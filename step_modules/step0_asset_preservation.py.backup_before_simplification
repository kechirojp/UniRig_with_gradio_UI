"""
Step 0 Module - シンプルファイル転送（2025年6月10日改訂版）
アップロードされたモデルをStep1に転送するだけのシンプル機能

新設計方針:
- アセット保存機能は完全廃止
- UV・マテリアル・テクスチャ構造の保存機能を完全廃止
- ファイル転送確認のみの最小限処理

責務: アップロードされたモデルファイル → Step1への転送確認
入力: 3Dモデルファイルパス (.glb, .fbx, .obj等)
出力: ファイル転送完了フラグのみ（空の辞書）
"""
import os
import logging
import time
from pathlib import Path
from typing import Tuple, Dict


class Step0FileTransfer:
    """Step 0: シンプルファイル転送モジュール（機能簡略化版）"""

    def __init__(self, model_name: str, input_file: str, output_dir: str, logger_instance: logging.Logger):
        """
        Step0初期化

        Args:
            model_name: モデル名
            input_file: アップロードされた3Dモデルファイルパス
            output_dir: 出力ディレクトリ（使用しないが互換性のため保持）
            logger_instance: ロガーインスタンス
        """
        self.model_name = model_name
        self.input_file = Path(input_file)
        self.output_dir = Path(output_dir)
        self.logger = logger_instance
        
        # 出力ディレクトリは作成しない（ファイル転送のみ）
        self.logger.info(f"Step0 ファイル転送初期化: {self.model_name}")
        self.logger.info(f"入力ファイル: {self.input_file}")

    def transfer_file(self) -> Tuple[bool, str, Dict]:
        """
        シンプルファイル転送処理（機能簡略化版）
        
        Returns:
            success: 転送成功フラグ
            logs: 転送ログ
            output_files: 空の辞書（ファイル出力なし）
        """
        start_time = time.time()
        
        try:
            self.logger.info(f"=== Step 0: {self.model_name} ファイル転送開始 ===")
            
            # 入力ファイル存在確認
            if not self.input_file.exists():
                error_msg = f"入力ファイルが存在しません: {self.input_file}"
                self.logger.error(error_msg)
                return False, error_msg, {}
            
            # ファイルサイズ確認
            file_size_mb = self.input_file.stat().st_size / (1024 * 1024)
            self.logger.info(f"ファイルサイズ: {file_size_mb:.1f}MB")
            
            # ファイル形式確認
            file_extension = self.input_file.suffix.lower()
            supported_formats = ['.glb', '.fbx', '.obj', '.gltf', '.ply', '.dae']
            
            if file_extension not in supported_formats:
                warning_msg = f"未確認のファイル形式: {file_extension} (サポート形式: {', '.join(supported_formats)})"
                self.logger.warning(warning_msg)
            else:
                self.logger.info(f"ファイル形式確認済み: {file_extension}")
            
            # 処理時間計算
            processing_time = time.time() - start_time
            
            success_log = (
                f"Step 0 ファイル転送完了: {self.input_file.name} "
                f"({file_size_mb:.1f}MB, {processing_time:.2f}秒)"
            )
            self.logger.info(success_log)
            
            # ファイル出力なし、転送準備完了のみ
            return True, success_log, {}
            
        except Exception as e:
            error_msg = f"Step 0 ファイル転送エラー: {str(e)}"
            self.logger.error(error_msg, exc_info=True)
            return False, error_msg, {}


# 新設計に基づく統一APIインターフェース
def transfer_file(input_file: str, model_name: str) -> Tuple[bool, str, Dict]:
    """
    Step0統一APIインターフェース - ファイル転送のみ（機能簡略化）
    
    Args:
        input_file: アップロードされた3Dモデルファイルパス
        model_name: モデル識別名
    
    Returns:
        success: True/False
        logs: "ファイル転送完了: /path/to/file" 
        output_files: {} (空の辞書・ファイル出力なし)
    """
    # 簡易ロガー作成
    logger = logging.getLogger(f"Step0_{model_name}")
    logger.setLevel(logging.INFO)
    
    # ハンドラーが既に存在しない場合のみ追加
    if not logger.handlers:
        handler = logging.StreamHandler()
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        logger.addHandler(handler)
    
    try:
        # ダミー出力ディレクトリ（使用しない）
        dummy_output_dir = "/tmp/step0_dummy"
        
        # Step0ファイル転送実行
        step0_processor = Step0FileTransfer(
            model_name=model_name,
            input_file=input_file,
            output_dir=dummy_output_dir,
            logger_instance=logger
        )
        
        return step0_processor.transfer_file()
        
    except Exception as e:
        error_msg = f"Step0統一API実行エラー: {str(e)}"
        logger.error(error_msg, exc_info=True)
        return False, error_msg, {}


# 互換性のための関数（使用非推奨・将来削除予定）
def preserve_assets(input_file: str, model_name: str, output_dir: str) -> Tuple[bool, str, Dict[str, str]]:
    """
    旧アセット保存API（互換性のみ・機能簡略化済み）
    
    注意: この関数は新設計では使用されません。
    transfer_file()関数を使用してください。
    """
    logger = logging.getLogger(f"Step0_Deprecated_{model_name}")
    logger.warning("preserve_assets()は非推奨です。transfer_file()を使用してください。")
    
    # 新しいtransfer_file()に転送
    success, logs, _ = transfer_file(input_file, model_name)
    
    # 旧形式のレスポンス（空の辞書）
    return success, logs, {}


if __name__ == "__main__":
    # テスト実行
    import sys
    
    if len(sys.argv) != 3:
        print("使用方法: python step0_asset_preservation.py <input_file> <model_name>")
        sys.exit(1)
    
    input_file = sys.argv[1]
    model_name = sys.argv[2]
    
    # ログ設定
    logging.basicConfig(level=logging.INFO)
    
    # Step0実行
    success, logs, output_files = transfer_file(input_file, model_name)
    
    print(f"\n=== Step0実行結果 ===")
    print(f"成功: {success}")
    print(f"ログ: {logs}")
    print(f"出力ファイル: {output_files}")
    
    if success:
        print("\n✅ Step0 ファイル転送成功")
    else:
        print("\n❌ Step0 ファイル転送失敗")
        sys.exit(1)
        """
        Preserves asset details (UVs, materials, textures) from the input model.
        Uses instance variables for input_file, model_name, and output_dir.

        Returns:
            success: True if preservation was successful, False otherwise.
            logs: A string containing log messages from the preservation process.
            output_files: A dictionary containing paths to the generated files.
        """
        self.logger.info(f"Starting asset preservation for {self.model_name}")
        start_time = time.time()

        input_model_path = self.input_file
        if not input_model_path.exists():
            error_msg = f"Input model file not found: {input_model_path}"
            self.logger.error(error_msg)
            return False, error_msg, {}

        model_specific_output_dir = self.output_dir
        model_specific_output_dir.mkdir(parents=True, exist_ok=True) 

        metadata_file_name = f"{self.model_name}_asset_metadata.json"
        metadata_file_path = model_specific_output_dir / metadata_file_name
        
        textures_dir_name = "textures" 
        textures_dir_path = model_specific_output_dir / textures_dir_name

        self.logger.info(f"Preserving assets for model '{self.model_name}' from '{input_model_path}'")
        self.logger.info(f"Output directory for this model/step: {model_specific_output_dir}")
        self.logger.info(f"Overall metadata file will be: {metadata_file_path}")
        self.logger.info(f"Textures subdirectory (created by Blender script): {textures_dir_path}")

        try:
            success, blender_logs, blender_output_data = self._extract_textures_with_blender(
                input_model_path_str=str(input_model_path),
                blender_script_output_dir_str=str(model_specific_output_dir),
                model_name=self.model_name
            )

            if not success:
                self.logger.error(f"Blender texture extraction failed. Logs: {blender_logs}")
                return False, f"Blender extraction failed: {blender_logs}", {}

            final_metadata = {
                "model_name": self.model_name,
                "original_model_path": str(input_model_path),
                "asset_preservation_output_dir": str(model_specific_output_dir),
                "preserved_textures_relative_dir": textures_dir_name, 
                "blender_extraction_data": blender_output_data, 
                "texture_files_reported_by_blender": [], 
                "final_texture_paths_in_step0_dir": [str(p.relative_to(model_specific_output_dir)) for p in textures_dir_path.glob('**/*') if p.is_file()] if textures_dir_path.exists() else []
            }
            
            if blender_output_data and isinstance(blender_output_data.get("textures_copied_map"), dict):
                final_metadata["texture_files_reported_by_blender"] = list(blender_output_data["textures_copied_map"].values())

            with open(metadata_file_path, 'w', encoding='utf-8') as f:
                json.dump(final_metadata, f, indent=4, ensure_ascii=False)
            
            self.logger.info(f"Asset metadata saved to: {metadata_file_path}")
            log_message = f"Asset preservation successful for {self.model_name}. Metadata: {metadata_file_path}, Textures in: {textures_dir_path}. Blender logs: {blender_logs}"
            
            output_files = {
                "asset_metadata_json": str(metadata_file_path),
                "preserved_textures_dir": str(textures_dir_path) 
            }
            if blender_output_data and blender_output_data.get("blender_json_output_path_in_script"):
                 output_files["blender_script_json_output"] = blender_output_data.get("blender_json_output_path_in_script")

            return True, log_message, output_files

        except Exception as e:
            error_msg = f"Error during asset preservation for {self.model_name}: {e}"
            self.logger.error(error_msg, exc_info=True)
            return False, error_msg, {}

    def _extract_textures_with_blender(self, input_model_path_str: str, blender_script_output_dir_str: str, model_name: str, timeout: int = 300) -> tuple[bool, str, dict]:
        """
        Blenderをバックグラウンドで実行し、テクスチャとマテリアル情報を抽出・保存します。

        Args:
            input_model_path_str: 解析対象の3Dモデルファイルの絶対パス。
            blender_script_output_dir_str: Blenderスクリプトが作業し、出力（texturesサブディレクトリ、自身のJSONデータファイル）を保存するディレクトリの絶対パス。
                                           例: /app/pipeline_work/mymodel/00_asset_preservation/
            model_name: モデル名。Blenderスクリプト内でファイル名などに使用されます。
            timeout: Blender実行のタイムアウト時間（秒）。

        Returns:
            (success, logs, extracted_data_dict)
            extracted_data_dict はBlenderスクリプトが生成したJSONファイルの内容です。
        """
        self.logger.info(f"Blender texture extraction process started for model: {model_name}")
        self.logger.debug(f"  Input model: {input_model_path_str}")
        self.logger.debug(f"  Blender script output dir: {blender_script_output_dir_str}")

        blender_script_work_dir = Path(blender_script_output_dir_str)
        blender_internal_json_filename = f"{model_name}_blender_texture_extraction_data.json"
        blender_internal_json_full_path = blender_script_work_dir / blender_internal_json_filename
        blender_internal_json_path_for_script_injection = str(blender_internal_json_full_path.as_posix())

        temp_script_filename = f"{model_name}_blender_asset_extraction_temp.py"
        temp_script_full_path = blender_script_work_dir / temp_script_filename

        # f-string内の辞書リテラルとネストされたフォーマットを避けるため、.format()を使用
        script_content = """
import bpy
import json
import os
import shutil
from pathlib import Path

INJECTED_INPUT_MODEL_PATH = r'{input_model_path}'
INJECTED_BLENDER_SCRIPT_OUTPUT_DIR = Path(r'{blender_script_output_dir}')
INJECTED_JSON_DATA_OUTPUT_PATH = Path(r'{json_output_path}')
INJECTED_MODEL_NAME = '{model_name}'

def get_image_users_and_paths(obj):
    image_info = []
    if obj.type == 'MESH':
        for mat_slot in obj.material_slots:
            if mat_slot.material:
                mat = mat_slot.material
                if mat.use_nodes:
                    for node in mat.node_tree.nodes:
                        if node.type == 'TEX_IMAGE':
                            if node.image:
                                image_path = bpy.path.abspath(node.image.filepath) if node.image.filepath else None
                                if image_path and os.path.exists(image_path):
                                    image_info.append({{
                                        "node_name": node.name,
                                        "node_type": node.type,
                                        "image_name": node.image.name,
                                        "original_path": image_path,
                                        "packed_file": node.image.packed_file is not None,
                                        "source": node.image.source,
                                    }})
                                elif node.image.packed_file:
                                     image_info.append({{
                                        "node_name": node.name,
                                        "node_type": node.type,
                                        "image_name": node.image.name,
                                        "original_path": "Packed into .blend",
                                        "packed_file": True,
                                        "source": node.image.source,
                                    }})
    return image_info

def extract_and_save_textures_main():
    print("Blender script: Using input model: " + INJECTED_INPUT_MODEL_PATH)
    print("Blender script: Script's designated output directory: " + str(INJECTED_BLENDER_SCRIPT_OUTPUT_DIR))
    print("Blender script: JSON data will be written to: " + str(INJECTED_JSON_DATA_OUTPUT_PATH))

    target_textures_dir = INJECTED_BLENDER_SCRIPT_OUTPUT_DIR / "textures"
    target_textures_dir.mkdir(parents=True, exist_ok=True)
    print("Blender script: Textures will be saved into: " + str(target_textures_dir))

    bpy.ops.wm.read_factory_settings(use_empty=True)
    
    model_file_ext = Path(INJECTED_INPUT_MODEL_PATH).suffix.lower()
    if model_file_ext in ['.glb', '.gltf']:
        bpy.ops.import_scene.gltf(filepath=INJECTED_INPUT_MODEL_PATH)
    elif model_file_ext == '.fbx':
        bpy.ops.import_scene.fbx(filepath=INJECTED_INPUT_MODEL_PATH)
    elif model_file_ext == '.obj':
        bpy.ops.import_scene.obj(filepath=INJECTED_INPUT_MODEL_PATH)
    else:
        error_message = "Unsupported file format: " + INJECTED_INPUT_MODEL_PATH
        print(error_message)
        return {{"error": error_message, "details": "File extension not supported for import."}}

    extracted_data = {{
        "model_name": INJECTED_MODEL_NAME,
        "original_model_path_in_script": INJECTED_INPUT_MODEL_PATH,
        "blender_script_output_dir_in_script": str(INJECTED_BLENDER_SCRIPT_OUTPUT_DIR),
        "blender_json_output_path_in_script": str(INJECTED_JSON_DATA_OUTPUT_PATH),
        "preserved_textures_relative_dir_in_script": "textures",
        "materials": [],
        "textures_copied_map": {{}}
    }}

    all_image_paths_to_copy = set()

    for obj in bpy.context.scene.objects:
        if obj.type == 'MESH':
            for slot in obj.material_slots:
                if slot.material:
                    mat = slot.material
                    material_info = {{"name": mat.name, "nodes": []}}
                    if mat.use_nodes:
                        for node in mat.node_tree.nodes:
                            node_info = {{"name": node.name, "type": node.type}}
                            if node.type == 'TEX_IMAGE' and node.image:
                                img = node.image
                                node_info["image_name"] = img.name
                                node_info["image_source"] = img.source
                                node_info["image_is_packed"] = img.packed_file is not None
                                original_filepath_abs = bpy.path.abspath(img.filepath) if img.filepath else "N/A"
                                node_info["image_original_filepath_abs"] = original_filepath_abs

                                if img.source == 'FILE' and img.filepath and os.path.exists(original_filepath_abs):
                                    all_image_paths_to_copy.add(original_filepath_abs)
                                    node_info["image_status"] = "Found at original path, will copy."
                                elif img.packed_file:
                                    temp_texture_name = Path(img.name).name
                                    if not Path(temp_texture_name).suffix and img.file_format:
                                        temp_texture_name = temp_texture_name + "." + img.file_format.lower()
                                    elif not Path(temp_texture_name).suffix:
                                        temp_texture_name = temp_texture_name + ".png"
                                    
                                    packed_save_path = target_textures_dir / temp_texture_name
                                    try:
                                        img.filepath_raw = str(packed_save_path) 
                                        img.save()
                                        if packed_save_path.exists():
                                            all_image_paths_to_copy.add(str(packed_save_path))
                                            node_info["image_status"] = "Packed, saved to " + str(packed_save_path)
                                        else:
                                            node_info["image_status"] = "Packed, failed to save to " + str(packed_save_path)
                                    except RuntimeError as e_save_packed:
                                        print("Error saving packed image " + img.name + " to " + str(packed_save_path) + ": " + str(e_save_packed))
                                        node_info["image_status"] = "Packed, error saving: " + str(e_save_packed)
                                else:
                                    node_info["image_status"] = "Not found or not a file-based/packed image."
                            material_info["nodes"].append(node_info)
                    extracted_data["materials"].append(material_info)

    for original_path_str in all_image_paths_to_copy:
        original_path = Path(original_path_str)
        if original_path.exists() and original_path.is_file():
            texture_filename = original_path.name
            new_texture_path_in_target = target_textures_dir / texture_filename
            
            if original_path.resolve() != new_texture_path_in_target.resolve():
                try:
                    shutil.copy2(original_path, new_texture_path_in_target)
                    print("Copied: " + str(original_path) + " -> " + str(new_texture_path_in_target))
                    extracted_data["textures_copied_map"][str(original_path)] = str(new_texture_path_in_target)
                except Exception as e_copy:
                    print("Error copying " + str(original_path) + " to " + str(new_texture_path_in_target) + ": " + str(e_copy))
            else:
                print("Texture " + str(original_path) + " is already in target directory or is the source itself.")
                extracted_data["textures_copied_map"][str(original_path)] = str(new_texture_path_in_target)

    for mat_info in extracted_data["materials"]:
        for node_info in mat_info.get("nodes", []):
            original_img_path = node_info.get("image_original_filepath_abs")
            if original_img_path and original_img_path in extracted_data["textures_copied_map"]:
                new_abs_path = extracted_data["textures_copied_map"][original_img_path]
                node_info["new_path_in_asset_preservation_step"] = str(Path(new_abs_path).relative_to(INJECTED_BLENDER_SCRIPT_OUTPUT_DIR))

    with open(INJECTED_JSON_DATA_OUTPUT_PATH, 'w', encoding='utf-8') as f:
        json.dump(extracted_data, f, indent=4, ensure_ascii=False)
    
    print("Blender script: Asset data saved to " + str(INJECTED_JSON_DATA_OUTPUT_PATH))
    return extracted_data

# Main execution block for the Blender script
if __name__ == '__main__':
    try:
        blender_script_output = extract_and_save_textures_main()
        print("Blender script execution finished successfully from Blender's perspective.")
    except Exception as e_blender:
        import traceback
        error_details = "Error in Blender script (extract_and_save_textures_main): " + str(e_blender) + "\\n" + traceback.format_exc()
        print(error_details)
        try:
            with open(INJECTED_JSON_DATA_OUTPUT_PATH, 'w', encoding='utf-8') as f_err:
                json.dump({{"error": str(e_blender), "traceback": traceback.format_exc(), "message": "Blender script failed during execution."}}, f_err, indent=4, ensure_ascii=False)
        except Exception as e_json_write_err:
            print("Additionally, failed to write error to JSON: " + str(e_json_write_err))
        raise
""".format(
            input_model_path=Path(input_model_path_str).as_posix(),
            blender_script_output_dir=Path(blender_script_output_dir_str).as_posix(),
            json_output_path=blender_internal_json_path_for_script_injection,
            model_name=model_name
        )
        self.logger.debug(f"Blender script content to be written to {temp_script_full_path}:\n{script_content[:1000]}...")
        
        blender_executable = os.getenv("BLENDER_EXECUTABLE", "blender")
        cmd = [blender_executable, "--background", "--python", str(temp_script_full_path)]
        
        try:
            with open(temp_script_full_path, "w", encoding="utf-8") as f_script:
                f_script.write(script_content)
            self.logger.info(f"Temporary Blender script saved to: {temp_script_full_path}")
            self.logger.info(f"Executing Blender command: {' '.join(cmd)}")

            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, encoding='utf-8')
            stdout, stderr = process.communicate(timeout=timeout)
            
            return_code_msg = f"Blender process return code: {process.returncode}."
            self.logger.info(return_code_msg)
            full_blender_logs = f"{return_code_msg}\nStdout:\n{stdout}\nStderr:\n{stderr}"

            if process.returncode == 0:
                self.logger.info("Blender script executed successfully (return code 0).")
                if blender_internal_json_full_path.exists():
                    with open(blender_internal_json_full_path, 'r', encoding='utf-8') as f_json_data:
                        blender_data_content = json.load(f_json_data)
                    if isinstance(blender_data_content, dict) and "error" in blender_data_content:
                        err_msg_from_json = f"Blender script reported an error in its JSON output: {blender_data_content.get('error')}"
                        self.logger.error(err_msg_from_json)
                        return False, f"{full_blender_logs}\n{err_msg_from_json}", blender_data_content
                    return True, full_blender_logs, blender_data_content
                else:
                    # This case (return code 0 but no JSON) should ideally not happen if the script is robust.
                    err_msg_no_json = f"Blender script finished (return code 0) but its output JSON not found: {blender_internal_json_full_path}"
                    self.logger.error(err_msg_no_json)
                    return False, f"{full_blender_logs}\nError: {err_msg_no_json}", {}
            else: # Non-zero return code from Blender
                self.logger.error(f"Blender script execution failed. Full logs:\n{full_blender_logs}")
                error_json_data = {}
                if blender_internal_json_full_path.exists():
                    try:
                        with open(blender_internal_json_full_path, 'r', encoding='utf-8') as f_err_json:
                            error_json_data = json.load(f_err_json)
                        self.logger.info(f"Blender error JSON content (if any): {error_json_data}")
                    except Exception as e_json_read:
                        self.logger.error(f"Could not read Blender's JSON output on error: {e_json_read}")
                return False, full_blender_logs, error_json_data

        except subprocess.TimeoutExpired:
            timeout_msg = f"Blender script timed out after {timeout} seconds."
            self.logger.error(timeout_msg)
            # Try to clean up temp script even on timeout
            if temp_script_full_path.exists(): temp_script_full_path.unlink(missing_ok=True)
            return False, timeout_msg, {}
        except FileNotFoundError:
            fnf_msg = f"Blender executable ('{blender_executable}') not found. Ensure Blender is installed and in PATH, or BLENDER_EXECUTABLE env var is set."
            self.logger.error(fnf_msg)
            # No need to clean up temp_script here as it might not have been created
            return False, fnf_msg, {}
        except Exception as e_exec:
            exec_err_msg = f"An unexpected error occurred while preparing or running Blender script: {e_exec}"
            self.logger.error(exec_err_msg, exc_info=True)
            if temp_script_full_path.exists(): temp_script_full_path.unlink(missing_ok=True)
            return False, exec_err_msg, {}
        finally:
            # Ensure cleanup in most cases, except for early FileNotFoundError for blender executable itself
            if temp_script_full_path.exists():
                try:
                    temp_script_full_path.unlink()
                    self.logger.info(f"Cleaned up temporary Blender script: {temp_script_full_path}")
                except OSError as e_unlink:
                    self.logger.warning(f"Could not delete temporary Blender script {temp_script_full_path}: {e_unlink}")

if __name__ == "__main__":
    # このテストブロックは、app.py から呼び出される際の動作を模倣します。
    # app.py の FileManager が適切な output_dir を生成して渡すことを想定しています。

    logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    main_logger = logging.getLogger(__name__)

    # --- 設定 ---
    test_model_name = "test_humanoid"
    # pipeline_work ディレクトリのベースパス (通常は /app/pipeline_work)
    # 環境変数などから取得するか、固定値を設定
    pipeline_work_base_str = os.getenv("PIPELINE_WORK_DIR", "/app/pipeline_work")
    pipeline_work_base = Path(pipeline_work_base_str)

    # FileManager が生成するであろう Step0 の出力ディレクトリパス
    # {PIPELINE_DIR}/{model_name}/00_asset_preservation/
    test_step0_output_dir = pipeline_work_base / test_model_name / "00_asset_preservation"
    test_step0_output_dir.mkdir(parents=True, exist_ok=True) # テスト用に作成

    # テスト用の入力ファイル (実際に存在するパスを指定してください)
    # 例: test_input_file = Path("/app/examples/models/test_humanoid.glb")
    # ここではダミーファイルを作成してテストします。
    # 実際のテストでは、有効なモデルファイルパスを指定してください。
    example_models_dir = Path("/app/examples/models") # 仮
    test_input_file = example_models_dir / f"{test_model_name}.glb" # 仮の入力ファイルパス

    if not test_input_file.parent.exists():
        test_input_file.parent.mkdir(parents=True, exist_ok=True)
    if not test_input_file.exists():
        try:
            with open(test_input_file, "w") as f:
                f.write("dummy glb content for testing") # ダミーファイル
            main_logger.info(f"Created dummy input file for testing: {test_input_file}")
        except IOError as e:
            main_logger.error(f"Could not create dummy input file {test_input_file}: {e}. Please provide a valid model file.")
            # exit(1) # 実際のテストでは有効なファイルがないと続行不可

    main_logger.info(f"--- Running Step0 Asset Preservation Test ---")
    main_logger.info(f"Model Name: {test_model_name}")
    main_logger.info(f"Input File: {test_input_file}")
    main_logger.info(f"Step0 Output Dir (simulating FileManager output): {test_step0_output_dir}")
    
    # Step0AssetPreservationのインスタンスを作成 (logger_instanceを使用)
    preserver = Step0AssetPreservation(
        model_name=test_model_name,
        input_file=str(test_input_file),
        output_dir=str(test_step0_output_dir),
        logger_instance=main_logger  # logger を logger_instance に修正
    )

    # preserve_assetsメソッドを実行
    success, log_message, output_files = preserver.preserve_assets()

    main_logger.info(f"Preservation Result: {'Success' if success else 'Failed'}")
    main_logger.info(f"Logs:\n{log_message}")
    main_logger.info(f"Output Files:\n{json.dumps(output_files, indent=2)}")

    if success:
        main_logger.info(f"Verifying outputs...")
        metadata_path = Path(output_files.get("asset_metadata_json", ""))
        textures_path = Path(output_files.get("preserved_textures_dir", ""))
        blender_json_path = Path(output_files.get("blender_json_output", ""))

        if metadata_path.exists():
            main_logger.info(f"  ✅ Metadata JSON exists: {metadata_path}")
        else:
            main_logger.error(f"  ❌ Metadata JSON NOT FOUND: {metadata_path}")
        
        if textures_path.exists() and textures_path.is_dir():
            main_logger.info(f"  ✅ Textures directory exists: {textures_path}")
            texture_contents = list(textures_path.iterdir())
            main_logger.info(f"  Textures directory contents ({len(texture_contents)} items): {[item.name for item in texture_contents[:5]]}")

        else:
            main_logger.error(f"  ❌ Textures directory NOT FOUND or is not a dir: {textures_path}")

        if blender_json_path.exists():
             main_logger.info(f"  ✅ Blender JSON output exists: {blender_json_path}")
        # else: # これはオプションなのでエラーとしない
        #     main_logger.warning(f"  ⚠️ Blender JSON output not found (optional): {blender_json_path}")
    else:
        main_logger.error("Asset preservation failed. Check logs for details.")
