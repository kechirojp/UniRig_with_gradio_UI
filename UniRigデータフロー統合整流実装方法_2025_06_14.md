# 🎯 UniRigデータフロー統合整流実装方法 - 2025年6月14日

## 📋 整流の定義と目的

**整流（せいりゅう）**: 分散・不整合だったデータフローを統一された方向に整理し、一貫性のある処理の流れを確立すること

**目的**: 
- ユーザー体験の向上（予測可能なファイル名、1クリックでの成果物取得）
- 開発効率の向上（デバッグ容易性、メンテナンス性）
- システム堅牢性の向上（エラー処理、状態管理の簡素化）

## 🚨 現状の問題点分析

### 1. 命名規則の混乱（最重要課題）
```
現在のファイル名パターン:
├── Step2: skeleton.fbx vs predict_skeleton.npz （不整合）
├── Step3: result_fbx.fbx vs skinned_model.fbx （予測困難）
├── Step4: 任意の名前 （統一性なし）
└── 結果: ユーザーが何をダウンロードして良いか分からない
```

### 2. 設定ファイルの重複定義
```yaml
# /app/configs/task/quick_inference_unirig_skin.yaml
writer:                    # 1回目の定義
  export_npz: "{model_name}_skinning"
  export_fbx: "{model_name}_skinned_unirig"
# ...
writer:                    # 2回目の定義（重複・競合）
  export_npz: predict_skin
  export_fbx: result_fbx
```

### 3. データフロー齟齬
```
Step2 → Step3 の連携問題:
├── Step2出力: skeleton.fbx
├── Step3期待: predict_skeleton.npz
└── 結果: ファイル名不一致によるパイプライン失敗
```

## 🎯 整流方法の具体的実装

### Phase 1: 固定ディレクトリ管理機能の強化

#### 1. `src/system/fixed_directory_manager.py` の改修
```python
class FixedDirectoryManager:
    """統一命名規則対応ディレクトリ管理"""
    
    def __init__(self, base_dir: str = "/app/pipeline_work"):
        self.base_dir = Path(base_dir)
        self.unified_naming = UnifiedNamingConvention()
    
    def get_unified_file_path(self, model_name: str, step: str, file_type: str) -> Path:
        """統一命名規則に基づくファイルパス取得"""
        step_dir = self.get_step_directory(model_name, step)
        return step_dir / self.unified_naming.get_file_name(model_name, step, file_type)
    
    def ensure_unified_output(self, model_name: str, step: str, 
                             original_file: Path, file_type: str) -> Path:
        """原流処理出力を統一命名規則にリネーム/コピー"""
        unified_path = self.get_unified_file_path(model_name, step, file_type)
        
        if original_file.exists() and original_file != unified_path:
            # 統一名でのコピー/リネーム
            shutil.copy2(original_file, unified_path)
            logger.info(f"統一命名規則適用: {original_file} → {unified_path}")
        
        return unified_path
```

#### 2. `UnifiedNamingConvention` クラスの実装
```python
class UnifiedNamingConvention:
    """統一ファイル命名規則の実装"""
    
    NAMING_PATTERNS = {
        'step1': {
            'mesh_npz': '{model_name}_mesh.npz',
        },
        'step2': {
            'skeleton_fbx': '{model_name}_skeleton.fbx',
            'skeleton_npz': '{model_name}_skeleton.npz',
        },
        'step3': {
            'skinned_fbx': '{model_name}_skinned.fbx',
            'skinning_npz': '{model_name}_skinning.npz',
        },
        'step4': {
            'merged_fbx': '{model_name}_merged.fbx',
        },
        'step5': {
            'rigged_fbx': '{model_name}_rigged.fbx',  # 最終成果物
        }
    }
    
    def get_file_name(self, model_name: str, step: str, file_type: str) -> str:
        """統一命名規則に基づくファイル名生成"""
        pattern = self.NAMING_PATTERNS.get(step, {}).get(file_type)
        if pattern:
            return pattern.format(model_name=model_name)
        else:
            raise ValueError(f"未定義の命名パターン: {step}/{file_type}")
```

### Phase 2: 統一Orchestrator実装

#### 1. `src/pipeline/unified_extract.py` の整流対応
```python
class UnifiedExtractor:
    def extract_mesh_unified(self, input_file: str, model_name: str, output_dir: str) -> dict:
        """統一命名規則対応メッシュ抽出"""
        
        # 1. 原流処理実行
        success, logs = self._execute_original_extract(input_file, output_dir)
        
        if success:
            # 2. 統一命名規則適用
            original_output = Path(output_dir) / "raw_data.npz"  # 原流出力
            unified_output = self.dir_manager.ensure_unified_output(
                model_name, 'step1', original_output, 'mesh_npz'
            )
            
            return {
                'success': True,
                'unified_files': {'mesh_npz': str(unified_output)},
                'logs': logs
            }
        
        return {'success': False, 'logs': logs}
```

#### 2. `src/pipeline/unified_skeleton.py` の整流対応
```python
class UnifiedSkeletonOrchestrator:
    def generate_skeleton_unified(self, model_name: str, mesh_file: str, 
                                 output_dir: str, gender: str = "neutral") -> dict:
        """統一命名規則対応スケルトン生成"""
        
        # 1. 原流処理実行
        success, logs = self._execute_original_skeleton_generation(
            mesh_file, output_dir, gender
        )
        
        if success:
            # 2. 統一命名規則適用
            original_fbx = Path(output_dir) / "skeleton_model.fbx"  # 原流FBX
            original_npz = Path(output_dir) / "predict_skeleton.npz"  # 原流NPZ
            
            unified_fbx = self.dir_manager.ensure_unified_output(
                model_name, 'step2', original_fbx, 'skeleton_fbx'
            )
            unified_npz = self.dir_manager.ensure_unified_output(
                model_name, 'step2', original_npz, 'skeleton_npz'
            )
            
            return {
                'success': True,
                'unified_files': {
                    'skeleton_fbx': str(unified_fbx),
                    'skeleton_npz': str(unified_npz)
                },
                'logs': logs
            }
        
        return {'success': False, 'logs': logs}
```

### Phase 3: 設定ファイル整流

#### 1. `configs/task/quick_inference_skeleton_articulationxl_ar_256.yaml` 修正
```yaml
# 決め打ち修正: 統一命名規則対応
task: inference
writer:
  export_fbx: skeleton_model      # ✅ 修正: 統一名
  export_npz: predict_skeleton    # ✅ 維持: 原流処理期待値

# 実験名も統一
experiment_name: quick_inference_skeleton_unified
```

#### 2. `configs/task/quick_inference_unirig_skin.yaml` 修正
```yaml
# 重複定義完全除去
task: inference
writer:
  export_npz: predict_skin        # ✅ 統一: 原流処理期待値
  export_fbx: skinned_model       # ✅ 統一: 統一命名規則

# 重複writer定義を完全削除
# writer: ... （削除）

experiment_name: quick_inference_unirig_skin_unified
```

### Phase 4: Shell Script整流

#### 1. `launch/inference/generate_skeleton.sh` 修正
```bash
#!/bin/bash
# 統一パラメータ対応

# パラメータ定義
input_file="$1"
output_dir="$2"
model_name="$3"  # 新規: 統一命名規則用

# デフォルト値
output_dir=${output_dir:-"results"}
model_name=${model_name:-"unknown"}

# Stage 1: メッシュ抽出（統一命名規則対応）
echo "Step1: メッシュ抽出開始"
python -m src.data.extract \
    --input_file="$input_file" \
    --output_dir="$output_dir" \
    --model_name="$model_name"

# Stage 2: スケルトン生成（統一命名規則対応）
echo "Step2: スケルトン生成開始"
python run.py \
    --task=configs/task/quick_inference_skeleton_articulationxl_ar_256.yaml \
    --output_dir="$output_dir" \
    --model_name="$model_name"

# 統一命名規則適用
echo "統一命名規則適用中..."
if [ -f "$output_dir/skeleton_model.fbx" ]; then
    cp "$output_dir/skeleton_model.fbx" "$output_dir/${model_name}_skeleton.fbx"
    echo "✅ 統一FBX作成: ${model_name}_skeleton.fbx"
fi

if [ -f "$output_dir/predict_skeleton.npz" ]; then
    cp "$output_dir/predict_skeleton.npz" "$output_dir/${model_name}_skeleton.npz"
    echo "✅ 統一NPZ作成: ${model_name}_skeleton.npz"
fi
```

#### 2. `launch/inference/generate_skin.sh` 修正
```bash
#!/bin/bash
# 統一パラメータ対応

mesh_file="$1"
skeleton_dir="$2"
output_dir="$3"
model_name="$4"  # 新規: 統一命名規則用

# デフォルト値
output_dir=${output_dir:-"results"}
model_name=${model_name:-"unknown"}

# メッシュ抽出（統一命名規則対応）
echo "Step1: メッシュ抽出（スキニング用）"
python -m src.data.extract \
    --input_file="$mesh_file" \
    --output_dir="$output_dir" \
    --model_name="$model_name"

# スキニング適用（統一命名規則対応）
echo "Step3: スキニング適用開始"
python run.py \
    --task=configs/task/quick_inference_unirig_skin.yaml \
    --output_dir="$output_dir" \
    --npz_dir="$skeleton_dir" \
    --model_name="$model_name"

# 統一命名規則適用
echo "統一命名規則適用中..."
if [ -f "$output_dir/skinned_model.fbx" ]; then
    cp "$output_dir/skinned_model.fbx" "$output_dir/${model_name}_skinned.fbx"
    echo "✅ 統一FBX作成: ${model_name}_skinned.fbx"
fi

if [ -f "$output_dir/predict_skin.npz" ]; then
    cp "$output_dir/predict_skin.npz" "$output_dir/${model_name}_skinning.npz"
    echo "✅ 統一NPZ作成: ${model_name}_skinning.npz"
fi
```

### Phase 5: app.py統合改修

#### 統一命名規則対応UI改修
```python
def execute_step2_skeleton(model_name: str, input_file: str, gender: str = "neutral"):
    """Step2: 統一命名規則対応スケルトン生成"""
    
    # 統一Orchestrator使用
    orchestrator = UnifiedSkeletonOrchestrator()
    result = orchestrator.generate_skeleton_unified(
        model_name=model_name,
        mesh_file=input_file,
        output_dir=f"/app/pipeline_work/{model_name}/02_skeleton",
        gender=gender
    )
    
    if result['success']:
        # ユーザー向け成果物情報
        skeleton_fbx = result['unified_files']['skeleton_fbx']
        return {
            'success': True,
            'message': f"✅ {model_name}のスケルトン生成完了",
            'download_files': {
                'skeleton': skeleton_fbx,  # ユーザーがダウンロード可能
            },
            'logs': result['logs']
        }
    else:
        return {
            'success': False,
            'message': f"❌ {model_name}のスケルトン生成失敗",
            'logs': result['logs']
        }
```

## 🎯 整流の期待効果

### 1. ユーザー体験の向上
```bash
# 改修前: 複雑で予測困難
複数ファイル名 → 何をダウンロード？ → 手動マージ？

# 改修後: シンプルで予測可能
{model_name}_rigged.fbx → 1クリックダウンロード → 即座に利用可能
```

### 2. 開発効率の向上
```bash
# 改修前: デバッグ困難
"predict_skeleton.npz が見つからない" → どこにある？

# 改修後: デバッグ容易
"bird_skeleton.npz が見つからない" → 02_skeleton/ディレクトリ確認
```

### 3. システム堅牢性の向上
```bash
# 改修前: 複雑なフォールバック処理
多数のファイル名パターン → 複雑なエラー処理

# 改修後: シンプルな状態管理
統一ファイル名 → 予測可能な処理フロー
```

## 🚨 実装時の注意事項

### 1. 段階的実装（重要）
```
Phase 1: FixedDirectoryManager統一対応
Phase 2: Orchestrator統一対応
Phase 3: 設定ファイル整流
Phase 4: Shell Script整流
Phase 5: app.py統合改修
```

### 2. 既存データとの互換性
```python
# フォールバック機能の実装
def find_file_with_fallback(model_name: str, step: str, file_type: str) -> Path:
    """統一命名規則ファイル + 既存ファイルのフォールバック検索"""
    
    # 1. 統一命名規則ファイル検索
    unified_path = get_unified_file_path(model_name, step, file_type)
    if unified_path.exists():
        return unified_path
    
    # 2. 既存命名規則ファイル検索（フォールバック）
    legacy_patterns = get_legacy_patterns(step, file_type)
    for pattern in legacy_patterns:
        legacy_path = Path(pattern.format(model_name=model_name))
        if legacy_path.exists():
            logger.warning(f"⚠️ レガシーファイル使用: {legacy_path}")
            return legacy_path
    
    raise FileNotFoundError(f"ファイルが見つかりません: {model_name}/{step}/{file_type}")
```

### 3. テスト駆動実装
```python
# 整流機能の単体テスト
def test_unified_naming_convention():
    """統一命名規則テスト"""
    naming = UnifiedNamingConvention()
    
    # Step2スケルトンファイル名テスト
    assert naming.get_file_name("bird", "step2", "skeleton_fbx") == "bird_skeleton.fbx"
    assert naming.get_file_name("bird", "step2", "skeleton_npz") == "bird_skeleton.npz"
    
    # Step5最終成果物テスト
    assert naming.get_file_name("bird", "step5", "rigged_fbx") == "bird_rigged.fbx"
```

## 📋 実装チェックリスト

### Phase 1: ディレクトリ管理整流
- [ ] `FixedDirectoryManager` の統一命名規則対応
- [ ] `UnifiedNamingConvention` クラス実装
- [ ] フォールバック機能実装

### Phase 2: Orchestrator整流
- [ ] `unified_extract.py` の統一命名規則対応
- [ ] `unified_skeleton.py` の統一命名規則対応
- [ ] `unified_skinning.py` の統一命名規則対応
- [ ] `unified_merge.py` の統一命名規則対応
- [ ] `unified_blender.py` の統一命名規則対応

### Phase 3: 設定ファイル整流
- [ ] `quick_inference_skeleton_articulationxl_ar_256.yaml` 修正
- [ ] `quick_inference_unirig_skin.yaml` 重複定義除去
- [ ] 設定ファイル整合性確認

### Phase 4: Shell Script整流
- [ ] `generate_skeleton.sh` 統一パラメータ対応
- [ ] `generate_skin.sh` 統一パラメータ対応
- [ ] `merge.sh` 統一パラメータ対応

### Phase 5: app.py統合整流
- [ ] 統一命名規則対応UI実装
- [ ] ユーザー向けダウンロード機能改修
- [ ] エラーメッセージ改善

### Phase 6: 最終検証
- [ ] エンドツーエンドテスト
- [ ] 既存データ互換性確認
- [ ] ユーザー体験確認

---

**この整流実装により、UniRigは技術的複雑さを隠蔽し、ユーザーにとってシンプルで予測可能な3Dリギングシステムとなります。**
