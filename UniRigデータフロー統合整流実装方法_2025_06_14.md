# ğŸ¯ UniRigãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼çµ±åˆæ•´æµå®Ÿè£…æ–¹æ³• - 2025å¹´6æœˆ14æ—¥

## ğŸ“‹ æ•´æµã®å®šç¾©ã¨ç›®çš„

**æ•´æµï¼ˆã›ã„ã‚Šã‚…ã†ï¼‰**: åˆ†æ•£ãƒ»ä¸æ•´åˆã ã£ãŸãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼ã‚’çµ±ä¸€ã•ã‚ŒãŸæ–¹å‘ã«æ•´ç†ã—ã€ä¸€è²«æ€§ã®ã‚ã‚‹å‡¦ç†ã®æµã‚Œã‚’ç¢ºç«‹ã™ã‚‹ã“ã¨

**ç›®çš„**: 
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã®å‘ä¸Šï¼ˆäºˆæ¸¬å¯èƒ½ãªãƒ•ã‚¡ã‚¤ãƒ«åã€1ã‚¯ãƒªãƒƒã‚¯ã§ã®æˆæœç‰©å–å¾—ï¼‰
- é–‹ç™ºåŠ¹ç‡ã®å‘ä¸Šï¼ˆãƒ‡ãƒãƒƒã‚°å®¹æ˜“æ€§ã€ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹æ€§ï¼‰
- ã‚·ã‚¹ãƒ†ãƒ å …ç‰¢æ€§ã®å‘ä¸Šï¼ˆã‚¨ãƒ©ãƒ¼å‡¦ç†ã€çŠ¶æ…‹ç®¡ç†ã®ç°¡ç´ åŒ–ï¼‰

## ğŸš¨ ç¾çŠ¶ã®å•é¡Œç‚¹åˆ†æ

### 1. å‘½åè¦å‰‡ã®æ··ä¹±ï¼ˆæœ€é‡è¦èª²é¡Œï¼‰
```
ç¾åœ¨ã®ãƒ•ã‚¡ã‚¤ãƒ«åãƒ‘ã‚¿ãƒ¼ãƒ³:
â”œâ”€â”€ Step2: skeleton.fbx vs predict_skeleton.npz ï¼ˆä¸æ•´åˆï¼‰
â”œâ”€â”€ Step3: result_fbx.fbx vs skinned_model.fbx ï¼ˆäºˆæ¸¬å›°é›£ï¼‰
â”œâ”€â”€ Step4: ä»»æ„ã®åå‰ ï¼ˆçµ±ä¸€æ€§ãªã—ï¼‰
â””â”€â”€ çµæœ: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒä½•ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦è‰¯ã„ã‹åˆ†ã‹ã‚‰ãªã„
```

### 2. è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®é‡è¤‡å®šç¾©
```yaml
# /app/configs/task/quick_inference_unirig_skin.yaml
writer:                    # 1å›ç›®ã®å®šç¾©
  export_npz: "{model_name}_skinning"
  export_fbx: "{model_name}_skinned_unirig"
# ...
writer:                    # 2å›ç›®ã®å®šç¾©ï¼ˆé‡è¤‡ãƒ»ç«¶åˆï¼‰
  export_npz: predict_skin
  export_fbx: result_fbx
```

### 3. ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼é½Ÿé½¬
```
Step2 â†’ Step3 ã®é€£æºå•é¡Œ:
â”œâ”€â”€ Step2å‡ºåŠ›: skeleton.fbx
â”œâ”€â”€ Step3æœŸå¾…: predict_skeleton.npz
â””â”€â”€ çµæœ: ãƒ•ã‚¡ã‚¤ãƒ«åä¸ä¸€è‡´ã«ã‚ˆã‚‹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å¤±æ•—
```

## ğŸ¯ æ•´æµæ–¹æ³•ã®å…·ä½“çš„å®Ÿè£…

### Phase 1: å›ºå®šãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªç®¡ç†æ©Ÿèƒ½ã®å¼·åŒ–

#### 1. `src/system/fixed_directory_manager.py` ã®æ”¹ä¿®
```python
class FixedDirectoryManager:
    """çµ±ä¸€å‘½åè¦å‰‡å¯¾å¿œãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªç®¡ç†"""
    
    def __init__(self, base_dir: str = "/app/pipeline_work"):
        self.base_dir = Path(base_dir)
        self.unified_naming = UnifiedNamingConvention()
    
    def get_unified_file_path(self, model_name: str, step: str, file_type: str) -> Path:
        """çµ±ä¸€å‘½åè¦å‰‡ã«åŸºã¥ããƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹å–å¾—"""
        step_dir = self.get_step_directory(model_name, step)
        return step_dir / self.unified_naming.get_file_name(model_name, step, file_type)
    
    def ensure_unified_output(self, model_name: str, step: str, 
                             original_file: Path, file_type: str) -> Path:
        """åŸæµå‡¦ç†å‡ºåŠ›ã‚’çµ±ä¸€å‘½åè¦å‰‡ã«ãƒªãƒãƒ¼ãƒ /ã‚³ãƒ”ãƒ¼"""
        unified_path = self.get_unified_file_path(model_name, step, file_type)
        
        if original_file.exists() and original_file != unified_path:
            # çµ±ä¸€åã§ã®ã‚³ãƒ”ãƒ¼/ãƒªãƒãƒ¼ãƒ 
            shutil.copy2(original_file, unified_path)
            logger.info(f"çµ±ä¸€å‘½åè¦å‰‡é©ç”¨: {original_file} â†’ {unified_path}")
        
        return unified_path
```

#### 2. `UnifiedNamingConvention` ã‚¯ãƒ©ã‚¹ã®å®Ÿè£…
```python
class UnifiedNamingConvention:
    """çµ±ä¸€ãƒ•ã‚¡ã‚¤ãƒ«å‘½åè¦å‰‡ã®å®Ÿè£…"""
    
    NAMING_PATTERNS = {
        'step1': {
            'mesh_npz': '{model_name}_mesh.npz',
        },
        'step2': {
            'skeleton_fbx': '{model_name}_skeleton.fbx',
            'skeleton_npz': '{model_name}_skeleton.npz',
        },
        'step3': {
            'skinned_fbx': '{model_name}_skinned.fbx',
            'skinning_npz': '{model_name}_skinning.npz',
        },
        'step4': {
            'merged_fbx': '{model_name}_merged.fbx',
        },
        'step5': {
            'rigged_fbx': '{model_name}_rigged.fbx',  # æœ€çµ‚æˆæœç‰©
        }
    }
    
    def get_file_name(self, model_name: str, step: str, file_type: str) -> str:
        """çµ±ä¸€å‘½åè¦å‰‡ã«åŸºã¥ããƒ•ã‚¡ã‚¤ãƒ«åç”Ÿæˆ"""
        pattern = self.NAMING_PATTERNS.get(step, {}).get(file_type)
        if pattern:
            return pattern.format(model_name=model_name)
        else:
            raise ValueError(f"æœªå®šç¾©ã®å‘½åãƒ‘ã‚¿ãƒ¼ãƒ³: {step}/{file_type}")
```

### Phase 2: çµ±ä¸€Orchestratorå®Ÿè£…

#### 1. `src/pipeline/unified_extract.py` ã®æ•´æµå¯¾å¿œ
```python
class UnifiedExtractor:
    def extract_mesh_unified(self, input_file: str, model_name: str, output_dir: str) -> dict:
        """çµ±ä¸€å‘½åè¦å‰‡å¯¾å¿œãƒ¡ãƒƒã‚·ãƒ¥æŠ½å‡º"""
        
        # 1. åŸæµå‡¦ç†å®Ÿè¡Œ
        success, logs = self._execute_original_extract(input_file, output_dir)
        
        if success:
            # 2. çµ±ä¸€å‘½åè¦å‰‡é©ç”¨
            original_output = Path(output_dir) / "raw_data.npz"  # åŸæµå‡ºåŠ›
            unified_output = self.dir_manager.ensure_unified_output(
                model_name, 'step1', original_output, 'mesh_npz'
            )
            
            return {
                'success': True,
                'unified_files': {'mesh_npz': str(unified_output)},
                'logs': logs
            }
        
        return {'success': False, 'logs': logs}
```

#### 2. `src/pipeline/unified_skeleton.py` ã®æ•´æµå¯¾å¿œ
```python
class UnifiedSkeletonOrchestrator:
    def generate_skeleton_unified(self, model_name: str, mesh_file: str, 
                                 output_dir: str, gender: str = "neutral") -> dict:
        """çµ±ä¸€å‘½åè¦å‰‡å¯¾å¿œã‚¹ã‚±ãƒ«ãƒˆãƒ³ç”Ÿæˆ"""
        
        # 1. åŸæµå‡¦ç†å®Ÿè¡Œ
        success, logs = self._execute_original_skeleton_generation(
            mesh_file, output_dir, gender
        )
        
        if success:
            # 2. çµ±ä¸€å‘½åè¦å‰‡é©ç”¨
            original_fbx = Path(output_dir) / "skeleton_model.fbx"  # åŸæµFBX
            original_npz = Path(output_dir) / "predict_skeleton.npz"  # åŸæµNPZ
            
            unified_fbx = self.dir_manager.ensure_unified_output(
                model_name, 'step2', original_fbx, 'skeleton_fbx'
            )
            unified_npz = self.dir_manager.ensure_unified_output(
                model_name, 'step2', original_npz, 'skeleton_npz'
            )
            
            return {
                'success': True,
                'unified_files': {
                    'skeleton_fbx': str(unified_fbx),
                    'skeleton_npz': str(unified_npz)
                },
                'logs': logs
            }
        
        return {'success': False, 'logs': logs}
```

### Phase 3: è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«æ•´æµ

#### 1. `configs/task/quick_inference_skeleton_articulationxl_ar_256.yaml` ä¿®æ­£
```yaml
# æ±ºã‚æ‰“ã¡ä¿®æ­£: çµ±ä¸€å‘½åè¦å‰‡å¯¾å¿œ
task: inference
writer:
  export_fbx: skeleton_model      # âœ… ä¿®æ­£: çµ±ä¸€å
  export_npz: predict_skeleton    # âœ… ç¶­æŒ: åŸæµå‡¦ç†æœŸå¾…å€¤

# å®Ÿé¨“åã‚‚çµ±ä¸€
experiment_name: quick_inference_skeleton_unified
```

#### 2. `configs/task/quick_inference_unirig_skin.yaml` ä¿®æ­£
```yaml
# é‡è¤‡å®šç¾©å®Œå…¨é™¤å»
task: inference
writer:
  export_npz: predict_skin        # âœ… çµ±ä¸€: åŸæµå‡¦ç†æœŸå¾…å€¤
  export_fbx: skinned_model       # âœ… çµ±ä¸€: çµ±ä¸€å‘½åè¦å‰‡

# é‡è¤‡writerå®šç¾©ã‚’å®Œå…¨å‰Šé™¤
# writer: ... ï¼ˆå‰Šé™¤ï¼‰

experiment_name: quick_inference_unirig_skin_unified
```

### Phase 4: Shell Scriptæ•´æµ

#### 1. `launch/inference/generate_skeleton.sh` ä¿®æ­£
```bash
#!/bin/bash
# çµ±ä¸€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å¯¾å¿œ

# ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å®šç¾©
input_file="$1"
output_dir="$2"
model_name="$3"  # æ–°è¦: çµ±ä¸€å‘½åè¦å‰‡ç”¨

# ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
output_dir=${output_dir:-"results"}
model_name=${model_name:-"unknown"}

# Stage 1: ãƒ¡ãƒƒã‚·ãƒ¥æŠ½å‡ºï¼ˆçµ±ä¸€å‘½åè¦å‰‡å¯¾å¿œï¼‰
echo "Step1: ãƒ¡ãƒƒã‚·ãƒ¥æŠ½å‡ºé–‹å§‹"
python -m src.data.extract \
    --input_file="$input_file" \
    --output_dir="$output_dir" \
    --model_name="$model_name"

# Stage 2: ã‚¹ã‚±ãƒ«ãƒˆãƒ³ç”Ÿæˆï¼ˆçµ±ä¸€å‘½åè¦å‰‡å¯¾å¿œï¼‰
echo "Step2: ã‚¹ã‚±ãƒ«ãƒˆãƒ³ç”Ÿæˆé–‹å§‹"
python run.py \
    --task=configs/task/quick_inference_skeleton_articulationxl_ar_256.yaml \
    --output_dir="$output_dir" \
    --model_name="$model_name"

# çµ±ä¸€å‘½åè¦å‰‡é©ç”¨
echo "çµ±ä¸€å‘½åè¦å‰‡é©ç”¨ä¸­..."
if [ -f "$output_dir/skeleton_model.fbx" ]; then
    cp "$output_dir/skeleton_model.fbx" "$output_dir/${model_name}_skeleton.fbx"
    echo "âœ… çµ±ä¸€FBXä½œæˆ: ${model_name}_skeleton.fbx"
fi

if [ -f "$output_dir/predict_skeleton.npz" ]; then
    cp "$output_dir/predict_skeleton.npz" "$output_dir/${model_name}_skeleton.npz"
    echo "âœ… çµ±ä¸€NPZä½œæˆ: ${model_name}_skeleton.npz"
fi
```

#### 2. `launch/inference/generate_skin.sh` ä¿®æ­£
```bash
#!/bin/bash
# çµ±ä¸€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å¯¾å¿œ

mesh_file="$1"
skeleton_dir="$2"
output_dir="$3"
model_name="$4"  # æ–°è¦: çµ±ä¸€å‘½åè¦å‰‡ç”¨

# ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
output_dir=${output_dir:-"results"}
model_name=${model_name:-"unknown"}

# ãƒ¡ãƒƒã‚·ãƒ¥æŠ½å‡ºï¼ˆçµ±ä¸€å‘½åè¦å‰‡å¯¾å¿œï¼‰
echo "Step1: ãƒ¡ãƒƒã‚·ãƒ¥æŠ½å‡ºï¼ˆã‚¹ã‚­ãƒ‹ãƒ³ã‚°ç”¨ï¼‰"
python -m src.data.extract \
    --input_file="$mesh_file" \
    --output_dir="$output_dir" \
    --model_name="$model_name"

# ã‚¹ã‚­ãƒ‹ãƒ³ã‚°é©ç”¨ï¼ˆçµ±ä¸€å‘½åè¦å‰‡å¯¾å¿œï¼‰
echo "Step3: ã‚¹ã‚­ãƒ‹ãƒ³ã‚°é©ç”¨é–‹å§‹"
python run.py \
    --task=configs/task/quick_inference_unirig_skin.yaml \
    --output_dir="$output_dir" \
    --npz_dir="$skeleton_dir" \
    --model_name="$model_name"

# çµ±ä¸€å‘½åè¦å‰‡é©ç”¨
echo "çµ±ä¸€å‘½åè¦å‰‡é©ç”¨ä¸­..."
if [ -f "$output_dir/skinned_model.fbx" ]; then
    cp "$output_dir/skinned_model.fbx" "$output_dir/${model_name}_skinned.fbx"
    echo "âœ… çµ±ä¸€FBXä½œæˆ: ${model_name}_skinned.fbx"
fi

if [ -f "$output_dir/predict_skin.npz" ]; then
    cp "$output_dir/predict_skin.npz" "$output_dir/${model_name}_skinning.npz"
    echo "âœ… çµ±ä¸€NPZä½œæˆ: ${model_name}_skinning.npz"
fi
```

### Phase 5: app.pyçµ±åˆæ”¹ä¿®

#### çµ±ä¸€å‘½åè¦å‰‡å¯¾å¿œUIæ”¹ä¿®
```python
def execute_step2_skeleton(model_name: str, input_file: str, gender: str = "neutral"):
    """Step2: çµ±ä¸€å‘½åè¦å‰‡å¯¾å¿œã‚¹ã‚±ãƒ«ãƒˆãƒ³ç”Ÿæˆ"""
    
    # çµ±ä¸€Orchestratorä½¿ç”¨
    orchestrator = UnifiedSkeletonOrchestrator()
    result = orchestrator.generate_skeleton_unified(
        model_name=model_name,
        mesh_file=input_file,
        output_dir=f"/app/pipeline_work/{model_name}/02_skeleton",
        gender=gender
    )
    
    if result['success']:
        # ãƒ¦ãƒ¼ã‚¶ãƒ¼å‘ã‘æˆæœç‰©æƒ…å ±
        skeleton_fbx = result['unified_files']['skeleton_fbx']
        return {
            'success': True,
            'message': f"âœ… {model_name}ã®ã‚¹ã‚±ãƒ«ãƒˆãƒ³ç”Ÿæˆå®Œäº†",
            'download_files': {
                'skeleton': skeleton_fbx,  # ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å¯èƒ½
            },
            'logs': result['logs']
        }
    else:
        return {
            'success': False,
            'message': f"âŒ {model_name}ã®ã‚¹ã‚±ãƒ«ãƒˆãƒ³ç”Ÿæˆå¤±æ•—",
            'logs': result['logs']
        }
```

## ğŸ¯ æ•´æµã®æœŸå¾…åŠ¹æœ

### 1. ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã®å‘ä¸Š
```bash
# æ”¹ä¿®å‰: è¤‡é›‘ã§äºˆæ¸¬å›°é›£
è¤‡æ•°ãƒ•ã‚¡ã‚¤ãƒ«å â†’ ä½•ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ï¼Ÿ â†’ æ‰‹å‹•ãƒãƒ¼ã‚¸ï¼Ÿ

# æ”¹ä¿®å¾Œ: ã‚·ãƒ³ãƒ—ãƒ«ã§äºˆæ¸¬å¯èƒ½
{model_name}_rigged.fbx â†’ 1ã‚¯ãƒªãƒƒã‚¯ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ â†’ å³åº§ã«åˆ©ç”¨å¯èƒ½
```

### 2. é–‹ç™ºåŠ¹ç‡ã®å‘ä¸Š
```bash
# æ”¹ä¿®å‰: ãƒ‡ãƒãƒƒã‚°å›°é›£
"predict_skeleton.npz ãŒè¦‹ã¤ã‹ã‚‰ãªã„" â†’ ã©ã“ã«ã‚ã‚‹ï¼Ÿ

# æ”¹ä¿®å¾Œ: ãƒ‡ãƒãƒƒã‚°å®¹æ˜“
"bird_skeleton.npz ãŒè¦‹ã¤ã‹ã‚‰ãªã„" â†’ 02_skeleton/ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªç¢ºèª
```

### 3. ã‚·ã‚¹ãƒ†ãƒ å …ç‰¢æ€§ã®å‘ä¸Š
```bash
# æ”¹ä¿®å‰: è¤‡é›‘ãªãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†
å¤šæ•°ã®ãƒ•ã‚¡ã‚¤ãƒ«åãƒ‘ã‚¿ãƒ¼ãƒ³ â†’ è¤‡é›‘ãªã‚¨ãƒ©ãƒ¼å‡¦ç†

# æ”¹ä¿®å¾Œ: ã‚·ãƒ³ãƒ—ãƒ«ãªçŠ¶æ…‹ç®¡ç†
çµ±ä¸€ãƒ•ã‚¡ã‚¤ãƒ«å â†’ äºˆæ¸¬å¯èƒ½ãªå‡¦ç†ãƒ•ãƒ­ãƒ¼
```

## ğŸš¨ å®Ÿè£…æ™‚ã®æ³¨æ„äº‹é …

### 1. æ®µéšçš„å®Ÿè£…ï¼ˆé‡è¦ï¼‰
```
Phase 1: FixedDirectoryManagerçµ±ä¸€å¯¾å¿œ
Phase 2: Orchestratorçµ±ä¸€å¯¾å¿œ
Phase 3: è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«æ•´æµ
Phase 4: Shell Scriptæ•´æµ
Phase 5: app.pyçµ±åˆæ”¹ä¿®
```

### 2. æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã¨ã®äº’æ›æ€§
```python
# ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½ã®å®Ÿè£…
def find_file_with_fallback(model_name: str, step: str, file_type: str) -> Path:
    """çµ±ä¸€å‘½åè¦å‰‡ãƒ•ã‚¡ã‚¤ãƒ« + æ—¢å­˜ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ¤œç´¢"""
    
    # 1. çµ±ä¸€å‘½åè¦å‰‡ãƒ•ã‚¡ã‚¤ãƒ«æ¤œç´¢
    unified_path = get_unified_file_path(model_name, step, file_type)
    if unified_path.exists():
        return unified_path
    
    # 2. æ—¢å­˜å‘½åè¦å‰‡ãƒ•ã‚¡ã‚¤ãƒ«æ¤œç´¢ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
    legacy_patterns = get_legacy_patterns(step, file_type)
    for pattern in legacy_patterns:
        legacy_path = Path(pattern.format(model_name=model_name))
        if legacy_path.exists():
            logger.warning(f"âš ï¸ ãƒ¬ã‚¬ã‚·ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ä½¿ç”¨: {legacy_path}")
            return legacy_path
    
    raise FileNotFoundError(f"ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {model_name}/{step}/{file_type}")
```

### 3. ãƒ†ã‚¹ãƒˆé§†å‹•å®Ÿè£…
```python
# æ•´æµæ©Ÿèƒ½ã®å˜ä½“ãƒ†ã‚¹ãƒˆ
def test_unified_naming_convention():
    """çµ±ä¸€å‘½åè¦å‰‡ãƒ†ã‚¹ãƒˆ"""
    naming = UnifiedNamingConvention()
    
    # Step2ã‚¹ã‚±ãƒ«ãƒˆãƒ³ãƒ•ã‚¡ã‚¤ãƒ«åãƒ†ã‚¹ãƒˆ
    assert naming.get_file_name("bird", "step2", "skeleton_fbx") == "bird_skeleton.fbx"
    assert naming.get_file_name("bird", "step2", "skeleton_npz") == "bird_skeleton.npz"
    
    # Step5æœ€çµ‚æˆæœç‰©ãƒ†ã‚¹ãƒˆ
    assert naming.get_file_name("bird", "step5", "rigged_fbx") == "bird_rigged.fbx"
```

## ğŸ“‹ å®Ÿè£…ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

### Phase 1: ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªç®¡ç†æ•´æµ
- [ ] `FixedDirectoryManager` ã®çµ±ä¸€å‘½åè¦å‰‡å¯¾å¿œ
- [ ] `UnifiedNamingConvention` ã‚¯ãƒ©ã‚¹å®Ÿè£…
- [ ] ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½å®Ÿè£…

### Phase 2: Orchestratoræ•´æµ
- [ ] `unified_extract.py` ã®çµ±ä¸€å‘½åè¦å‰‡å¯¾å¿œ
- [ ] `unified_skeleton.py` ã®çµ±ä¸€å‘½åè¦å‰‡å¯¾å¿œ
- [ ] `unified_skinning.py` ã®çµ±ä¸€å‘½åè¦å‰‡å¯¾å¿œ
- [ ] `unified_merge.py` ã®çµ±ä¸€å‘½åè¦å‰‡å¯¾å¿œ
- [ ] `unified_blender.py` ã®çµ±ä¸€å‘½åè¦å‰‡å¯¾å¿œ

### Phase 3: è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«æ•´æµ
- [ ] `quick_inference_skeleton_articulationxl_ar_256.yaml` ä¿®æ­£
- [ ] `quick_inference_unirig_skin.yaml` é‡è¤‡å®šç¾©é™¤å»
- [ ] è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«æ•´åˆæ€§ç¢ºèª

### Phase 4: Shell Scriptæ•´æµ
- [ ] `generate_skeleton.sh` çµ±ä¸€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å¯¾å¿œ
- [ ] `generate_skin.sh` çµ±ä¸€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å¯¾å¿œ
- [ ] `merge.sh` çµ±ä¸€ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿å¯¾å¿œ

### Phase 5: app.pyçµ±åˆæ•´æµ
- [ ] çµ±ä¸€å‘½åè¦å‰‡å¯¾å¿œUIå®Ÿè£…
- [ ] ãƒ¦ãƒ¼ã‚¶ãƒ¼å‘ã‘ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰æ©Ÿèƒ½æ”¹ä¿®
- [ ] ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ”¹å–„

### Phase 6: æœ€çµ‚æ¤œè¨¼
- [ ] ã‚¨ãƒ³ãƒ‰ãƒ„ãƒ¼ã‚¨ãƒ³ãƒ‰ãƒ†ã‚¹ãƒˆ
- [ ] æ—¢å­˜ãƒ‡ãƒ¼ã‚¿äº’æ›æ€§ç¢ºèª
- [ ] ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ç¢ºèª

---

**ã“ã®æ•´æµå®Ÿè£…ã«ã‚ˆã‚Šã€UniRigã¯æŠ€è¡“çš„è¤‡é›‘ã•ã‚’éš è”½ã—ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«ã¨ã£ã¦ã‚·ãƒ³ãƒ—ãƒ«ã§äºˆæ¸¬å¯èƒ½ãª3Dãƒªã‚®ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã¨ãªã‚Šã¾ã™ã€‚**
