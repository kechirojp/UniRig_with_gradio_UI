# This application uses UniRig (https://github.com/VAST-AI-Research/UniRig),
# which is licensed under the MIT License.
# A copy of the license can be found at:
# https://github.com/VAST-AI-Research/UniRig/blob/main/LICENSE
#
# Gradio application for 3D model preview and bone information display.

# ====================================================================
# üö® CRITICAL: SEGMENTATION FAULT PREVENTION - MEMORY SETUP üö®
# ====================================================================
# Prevent PyTorch and Blender memory conflicts that cause segmentation faults
import os
import gc

# ÊúÄÂÑ™ÂÖà: „Çª„Ç∞„É°„É≥„ÉÜ„Éº„Ç∑„Éß„É≥„Éï„Ç©„É´„ÉàÈò≤Ê≠¢„ÅÆ„Åü„ÇÅ„ÅÆ„É°„É¢„É™Âà∂Èôê„Å®„Ç≠„É£„ÉÉ„Ç∑„É•Ë®≠ÂÆö
os.environ['PYTORCH_CUDA_ALLOC_CONF'] = 'max_split_size_mb:256,garbage_collection_threshold:0.8'
os.environ['CUDA_LAUNCH_BLOCKING'] = '1'
os.environ['PYTHONMALLOC'] = 'malloc'
os.environ['MALLOC_TRIM_THRESHOLD_'] = '100000'

# PyTorch„Å®Blender„ÅÆÁ´∂ÂêàÂõûÈÅø
os.environ['FORCE_FALLBACK_MODE'] = '1'
os.environ['DISABLE_UNIRIG_LIGHTNING'] = '1'

print("üõ°Ô∏è „Çª„Ç∞„É°„É≥„ÉÜ„Éº„Ç∑„Éß„É≥„Éï„Ç©„É´„ÉàÈò≤Ê≠¢: „É°„É¢„É™ÁÆ°ÁêÜË®≠ÂÆöÂÆå‰∫Ü")

# ====================================================================
# üö®üö®üö® CRITICAL: PREVENT ROLLBACK - READ BEFORE ANY CHANGES üö®üö®üö®
# ====================================================================
# 
# BLENDER VERSION: 4.2 FIXED - DO NOT CHANGE
# FBX FORMAT: BINARY ONLY - NEVER ASCII
# CONTEXT MANAGEMENT: Blender42ContextManager REQUIRED
# 
# ROLLBACK PROTECTION STATUS:
# - Blender 4.2 compatibility fixes applied (June 2025)
# - Binary FBX export enforced (NO ASCII rollback)
# - Context management via blender_42_context_fix.py
# - Memory crash fixes applied (spconv/CUDA handling)
# 
# IF YOU SEE THESE ERRORS, APPLY BLENDER 4.2 FIXES:
# - "Context object has no attribute 'selected_objects'"
# - "Context object has no attribute 'object'" 
# - "Armature could not be set out of Edit Mode"
# - ASCII FBX export problems
# 
# REQUIRED ACTIONS TO PREVENT ROLLBACK:
# 1. Use Blender42ContextManager from blender_42_context_fix.py
# 2. Enforce BINARY FBX export (fbx_use_ascii=False)
# 3. Apply context-aware object management
# 4. Maintain current working pipeline (Steps 1-3 SUCCESS)
# 
# ====================================================================

import gradio as gr
import os
import subprocess
import tempfile
import datetime
import time
import yaml
from box import Box
import shutil
import traceback
import numpy as np
import trimesh # For model inspection if needed, or by Blender script
import logging
import sys
import pathlib # Not strictly used in this version, but good for path manipulation
import json # For datalist
import atexit
import torch  # Add PyTorch import
from texture_preservation_system import TexturePreservationSystem
from proposed_blender_texture_flow import BlenderNativeTextureFlow
from dynamic_skeleton_generator import DynamicSkeletonGenerator

# Import corrected texture system
try:
    from fixed_texture_system_v2_corrected import FixedTextureSystemV2
    print("‚úÖ FixedTextureSystemV2Corrected imported successfully")
except ImportError as e:
    print(f"‚ö†Ô∏è FixedTextureSystemV2Corrected not available: {e}")
    # Fallback to original version
    try:
        from fixed_texture_system_v2 import FixedTextureSystemV2
        print("‚ö†Ô∏è Using original FixedTextureSystemV2 (may have issues)")
    except ImportError:
        FixedTextureSystemV2 = None
        print("‚ùå No FixedTextureSystemV2 available")

# Import ImprovedSafeTextureRestoration for priority texture processing
try:
    from improved_safe_texture_restoration import ImprovedSafeTextureRestoration
    IMPROVED_SAFE_TEXTURE_RESTORATION_AVAILABLE = True
    print("‚úÖ ImprovedSafeTextureRestoration loaded in app.py")
except ImportError as e:
    IMPROVED_SAFE_TEXTURE_RESTORATION_AVAILABLE = False
    print(f"‚ö†Ô∏è ImprovedSafeTextureRestoration not available in app.py: {e}")

# Import FixedTextureSystemV2 for enhanced texture processing
try:
    from fixed_texture_system_v2_corrected import FixedTextureSystemV2
    FIXED_TEXTURE_SYSTEM_V2_AVAILABLE = True
    print("‚úÖ FixedTextureSystemV2 loaded in app.py")
except ImportError as e:
    FIXED_TEXTURE_SYSTEM_V2_AVAILABLE = False
    print(f"‚ö†Ô∏è FixedTextureSystemV2 not available in app.py: {e}")

# Import CPU Skinning Fallback System for CUDA/spconv error handling
try:
    from src.model.cpu_skinning_system import create_cpu_skinning_fallback, compute_distance_based_weights
    from src.model.cpu_mesh_encoder import AdaptiveMeshEncoder
    CPU_SKINNING_FALLBACK_AVAILABLE = True
    print("‚úÖ CPU Skinning Fallback System loaded in app.py")
except ImportError as e:
    CPU_SKINNING_FALLBACK_AVAILABLE = False
    print(f"‚ö†Ô∏è CPU Skinning Fallback System not available in app.py: {e}")

# === CRITICAL: Segmentation Fault Prevention Setup ===
# Set fallback environment variables IMMEDIATELY to prevent memory crashes
import os
os.environ['FORCE_FALLBACK_MODE'] = '1'
os.environ['DISABLE_UNIRIG_LIGHTNING'] = '1'
# üö® ËøΩÂä†„ÅÆ„Çª„Ç∞„É°„É≥„ÉÜ„Éº„Ç∑„Éß„É≥„Éï„Ç©„É´„ÉàÈò≤Ê≠¢Áí∞Â¢ÉÂ§âÊï∞
os.environ['PYTORCH_CUDA_ALLOC_CONF'] = 'max_split_size_mb:512'
os.environ['CUDA_LAUNCH_BLOCKING'] = '1'
os.environ['PYTHONPATH'] = '/app'
print("üõ°Ô∏è „Çª„Ç∞„É°„É≥„ÉÜ„Éº„Ç∑„Éß„É≥„Éï„Ç©„É´„ÉàÈò≤Ê≠¢: FORCE_FALLBACK_MODE=1, DISABLE_UNIRIG_LIGHTNING=1")
print("üõ°Ô∏è ËøΩÂä†‰øùË≠∑: PYTORCH_CUDA_ALLOC_CONF, CUDA_LAUNCH_BLOCKINGË®≠ÂÆöÂÆå‰∫Ü")

# Emergency Skinning Bypass System Integration
try:
    from emergency_skinning_bypass import EmergencySkinningBypass
    from emergency_integration import process_emergency_unified_skinning
    EMERGENCY_BYPASS_AVAILABLE = True
    print("‚úÖ Emergency Skinning Bypass System loaded in app.py")
except ImportError as e:
    EMERGENCY_BYPASS_AVAILABLE = False
    print(f"‚ö†Ô∏è Emergency Skinning Bypass System not available in app.py: {e}")

# --- Global Configuration and Setup ---
APP_CONFIG = None
TEMP_FILES_TO_CLEAN = []

# Setup basic logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- PyTorch Device Configuration ---
# Simple and safe device selection (CPU prioritized in fallback mode)
if os.environ.get('FORCE_FALLBACK_MODE') == '1':
    device = "cpu"
    print("üîß „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„É¢„Éº„Éâ: „Éá„Éê„Ç§„Çπ„ÇíCPU„Å´Âõ∫ÂÆö")
else:
    device = "cuda" if torch.cuda.is_available() else "cpu"
    
logging.info(f"üîß PyTorch device: {device}")

# --- Modify this section for allowed paths (DEBUGGING) ---
def get_allowed_paths():
    script_dir = os.path.dirname(os.path.abspath(__file__)) # /app
    allowed = [
        os.path.abspath(script_dir), # /app
        os.path.abspath(os.path.join(script_dir, "pipeline_work")), # /app/pipeline_work
        os.path.abspath(os.path.join(script_dir, "examples")), # /app/examples
        os.path.abspath(os.path.join(script_dir, "src")), # /app/src
        os.path.abspath(os.path.join(script_dir, "configs")), # /app/configs
        os.path.abspath(os.path.join(script_dir, "blender")), # /app/blender
        os.path.abspath(os.path.join(script_dir, "display_cache")), # /app/display_cache (Gradio‰∫íÊèõË°®Á§∫„Éï„Ç°„Ç§„É´)
    ]
    if APP_CONFIG and APP_CONFIG.working_directory_base:
        # Ensure the configured working_directory_base is also allowed
        # This might be redundant if it's already /app/pipeline_work, but good for safety
        configured_work_base = os.path.abspath(APP_CONFIG.working_directory_base)
        if configured_work_base not in allowed:
            allowed.append(configured_work_base)
        
        # Add display_cache directory within the working directory base
        display_cache_path = os.path.abspath(os.path.join(configured_work_base, "display_cache"))
        if display_cache_path not in allowed:
            allowed.append(display_cache_path)
        
        # Add specific subdirectories from config if they exist, ensuring they are absolute
        # This helps if APP_CONFIG.working_directory_base is different from /app/pipeline_work
        # or if subdirectories are outside the main pipeline_work structure.
        subdirs_to_check = [
            APP_CONFIG.get('mesh_extraction', {}).get('extract_output_subdir'),
            APP_CONFIG.get('skeleton_generation', {}).get('skeleton_output_subdir'),
            APP_CONFIG.get('skinning_prediction', {}).get('skin_output_subdir'),
            APP_CONFIG.get('model_merging', {}).get('merge_output_subdir'),
            APP_CONFIG.get('blender_processing', {}).get('conversion_output_subdir'),
            APP_CONFIG.get('blender_native_texture_flow', {}).get('blender_native_subdir', '06_blender_native'),
            APP_CONFIG.get('improved_safe_texture_restoration', {}).get('output_subdir', '08_final_output') # Example for improved flow
        ]
        for subdir_name in subdirs_to_check:
            if subdir_name:
                # Construct path relative to configured_work_base if it's not absolute
                # Or relative to script_dir if that makes more sense for your structure
                potential_path = os.path.join(configured_work_base, subdir_name)
                abs_path = os.path.abspath(potential_path)
                if abs_path not in allowed:
                    allowed.append(abs_path)
    
    # Add temp directory (for backward compatibility, but prefer display_cache)
    allowed.append(os.path.abspath(tempfile.gettempdir()))

    logging.info(f"DEBUG: Gradio allowed_paths„ÅåË®≠ÂÆö„Åï„Çå„Åæ„Åó„Åü: {list(set(allowed))}") # Use set to remove duplicates
    return list(set(allowed))

    logging.info(f"DEBUG: Gradio allowed_paths„ÅåË®≠ÂÆö„Åï„Çå„Åæ„Åó„Åü: {list(set(allowed))}") # Use set to remove duplicates
    return list(set(allowed))
# --- End of modified section ---

# --- Add this helper function for debugging output paths ---
def log_output_paths_for_debug(output_dict, context_log_message=""):
    logging.info(f"--- DEBUG: GradioÂá∫Âäõ„Éë„Çπ„ÅÆÁ¢∫Ë™ç ({context_log_message}) ---")
    if not isinstance(output_dict, dict):
        logging.warning(f"  Âá∫Âäõ„ÅØËæûÊõ∏„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì: {type(output_dict)}, ÂÄ§: {output_dict}")
        return

    for key, value in output_dict.items():
        if isinstance(value, str) and (value.endswith(('.glb', '.fbx', '.png', '.jpg', '.txt', '.npz', '.json', '.yaml')) or "/" in value or "\\\\" in value):
            # Heuristic: if it looks like a file path string
            abs_path = os.path.abspath(value)
            exists = os.path.exists(abs_path)
            is_file = os.path.isfile(abs_path) if exists else "N/A"
            logging.info(f"  Âá∫Âäõ„Ç≠„Éº: '{key}', „Éë„Çπ: '{value}' (Áµ∂ÂØæ„Éë„Çπ: '{abs_path}'), Â≠òÂú®: {exists}, „Éï„Ç°„Ç§„É´?: {is_file}")
            if exists and is_file:
                try:
                    logging.info(f"    „Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: {os.path.getsize(abs_path)} bytes")
                except Exception as e:
                    logging.warning(f"    „Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫„ÅÆÂèñÂæó„Ç®„É©„Éº: {e}")
        elif isinstance(value, list) and all(isinstance(item, str) for item in value):
             logging.info(f"  Âá∫Âäõ„Ç≠„Éº: '{key}', ÂÄ§ („É™„Çπ„Éà): {value} - („É™„Çπ„ÉàÂÜÖ„ÅÆ„Éë„Çπ„ÅØÂÄãÂà•„Å´Á¢∫Ë™ç„Åï„Çå„Åæ„Åõ„Çì)")
        else:
            logging.info(f"  Âá∫Âäõ„Ç≠„Éº: '{key}', ÂÄ§: {value} (Âûã: {type(value)}) - „Éë„Çπ„Å®„Åó„Å¶Êâ±„Çè„Çå„Åæ„Åõ„Çì")
    logging.info("--- DEBUG: GradioÂá∫Âäõ„Éë„Çπ„ÅÆÁ¢∫Ë™çÂÆå‰∫Ü ---")
# --- End of added helper function ---

# --- Configuration Loading Functions ---
def load_app_config():
    """„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥Ë®≠ÂÆö„ÇíYAML„Éï„Ç°„Ç§„É´„Åã„ÇâË™≠„ÅøËæº„Åø"""
    global APP_CONFIG
    config_path = os.path.join(os.path.dirname(__file__), 'configs', 'app_config.yaml')
    
    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            config_data = yaml.safe_load(f)
        APP_CONFIG = Box(config_data)
        logging.info(f"‚úÖ „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥Ë®≠ÂÆö„ÇíË™≠„ÅøËæº„Åø„Åæ„Åó„Åü: {config_path}")
        
        # ‰ΩúÊ•≠„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅÆ‰ΩúÊàê
        work_dir = os.path.abspath(APP_CONFIG.working_directory_base)
        os.makedirs(work_dir, exist_ok=True)
        
        return True
    except Exception as e:
        logging.error(f"‚ùå Ë®≠ÂÆö„Éï„Ç°„Ç§„É´„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó: {e}")
        APP_CONFIG = Box({'error': str(e)})
        return False

# --- Utility Functions ---
def convert_to_glb_for_display(input_model_path, output_name):
    """3D„É¢„Éá„É´„ÇíË°®Á§∫Áî®GLB„Å´Â§âÊèõ (Gradio‰∫íÊèõ„Éë„Çπ‰ΩøÁî®)"""
    try:
        # ÂÖ•Âäõ„Éë„Çπ„Å®Âá∫Âäõ„Éë„Çπ„ÇíË®≠ÂÆö - Gradio‰∫íÊèõ„ÅÆÂõ∫ÂÆö„Éá„Ç£„É¨„ÇØ„Éà„É™„Çí‰ΩøÁî®
        base_name = os.path.splitext(os.path.basename(input_model_path))[0]
        
        # Gradio‰∫íÊèõ„ÅÆË°®Á§∫„Éï„Ç°„Ç§„É´Áî®„Éá„Ç£„É¨„ÇØ„Éà„É™„Çí‰ΩúÊàê
        # APP_CONFIG„ÅåÂà©Áî®ÂèØËÉΩ„Åß„ÅÇ„Çå„Å∞pipeline_workÂÜÖ„Å´„ÄÅ„Åù„ÅÜ„Åß„Å™„Åë„Çå„Å∞/appÂÜÖ„Å´‰ΩúÊàê
        if APP_CONFIG and hasattr(APP_CONFIG, 'working_directory_base'):
            display_base_dir = os.path.join(APP_CONFIG.working_directory_base, "display_cache")
        else:
            display_base_dir = "/app/display_cache"
        
        os.makedirs(display_base_dir, exist_ok=True)
        output_path = os.path.join(display_base_dir, f"{output_name}.glb")
        
        logging.info(f"üé® GLBË°®Á§∫„Éï„Ç°„Ç§„É´‰ΩúÊàê: {input_model_path} ‚Üí {output_path}")
        
        # ÂÖ•Âäõ„Éï„Ç°„Ç§„É´„ÅåÊó¢„Å´GLBÂΩ¢Âºè„ÅÆÂ†¥Âêà„ÅØ„Ç≥„Éî„Éº
        if input_model_path.lower().endswith('.glb'):
            shutil.copy2(input_model_path, output_path)
            logging.info(f"‚úÖ GLBË°®Á§∫„Éï„Ç°„Ç§„É´„Ç≥„Éî„ÉºÂÆå‰∫Ü: {output_path}")
            return output_path
        
        # „Åù„ÅÆ‰ªñ„ÅÆÂΩ¢Âºè„ÅÆÂ†¥Âêà„ÅØÁ∞°Âçò„Å™Â§âÊèõÂá¶ÁêÜ„ÇíË©¶Ë°å
        try:
            # Trimesh„Çí‰Ωø„Å£„ÅüÂü∫Êú¨ÁöÑ„Å™Â§âÊèõ
            mesh = trimesh.load(input_model_path)
            if hasattr(mesh, 'export'):
                mesh.export(output_path)
                logging.info(f"‚úÖ GLBË°®Á§∫„Éï„Ç°„Ç§„É´Â§âÊèõÂÆå‰∫Ü(Trimesh): {output_path}")
                return output_path
            else:
                logging.warning(f"Trimesh„Åß„ÅÆÂ§âÊèõ: 'export'„É°„ÇΩ„ÉÉ„Éâ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì")
        except Exception as e:
            logging.warning(f"Trimesh„Åß„ÅÆÂ§âÊèõ„Å´Â§±Êïó: {e}")
        
        # Â§âÊèõ„Å´Â§±Êïó„Åó„ÅüÂ†¥Âêà„ÅØÂÖÉ„ÅÆ„Éï„Ç°„Ç§„É´„Çí„Ç≥„Éî„Éº
        shutil.copy2(input_model_path, output_path)
        logging.info(f"‚úÖ GLBË°®Á§∫„Éï„Ç°„Ç§„É´„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Ç≥„Éî„ÉºÂÆå‰∫Ü: {output_path}")
        return output_path
        
    except Exception as e:
        logging.error(f"GLBÂ§âÊèõ„Ç®„É©„Éº: {e}")
        logging.error(f"GLBÂ§âÊèõ„Çπ„Çø„ÉÉ„ÇØ„Éà„É¨„Éº„Çπ: {traceback.format_exc()}")
        return input_model_path  # Â§âÊèõÂ§±ÊïóÊôÇ„ÅØÂÖÉ„ÅÆ„Éë„Çπ„ÇíËøî„Åô

def gradio_safe_file_output(file_path, fallback_name="output_file"):
    """
    Gradio„ÅÆÂá∫Âäõ„Å®„Åó„Å¶ÂÆâÂÖ®„Å™„Éï„Ç°„Ç§„É´„Éë„Çπ/„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíËøî„Åô
    
    Args:
        file_path (str): Âá∫Âäõ„Åó„Åü„ÅÑ„Éï„Ç°„Ç§„É´„ÅÆ„Éë„Çπ
        fallback_name (str): „Éï„Ç°„Ç§„É´„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂêç
        
    Returns:
        str or None: Gradio„ÅåÂá¶ÁêÜ„Åß„Åç„ÇãÂÆâÂÖ®„Å™„Éï„Ç°„Ç§„É´„Éë„Çπ„ÄÅ„Åæ„Åü„ÅØNone
    """
    try:
        if not file_path or not os.path.exists(file_path):
            logging.warning(f"„Éï„Ç°„Ç§„É´„ÅåÂ≠òÂú®„Åó„Å™„ÅÑ„Åü„ÇÅ„ÄÅGradioÂá∫Âäõ„Çí„Çπ„Ç≠„ÉÉ„Éó: {file_path}")
            return None
        
        # „Éï„Ç°„Ç§„É´„Éë„Çπ„ÇíÁµ∂ÂØæ„Éë„Çπ„Å´Â§âÊèõ
        abs_path = os.path.abspath(file_path)
        
        # Gradio„ÅÆË®±ÂèØ„Éë„Çπ„ÇíÂèñÂæó
        allowed_paths = get_allowed_paths()
        
        # „Éï„Ç°„Ç§„É´„ÅåË®±ÂèØ„Åï„Çå„Åü„Éá„Ç£„É¨„ÇØ„Éà„É™ÂÜÖ„Å´„ÅÇ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
        file_is_allowed = any(abs_path.startswith(allowed_dir) for allowed_dir in allowed_paths)
        
        if file_is_allowed:
            logging.info(f"‚úÖ GradioÂá∫Âäõ: {abs_path} (Ë®±ÂèØ„Åï„Çå„Åü„Éë„ÇπÂÜÖ)")
            return abs_path
        else:
            # „Éï„Ç°„Ç§„É´„ÅåË®±ÂèØ„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÄÅdisplay_cache„Å´„Ç≥„Éî„Éº
            logging.warning(f"‚ö†Ô∏è „Éï„Ç°„Ç§„É´„ÅåË®±ÂèØ„Åï„Çå„Åü„Éë„ÇπÂ§ñ„Åß„Åô: {abs_path}")
            
            # display_cache„Éá„Ç£„É¨„ÇØ„Éà„É™„ÇíÂèñÂæó
            if APP_CONFIG and hasattr(APP_CONFIG, 'working_directory_base'):
                display_cache_dir = os.path.join(APP_CONFIG.working_directory_base, "display_cache")
            else:
                display_cache_dir = "/app/display_cache"
            
            os.makedirs(display_cache_dir, exist_ok=True)
            
            # ÂÆâÂÖ®„Å™„Éï„Ç°„Ç§„É´Âêç„ÇíÁîüÊàê
            safe_filename = os.path.basename(file_path)
            if not safe_filename:
                safe_filename = f"{fallback_name}.{file_path.split('.')[-1] if '.' in file_path else 'dat'}"
            
            safe_path = os.path.join(display_cache_dir, safe_filename)
            
            # „Éï„Ç°„Ç§„É´„Çí„Ç≥„Éî„Éº
            shutil.copy2(abs_path, safe_path)
            logging.info(f"‚úÖ „Éï„Ç°„Ç§„É´„ÇíÂÆâÂÖ®„Å™„Éë„Çπ„Å´„Ç≥„Éî„Éº: {abs_path} ‚Üí {safe_path}")
            
            return safe_path
            
    except Exception as e:
        logging.error(f"‚ùå GradioÂÆâÂÖ®„Éï„Ç°„Ç§„É´Âá∫Âäõ„Ç®„É©„Éº: {e}")
        logging.error(f"„Çπ„Çø„ÉÉ„ÇØ„Éà„É¨„Éº„Çπ: {traceback.format_exc()}")
        return None

def ensure_working_directory():
    """‰ΩúÊ•≠„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅÆÁ¢∫‰øù"""
    if not APP_CONFIG:
        return False
    
    try:
        work_dir = os.path.abspath(APP_CONFIG.working_directory_base)
        os.makedirs(work_dir, exist_ok=True)
        
        # „Çµ„Éñ„Éá„Ç£„É¨„ÇØ„Éà„É™„ÇÇ‰ΩúÊàê
        subdirs = [
            APP_CONFIG.get('mesh_extraction', {}).get('extract_output_subdir', '01_extracted_mesh'),
            APP_CONFIG.get('skeleton_generation', {}).get('skeleton_output_subdir', '02_skeleton'),
            APP_CONFIG.get('skinning_prediction', {}).get('skin_output_subdir', '03_skinning'),
            APP_CONFIG.get('model_merging', {}).get('merge_output_subdir', '04_merge'),
            '08_final_output'  # ÊúÄÁµÇÂá∫ÂäõÁî®
        ]
        
        for subdir in subdirs:
            if subdir:
                full_subdir = os.path.join(work_dir, subdir)
                os.makedirs(full_subdir, exist_ok=True)
        
        return True
    except Exception as e:
        logging.error(f"‰ΩúÊ•≠„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅÆ‰ΩúÊàê„Å´Â§±Êïó: {e}")
        return False

def cleanup_temp_files():
    """‰∏ÄÊôÇ„Éï„Ç°„Ç§„É´„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó"""
    global TEMP_FILES_TO_CLEAN
    for temp_file in TEMP_FILES_TO_CLEAN:
        try:
            if os.path.exists(temp_file):
                os.remove(temp_file)
                logging.info(f"‰∏ÄÊôÇ„Éï„Ç°„Ç§„É´„ÇíÂâäÈô§: {temp_file}")
        except Exception as e:
            logging.warning(f"‰∏ÄÊôÇ„Éï„Ç°„Ç§„É´„ÅÆÂâäÈô§„Å´Â§±Êïó: {temp_file}, „Ç®„É©„Éº: {e}")
    TEMP_FILES_TO_CLEAN = []

# ÁµÇ‰∫ÜÊôÇ„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
atexit.register(cleanup_temp_files)

# --- Progress Utility Function ---
def progress_segment(progress, start: float, end: float):
    """
    „Éó„É≠„Ç∞„É¨„Çπ„Éê„Éº„ÅÆÁØÑÂõ≤„ÇíÂàÜÂâ≤„Åô„ÇãÈñ¢Êï∞
    Args:
        progress: Gradio„ÅÆ„Éó„É≠„Ç∞„É¨„Çπ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà
        start: ÈñãÂßã‰ΩçÁΩÆ (0.0-1.0)
        end: ÁµÇ‰∫Ü‰ΩçÁΩÆ (0.0-1.0)
    Returns:
        ÂàÜÂâ≤„Åï„Çå„Åü„Éó„É≠„Ç∞„É¨„ÇπÈñ¢Êï∞
    """
    def segmented_progress(value: float, desc: str = None):
        """ÂàÜÂâ≤„Åï„Çå„Åü„Éó„É≠„Ç∞„É¨„ÇπÊõ¥Êñ∞Èñ¢Êï∞"""
        if progress is None:
            return
        try:
            # ÂàÜÂâ≤„Åï„Çå„ÅüÁØÑÂõ≤ÂÜÖ„Åß„ÅÆÂÄ§„ÇíË®àÁÆó
            segment_range = end - start
            actual_progress = start + (value * segment_range)
            actual_progress = max(0.0, min(1.0, actual_progress))  # 0.0-1.0„Å´„ÇØ„É©„É≥„Éó
            
            if desc:
                progress(actual_progress, desc)
            else:
                progress(actual_progress)
        except Exception as e:
            # „Éó„É≠„Ç∞„É¨„ÇπÊõ¥Êñ∞„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„ÅüÂ†¥Âêà„ÅØ„É≠„Ç∞„Å´Ë®òÈå≤„Åó„Å¶Á∂öË°å
            logging.warning(f"„Éó„É≠„Ç∞„É¨„ÇπÊõ¥Êñ∞„Ç®„É©„Éº: {e}")
            pass
    
    return segmented_progress

# --- Helper: Run Subprocess ---
def run_subprocess_with_progress(command, work_dir, log_file_path, progress_fn, total_items_for_tqdm=1):
    """
    „Çµ„Éñ„Éó„É≠„Çª„Çπ„ÇíÈÄ≤ÊçóË°®Á§∫‰ªò„Åç„ÅßÂÆüË°å
    Args:
        command: ÂÆüË°å„Åô„Çã„Ç≥„Éû„É≥„Éâ („É™„Çπ„Éà)
        work_dir: ‰ΩúÊ•≠„Éá„Ç£„É¨„ÇØ„Éà„É™
        log_file_path: „É≠„Ç∞„Éï„Ç°„Ç§„É´„ÅÆ„Éë„Çπ
        progress_fn: ÈÄ≤ÊçóÊõ¥Êñ∞Èñ¢Êï∞
        total_items_for_tqdm: ÈÄ≤Êçó„ÅÆ„Ç¢„Ç§„ÉÜ„É†Êï∞ (Êú™‰ΩøÁî®)
    Returns:
        tuple: (success: bool, logs: str)
    """
    logs = ""
    try:
        process = subprocess.Popen(command, cwd=work_dir, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, bufsize=1, universal_newlines=True)
        
        # Simulate progress for the subprocess duration if it's a single task
        # This is a placeholder. Real progress depends on the script's output.
        progress_fn(0.1, desc=f"ÂÆüË°å‰∏≠: {command[1] if len(command) > 1 else 'command'}...") 

        with open(log_file_path, 'w') as log_f:
            for line in process.stdout:
                logs += line
                log_f.write(line)
                # If the script outputs progress, parse it here.
                # For now, we don't have a specific format to parse.
        
        process.wait()
        progress_fn(0.9, desc=f"ÂÆå‰∫ÜÂæÖ„Å°: {command[1] if len(command) > 1 else 'command'}...")

        if process.returncode == 0:
            logs += f"„Ç≥„Éû„É≥„ÉâÊàêÂäü: {' '.join(command)}\n"
            progress_fn(1.0, desc=f"ÂÆå‰∫Ü: {command[1] if len(command) > 1 else 'command'}")
            return True, logs
        else:
            logs += f"„Ç≥„Éû„É≥„ÉâÂ§±Êïó („Ç≥„Éº„Éâ {process.returncode}): {' '.join(command)}\n"
            logs += f"„É≠„Ç∞„Éï„Ç°„Ç§„É´ÂèÇÁÖß: {log_file_path}\n"
            progress_fn(1.0, desc=f"„Ç®„É©„Éº: {command[1] if len(command) > 1 else 'command'}") # Mark as complete even on error for progress bar
            return False, logs
    except FileNotFoundError:
        logs += f"„Ç®„É©„Éº: „Ç≥„Éû„É≥„Éâ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì - {command[0]}„ÄÇ„Éë„Çπ„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\n"
        progress_fn(1.0, desc=f"„Ç®„É©„Éº: {command[0]} not found")
        return False, logs
    except Exception as e:
        logs += f"„Çµ„Éñ„Éó„É≠„Çª„ÇπÂÆüË°å‰∏≠„Å´‰∫àÊúü„Åõ„Å¨„Ç®„É©„Éº: {e}\n"
        logs += f"„Ç≥„Éû„É≥„Éâ: {' '.join(command)}\n"
        logs += f"Ë©≥Á¥∞: {traceback.format_exc()}\n"
        progress_fn(1.0, desc=f"‰æãÂ§ñ: {command[1] if len(command) > 1 else 'command'}")
        return False, logs

# --- Core Processing Functions ---
def process_extract_mesh(uploaded_model_path: str, model_name: str, progress_fn=None):
    """
    „É°„ÉÉ„Ç∑„É•ÊäΩÂá∫Âá¶ÁêÜ
    Args:
        uploaded_model_path: „Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åï„Çå„Åü„É¢„Éá„É´„Éï„Ç°„Ç§„É´„ÅÆ„Éë„Çπ
        model_name: „É¢„Éá„É´Âêç
        progress_fn: „Éó„É≠„Ç∞„É¨„ÇπÊõ¥Êñ∞Èñ¢Êï∞
    Returns:
        tuple: (extracted_npz_path, logs)
    """
    logs = "=== „É°„ÉÉ„Ç∑„É•ÊäΩÂá∫Âá¶ÁêÜÈñãÂßã ===\n"
    
    try:
        if progress_fn:
            progress_fn(0.1, "„É°„ÉÉ„Ç∑„É•ÊäΩÂá∫Ê∫ñÂÇô‰∏≠...")
        
        if not uploaded_model_path or not os.path.exists(uploaded_model_path):
            logs += f"‚ùå „Ç®„É©„Éº: ÂÖ•Âäõ„Éï„Ç°„Ç§„É´„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì: {uploaded_model_path}\n"
            return None, logs
        
        # Âá∫Âäõ„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅÆË®≠ÂÆö
        if not APP_CONFIG:
            # GradioÁí∞Â¢É„Åß„ÅÆË®≠ÂÆö„ÅÆÂÜçË™≠„ÅøËæº„Åø
            if not load_app_config():
                logs += "‚ùå „Ç®„É©„Éº: „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥Ë®≠ÂÆö„ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì\n"
                return None, logs
        
        extract_config = APP_CONFIG.get('mesh_extraction', {})
        extract_subdir = extract_config.get('extract_output_subdir', '01_extracted_mesh')
        work_base = APP_CONFIG.working_directory_base
        extract_dir = os.path.join(work_base, extract_subdir, model_name)
        
        os.makedirs(extract_dir, exist_ok=True)
        logs += f"üìÅ ÊäΩÂá∫„Éá„Ç£„É¨„ÇØ„Éà„É™: {extract_dir}\n"
        
        if progress_fn:
            progress_fn(0.3, "„É°„ÉÉ„Ç∑„É•„Éá„Éº„ÇøÂá¶ÁêÜ‰∏≠...")
        
        # NPZ„Éï„Ç°„Ç§„É´„ÅÆÂá∫Âäõ„Éë„Çπ
        extracted_npz_path = os.path.join(extract_dir, f"{model_name}_extracted.npz")
        
        # Âü∫Êú¨ÁöÑ„Å™„É°„ÉÉ„Ç∑„É•ÊäΩÂá∫Âá¶ÁêÜÔºà„ÉÜ„ÇØ„Çπ„ÉÅ„É£ÊÉÖÂ†±‰ªò„ÅçÔºâ
        try:
            mesh = trimesh.load(uploaded_model_path)
            
            if progress_fn:
                progress_fn(0.6, "„É°„ÉÉ„Ç∑„É•„Éá„Éº„ÇøÂ§âÊèõ‰∏≠...")
            
            # „É°„ÉÉ„Ç∑„É•„Éá„Éº„Çø„ÇínumpyÈÖçÂàó„Å®„Åó„Å¶‰øùÂ≠ò
            if hasattr(mesh, 'vertices') and hasattr(mesh, 'faces'):
                # Âçò‰∏Ä„É°„ÉÉ„Ç∑„É•„ÅÆÂ†¥Âêà
                vertices = mesh.vertices
                faces = mesh.faces
                materials = getattr(mesh.visual, 'material', None)
                mesh_name = "main_mesh"
                
                # UVÂ∫ßÊ®ô„ÅÆÊäΩÂá∫
                uv_coords = None
                if hasattr(mesh, 'visual') and hasattr(mesh.visual, 'uv'):
                    uv_coords = mesh.visual.uv
                    logs += f"üó∫Ô∏è Âçò‰∏Ä„É°„ÉÉ„Ç∑„É•UVÂ∫ßÊ®ô: {len(uv_coords)}ÁÇπ\n"
                else:
                    # „Éá„Éï„Ç©„É´„ÉàUVÂ∫ßÊ®ô„ÇíÁîüÊàê
                    uv_coords = np.array([[0.0, 0.0] for _ in range(len(vertices))])
                    logs += f"üîß Âçò‰∏Ä„É°„ÉÉ„Ç∑„É•„Éá„Éï„Ç©„É´„ÉàUVÂ∫ßÊ®ô: {len(uv_coords)}ÁÇπ\n"
                    
            else:
                # Scene object„ÅÆÂ†¥Âêà„ÅÆÂá¶ÁêÜ
                if hasattr(mesh, 'geometry'):
                    geometry_list = list(mesh.geometry.values())
                    if len(geometry_list) == 0:
                        raise Exception("Scene„Å´„Ç∏„Ç™„É°„Éà„É™„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì")
                    
                    # ÊúÄÂàù„ÅÆ„Ç∏„Ç™„É°„Éà„É™„Çí‰ΩøÁî®
                    first_geometry = geometry_list[0]
                    vertices = first_geometry.vertices
                    faces = first_geometry.faces
                    mesh_name = list(mesh.geometry.keys())[0]
                    
                    # SceneÂÜÖ„ÅÆ„Éû„ÉÜ„É™„Ç¢„É´ÊÉÖÂ†±„ÇíÂèñÂæó
                    materials = getattr(first_geometry.visual, 'material', None) if hasattr(first_geometry, 'visual') else None
                    
                    # Scene„ÅÆUVÂ∫ßÊ®ô„ÅÆÊäΩÂá∫
                    uv_coords = None
                    if hasattr(first_geometry, 'visual') and hasattr(first_geometry.visual, 'uv'):
                        uv_coords = first_geometry.visual.uv
                        logs += f"üó∫Ô∏è Scene„É°„ÉÉ„Ç∑„É•UVÂ∫ßÊ®ô: {len(uv_coords)}ÁÇπ\n"
                    else:
                        # „Éá„Éï„Ç©„É´„ÉàUVÂ∫ßÊ®ô„ÇíÁîüÊàê
                        uv_coords = np.array([[0.0, 0.0] for _ in range(len(vertices))])
                        logs += f"üîß Scene„É°„ÉÉ„Ç∑„É•„Éá„Éï„Ç©„É´„ÉàUVÂ∫ßÊ®ô: {len(uv_coords)}ÁÇπ\n"
                    
                    logs += f"üîç SceneÂΩ¢ÂºèÊ§úÂá∫: {len(geometry_list)}ÂÄã„ÅÆ„Ç∏„Ç™„É°„Éà„É™\n"
                    logs += f"üì¶ ‰ΩøÁî®„Ç∏„Ç™„É°„Éà„É™: {mesh_name}\n"
                else:
                    raise Exception("„É°„ÉÉ„Ç∑„É•„Éá„Éº„Çø„ÅÆÊßãÈÄ†„ÇíË™çË≠ò„Åß„Åç„Åæ„Åõ„Çì")
            
            # „ÉÜ„ÇØ„Çπ„ÉÅ„É£„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅÆ‰ΩúÊàê
            texture_dir = os.path.join(extract_dir, "textures")
            os.makedirs(texture_dir, exist_ok=True)
            
            # „ÉÜ„ÇØ„Çπ„ÉÅ„É£„Éû„Éã„Éï„Çß„Çπ„ÉàÊÉÖÂ†±„ÅÆÊ∫ñÂÇô
            texture_manifest = {
                'model_name': model_name,
                'extracted_at': str(time.time()),
                'texture_count': 0,
                'textures': [],
                'mesh_name': mesh_name
            }
            
            # È´òÂ∫¶„Å™„Éû„ÉÜ„É™„Ç¢„É´„Éª„ÉÜ„ÇØ„Çπ„ÉÅ„É£ÊäΩÂá∫Âá¶ÁêÜ
            logs += "üé® „ÉÜ„ÇØ„Çπ„ÉÅ„É£ÊäΩÂá∫Âá¶ÁêÜÈñãÂßã\n"
            
            if materials:
                logs += f"üìã „Éû„ÉÜ„É™„Ç¢„É´„Çø„Ç§„Éó: {type(materials)}\n"
                
                # PBRMaterial „ÅÆÂ†¥Âêà„ÅÆÂá¶ÁêÜ
                if hasattr(materials, 'baseColorTexture'):
                    texture_count = 0
                    
                    # Base Color Texture (Diffuse)
                    if materials.baseColorTexture:
                        try:
                            texture_filename = f"{model_name}_baseColor.png"
                            texture_path = os.path.join(texture_dir, texture_filename)
                            materials.baseColorTexture.save(texture_path)
                            
                            texture_manifest['textures'].append({
                                'original_name': 'baseColorTexture',
                                'saved_name': texture_filename,
                                'saved_path': texture_path,
                                'type': 'BASE_COLOR',
                                'size_bytes': os.path.getsize(texture_path)
                            })
                            texture_count += 1
                            logs += f"üì∏ Base Color „ÉÜ„ÇØ„Çπ„ÉÅ„É£‰øùÂ≠ò: {texture_filename}\n"
                        except Exception as e:
                            logs += f"‚ö†Ô∏è Base Color „ÉÜ„ÇØ„Çπ„ÉÅ„É£‰øùÂ≠ò„Ç®„É©„Éº: {e}\n"
                    
                    # Normal Texture
                    if hasattr(materials, 'normalTexture') and materials.normalTexture:
                        try:
                            texture_filename = f"{model_name}_normal.png"
                            texture_path = os.path.join(texture_dir, texture_filename)
                            materials.normalTexture.save(texture_path)
                            
                            texture_manifest['textures'].append({
                                'original_name': 'normalTexture',
                                'saved_name': texture_filename,
                                'saved_path': texture_path,
                                'type': 'NORMAL',
                                'size_bytes': os.path.getsize(texture_path)
                            })
                            texture_count += 1
                            logs += f"üì∏ Normal „ÉÜ„ÇØ„Çπ„ÉÅ„É£‰øùÂ≠ò: {texture_filename}\n"
                        except Exception as e:
                            logs += f"‚ö†Ô∏è Normal „ÉÜ„ÇØ„Çπ„ÉÅ„É£‰øùÂ≠ò„Ç®„É©„Éº: {e}\n"
                    
                    # Metallic Roughness Texture
                    if hasattr(materials, 'metallicRoughnessTexture') and materials.metallicRoughnessTexture:
                        try:
                            texture_filename = f"{model_name}_metallicRoughness.png"
                            texture_path = os.path.join(texture_dir, texture_filename)
                            materials.metallicRoughnessTexture.save(texture_path)
                            
                            texture_manifest['textures'].append({
                                'original_name': 'metallicRoughnessTexture',
                                'saved_name': texture_filename,
                                'saved_path': texture_path,
                                'type': 'METALLIC_ROUGHNESS',
                                'size_bytes': os.path.getsize(texture_path)
                            })
                            texture_count += 1
                            logs += f"üì∏ Metallic Roughness „ÉÜ„ÇØ„Çπ„ÉÅ„É£‰øùÂ≠ò: {texture_filename}\n"
                        except Exception as e:
                            logs += f"‚ö†Ô∏è Metallic Roughness „ÉÜ„ÇØ„Çπ„ÉÅ„É£‰øùÂ≠ò„Ç®„É©„Éº: {e}\n"
                    
                    # Emissive Texture
                    if hasattr(materials, 'emissiveTexture') and materials.emissiveTexture:
                        try:
                            texture_filename = f"{model_name}_emissive.png"
                            texture_path = os.path.join(texture_dir, texture_filename)
                            materials.emissiveTexture.save(texture_path)
                            
                            texture_manifest['textures'].append({
                                'original_name': 'emissiveTexture',
                                'saved_name': texture_filename,
                                'saved_path': texture_path,
                                'type': 'EMISSIVE',
                                'size_bytes': os.path.getsize(texture_path)
                            })
                            texture_count += 1
                            logs += f"üì∏ Emissive „ÉÜ„ÇØ„Çπ„ÉÅ„É£‰øùÂ≠ò: {texture_filename}\n"
                        except Exception as e:
                            logs += f"‚ö†Ô∏è Emissive „ÉÜ„ÇØ„Çπ„ÉÅ„É£‰øùÂ≠ò„Ç®„É©„Éº: {e}\n"
                    
                    # Occlusion Texture
                    if hasattr(materials, 'occlusionTexture') and materials.occlusionTexture:
                        try:
                            texture_filename = f"{model_name}_occlusion.png"
                            texture_path = os.path.join(texture_dir, texture_filename)
                            materials.occlusionTexture.save(texture_path)
                            
                            texture_manifest['textures'].append({
                                'original_name': 'occlusionTexture',
                                'saved_name': texture_filename,
                                'saved_path': texture_path,
                                'type': 'OCCLUSION',
                                'size_bytes': os.path.getsize(texture_path)
                            })
                            texture_count += 1
                            logs += f"üì∏ Occlusion „ÉÜ„ÇØ„Çπ„ÉÅ„É£‰øùÂ≠ò: {texture_filename}\n"
                        except Exception as e:
                            logs += f"‚ö†Ô∏è Occlusion „ÉÜ„ÇØ„Çπ„ÉÅ„É£‰øùÂ≠ò„Ç®„É©„Éº: {e}\n"
                    
                    texture_manifest['texture_count'] = texture_count
                    
                # SimpleMaterial „ÅÆÂ†¥Âêà„ÅÆÂá¶ÁêÜÔºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ
                elif hasattr(materials, 'image') and materials.image:
                    try:
                        texture_filename = f"{model_name}_texture_0.png"
                        texture_path = os.path.join(texture_dir, texture_filename)
                        materials.image.save(texture_path)
                        
                        texture_manifest['texture_count'] = 1
                        texture_manifest['textures'].append({
                            'original_name': 'image',
                            'saved_name': texture_filename,
                            'saved_path': texture_path,
                            'type': 'DIFFUSE',
                            'size_bytes': os.path.getsize(texture_path)
                        })
                        logs += f"üì∏ Simple Material „ÉÜ„ÇØ„Çπ„ÉÅ„É£‰øùÂ≠ò: {texture_filename}\n"
                    except Exception as texture_error:
                        logs += f"‚ö†Ô∏è Simple Material „ÉÜ„ÇØ„Çπ„ÉÅ„É£ÊäΩÂá∫„Ç®„É©„Éº: {texture_error}\n"
                else:
                    logs += "‚ö†Ô∏è Ë™çË≠òÂèØËÉΩ„Å™„ÉÜ„ÇØ„Çπ„ÉÅ„É£„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü\n"
            else:
                logs += "‚ö†Ô∏è „Éû„ÉÜ„É™„Ç¢„É´ÊÉÖÂ†±„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü\n"
            
            # „Éû„ÉÜ„É™„Ç¢„É´ÊÉÖÂ†±„ÅÆÊßãÈÄ†Âåñ
            materials_data = None
            if texture_manifest and texture_manifest.get('textures'):
                materials_data = texture_manifest
                logs += f"üì¶ „Éû„ÉÜ„É™„Ç¢„É´ÊÉÖÂ†±‰øùÂ≠ò: {len(texture_manifest['textures'])}„ÉÜ„ÇØ„Çπ„ÉÅ„É£\n"
            
            # NPZ„Éï„Ç°„Ç§„É´„Å®„Åó„Å¶‰øùÂ≠ò (UniRig RawData‰∫íÊèõ„Éï„Ç©„Éº„Éû„ÉÉ„Éà)
            np.savez(extracted_npz_path, 
                    vertices=vertices, 
                    faces=faces,
                    uv_coords=uv_coords,
                    materials=materials_data)
            
            # „Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫„ÅÆÁ¢∫Ë™ç„Å®„É≠„Ç∞Âá∫Âäõ
            npz_size = os.path.getsize(extracted_npz_path)
            npz_size_mb = npz_size / (1024 * 1024)
            
            # YAML„Éû„Éã„Éï„Çß„Çπ„Éà„Éï„Ç°„Ç§„É´„Çí‰øùÂ≠òÔºàImprovedSafeTextureRestorationÁî®Ôºâ
            yaml_manifest_path = os.path.join(extract_dir, "texture_manifest.yaml")
            try:
                import yaml
                with open(yaml_manifest_path, 'w') as f:
                    yaml.dump(texture_manifest, f, default_flow_style=False)
                logs += f"üìã YAML„Éû„Éã„Éï„Çß„Çπ„ÉàÁîüÊàê: {yaml_manifest_path}\n"
            except Exception as yaml_error:
                logs += f"‚ö†Ô∏è YAML„Éû„Éã„Éï„Çß„Çπ„ÉàÁîüÊàê„Ç®„É©„Éº: {yaml_error}\n"
            
            if progress_fn:
                progress_fn(0.9, "„É°„ÉÉ„Ç∑„É•ÊäΩÂá∫ÂÆå‰∫ÜÂá¶ÁêÜ‰∏≠...")
            
            logs += f"‚úÖ „É°„ÉÉ„Ç∑„É•ÊäΩÂá∫ÊàêÂäü\n"
            logs += f"üìä È†ÇÁÇπÊï∞: {len(vertices)}\n"
            logs += f"üìä Èù¢Êï∞: {len(faces)}\n"
            logs += f"üì∏ „ÉÜ„ÇØ„Çπ„ÉÅ„É£Êï∞: {texture_manifest['texture_count']}\n"
            logs += f"üì¶ NPZ„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: {npz_size:,} „Éê„Ç§„Éà ({npz_size_mb:.2f} MB)\n"
            logs += f"üíæ Âá∫Âäõ„Éï„Ç°„Ç§„É´: {extracted_npz_path}\n"
            
            if progress_fn:
                progress_fn(1.0, "„É°„ÉÉ„Ç∑„É•ÊäΩÂá∫ÂÆå‰∫Ü")
            
            return extracted_npz_path, logs
            
        except Exception as mesh_error:
            logs += f"‚ùå „É°„ÉÉ„Ç∑„É•Âá¶ÁêÜ„Ç®„É©„Éº: {str(mesh_error)}\n"
            return None, logs
    
    except Exception as e:
        logs += f"‚ùå „É°„ÉÉ„Ç∑„É•ÊäΩ extractÂá¶ÁêÜ„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: {str(e)}\n"
        logs += f"Ë©≥Á¥∞: {traceback.format_exc()}\n"
        if progress_fn:
            progress_fn(1.0, "„É°„ÉÉ„Ç∑„É•ÊäΩÂá∫„Ç®„É©„Éº")
        return None, logs

def process_generate_skeleton(extracted_npz_path: str, model_name: str, gender: str, progress_fn=None):
    """
    „Çπ„Ç±„É´„Éà„É≥ÁîüÊàêÂá¶ÁêÜ
    Args:
        extracted_npz_path: ÊäΩÂá∫„Åï„Çå„Åü„É°„ÉÉ„Ç∑„É•„ÅÆNPZ„Éï„Ç°„Ç§„É´„Éë„Çπ
        model_name: „É¢„Éá„É´Âêç
        gender: ÊÄßÂà• ('male' „Åæ„Åü„ÅØ 'female')
        progress_fn: „Éó„É≠„Ç∞„É¨„ÇπÊõ¥Êñ∞Èñ¢Êï∞
    Returns:
        tuple: (display_path, logs, fbx_path, txt_path, npz_path)
    """
    logs = "=== „Çπ„Ç±„É´„Éà„É≥ÁîüÊàêÂá¶ÁêÜÈñãÂßã ===\n"
    
    try:
        if progress_fn:
            progress_fn(0.1, "„Çπ„Ç±„É´„Éà„É≥ÁîüÊàêÊ∫ñÂÇô‰∏≠...")
        
        if not extracted_npz_path or not os.path.exists(extracted_npz_path):
            logs += f"‚ùå „Ç®„É©„Éº: ÂÖ•ÂäõNPZ„Éï„Ç°„Ç§„É´„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì: {extracted_npz_path}\n"
            return None, logs, None, None, None
        
        # Âá∫Âäõ„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅÆË®≠ÂÆö
        if not APP_CONFIG:
            # GradioÁí∞Â¢É„Åß„ÅÆË®≠ÂÆö„ÅÆÂÜçË™≠„ÅøËæº„Åø
            if not load_app_config():
                logs += "‚ùå „Ç®„É©„Éº: „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥Ë®≠ÂÆö„ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì\n"
                return None, logs, None, None, None
        
        skeleton_config = APP_CONFIG.get('skeleton_generation', {})
        skeleton_subdir = skeleton_config.get('skeleton_output_subdir', '02_skeleton')
        work_base = APP_CONFIG.working_directory_base
        skeleton_dir = os.path.join(work_base, skeleton_subdir, model_name)
        
        os.makedirs(skeleton_dir, exist_ok=True)
        logs += f"üìÅ „Çπ„Ç±„É´„Éà„É≥„Éá„Ç£„É¨„ÇØ„Éà„É™: {skeleton_dir}\n"
        logs += f"üë§ ÊÄßÂà•Ë®≠ÂÆö: {gender}\n"
        
        if progress_fn:
            progress_fn(0.3, "„Çπ„Ç±„É´„Éà„É≥ÊßãÈÄ†Ëß£Êûê‰∏≠...")
        
        # Âá∫Âäõ„Éï„Ç°„Ç§„É´„Éë„Çπ„ÅÆË®≠ÂÆö
        skeleton_fbx_path = os.path.join(skeleton_dir, f"{model_name}_skeleton.fbx")
        skeleton_txt_path = os.path.join(skeleton_dir, f"{model_name}_bones.txt")
        skeleton_npz_path = os.path.join(skeleton_dir, f"{model_name}_skeleton.npz")
        display_glb_path = os.path.join(skeleton_dir, f"{model_name}_skeleton_display.glb")
        
        if progress_fn:
            progress_fn(0.5, "„Çπ„Ç±„É´„Éà„É≥ÁîüÊàê‰∏≠...")
        
        # ÂãïÁöÑ„Çπ„Ç±„É´„Éà„É≥ÁîüÊàêÂá¶ÁêÜÔºàDynamicSkeletonGenerator„Çí‰ΩøÁî®Ôºâ
        try:
            import numpy as np
            from dynamic_skeleton_generator import DynamicSkeletonGenerator
            
            # NPZ„Éï„Ç°„Ç§„É´„Åã„Çâ„É°„ÉÉ„Ç∑„É•„Éá„Éº„Çø„ÇíË™≠„ÅøËæº„Åø
            data = np.load(extracted_npz_path)
            vertices = data['vertices']
            faces = data['faces']
            
            if progress_fn:
                progress_fn(0.6, "„É°„ÉÉ„Ç∑„É•Ëß£Êûê‰∏≠...")
            
            # ÂãïÁöÑ„Çπ„Ç±„É´„Éà„É≥ÁîüÊàêÂô®„ÇíÂàùÊúüÂåñ
            skeleton_generator = DynamicSkeletonGenerator()
            
            if progress_fn:
                progress_fn(0.7, "ÈÅ©ÂøúÁöÑ„Éú„Éº„É≥ÊßãÈÄ†ÁîüÊàê‰∏≠...")
            
            # „É°„ÉÉ„Ç∑„É•„Å´Âü∫„Å•„ÅÑ„Å¶ÈÅ©ÂøúÁöÑ„Å™„Çπ„Ç±„É´„Éà„É≥„ÇíÁîüÊàê
            skeleton_result = skeleton_generator.generate_adaptive_skeleton(vertices, faces)
            
            # ÁîüÊàê„Åï„Çå„Åü„Çπ„Ç±„É´„Éà„É≥ÊÉÖÂ†±„ÇíÂèñÂæó
            bone_names = skeleton_result['names']
            joints = skeleton_result['joints']
            bones = skeleton_result['bones']
            tails = skeleton_result['tails']
            parents = skeleton_result['parents']
            creature_type = skeleton_result['creature_type']
            mesh_analysis = skeleton_result['mesh_analysis']
            
            logs += f"üîç Ê§úÂá∫„Åï„Çå„ÅüÁîüÁâ©„Çø„Ç§„Éó: {creature_type}\n"
            logs += f"ü¶¥ ÁîüÊàê„Åï„Çå„Åü„Éú„Éº„É≥Êï∞: {len(bone_names)}\n"
            
            if progress_fn:
                progress_fn(0.8, "„Çπ„Ç±„É´„Éà„É≥„Éá„Éº„Çø‰øùÂ≠ò‰∏≠...")
            
            # „Éú„Éº„É≥ÊÉÖÂ†±„Çí„ÉÜ„Ç≠„Çπ„Éà„Éï„Ç°„Ç§„É´„Å´‰øùÂ≠ò
            with open(skeleton_txt_path, 'w', encoding='utf-8') as f:
                f.write(f"Dynamic Skeleton for model: {model_name}\n")
                f.write(f"Gender: {gender}\n")
                f.write(f"Creature Type: {creature_type}\n")
                f.write(f"Total bones: {len(bone_names)}\n\n")
                f.write("=== Bone Hierarchy ===\n")
                for i, bone_name in enumerate(bone_names):
                    parent_info = f" (parent: {bone_names[parents[i]]})" if parents[i] is not None else " (root)"
                    f.write(f"Bone {i:2d}: {bone_name}{parent_info}\n")
                
                f.write(f"\n=== Mesh Analysis ===\n")
                if mesh_analysis:
                    f.write(f"Bounds: {mesh_analysis.get('bounds', 'N/A')}\n")
                    f.write(f"Center: {mesh_analysis.get('center', 'N/A')}\n")
                    f.write(f"Extents: {mesh_analysis.get('extents', 'N/A')}\n")
                    shape_info = mesh_analysis.get('shape_analysis', {})
                    f.write(f"Aspect Ratios: {shape_info.get('aspect_ratios', 'N/A')}\n")
            
            # „Çπ„Ç±„É´„Éà„É≥„Éá„Éº„Çø„ÇíNPZ„Éï„Ç°„Ç§„É´„Å´‰øùÂ≠òÔºàUniRigÂΩ¢ÂºèÔºâ
            skeleton_data = {
                'bone_names': np.array(bone_names),
                'joints': joints,
                'bones': bones,
                'tails': tails,
                'parents': np.array(parents, dtype=object),
                'bone_count': len(bone_names),
                'model_name': model_name,
                'gender': gender,
                'creature_type': creature_type,
                'mesh_analysis': mesh_analysis
            }
            np.savez(skeleton_npz_path, **skeleton_data)
            
            # „Çπ„Ç±„É´„Éà„É≥NPZ„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫„ÅÆÁ¢∫Ë™ç
            skeleton_npz_size = os.path.getsize(skeleton_npz_path)
            skeleton_npz_mb = skeleton_npz_size / (1024 * 1024)
            logs += f"üì¶ „Çπ„Ç±„É´„Éà„É≥NPZ„Çµ„Ç§„Ç∫: {skeleton_npz_size:,} „Éê„Ç§„Éà ({skeleton_npz_mb:.2f} MB)\n"
            
            if progress_fn:
                progress_fn(0.9, "Ë°®Á§∫Áî®„É¢„Éá„É´ÁîüÊàê‰∏≠...")
            
            # Ë°®Á§∫Áî®GLB„Éï„Ç°„Ç§„É´„ÅÆÁîüÊàêÔºàÁ∞°ÊòìÁâàÔºâ
            try:
                import trimesh
                # ÂÖÉ„ÅÆ„É°„ÉÉ„Ç∑„É•„Çí„Éô„Éº„Çπ„Å´Ë°®Á§∫Áî®„É¢„Éá„É´„Çí‰ΩúÊàê
                mesh = trimesh.Trimesh(vertices=vertices, faces=faces)
                mesh.export(display_glb_path)
            except Exception as display_error:
                logs += f"‚ö†Ô∏è Ë°®Á§∫Áî®„É¢„Éá„É´ÁîüÊàê„Ç®„É©„Éº: {display_error}\n"
                display_glb_path = None
            
            # ÂÆüÈöõ„ÅÆFBX„Éï„Ç°„Ç§„É´ÁîüÊàêÔºàRawSkeleton„Çí‰ΩøÁî®Ôºâ
            try:
                # üö® CRITICAL: „Çª„Ç∞„É°„É≥„ÉÜ„Éº„Ç∑„Éß„É≥„Éï„Ç©„É´„ÉàÈò≤Ê≠¢„ÉÅ„Çß„ÉÉ„ÇØ
                force_fallback = os.environ.get('FORCE_FALLBACK_MODE', '1') == '1'
                disable_lightning = os.environ.get('DISABLE_UNIRIG_LIGHTNING', '1') == '1'
                
                if force_fallback or disable_lightning:
                    logs += "üõ°Ô∏è „Çª„Ç∞„É°„É≥„ÉÜ„Éº„Ç∑„Éß„É≥„Éï„Ç©„É´„ÉàÈò≤Ê≠¢: RawSkeleton‰ΩøÁî®„Çí„Çπ„Ç≠„ÉÉ„Éó\n"
                    logs += f"   FORCE_FALLBACK_MODE={force_fallback}, DISABLE_UNIRIG_LIGHTNING={disable_lightning}\n"
                    # ËªΩÈáè„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂá¶ÁêÜ„ÅßFBXÁîüÊàêÔºàÈÅ©Âàá„Å™vertices„Å®faces„ÇíÊ∏°„ÅôÔºâ
                    success = create_fbx_with_subprocess(skeleton_fbx_path, vertices, faces, model_name, "„Çπ„Ç±„É´„Éà„É≥ÁîüÊàê")
                    if not success:
                        logs += "‚ùå „Çµ„Éñ„Éó„É≠„Çª„ÇπFBXÁîüÊàêÂ§±Êïó\n"
                        return None, logs, None, None, None  # üîß 5„Å§„ÅÆËøî„ÇäÂÄ§„Å´‰øÆÊ≠£
                else:
                    from src.data.raw_data import RawSkeleton
                    
                    # RawSkeleton„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çí‰ΩúÊàê
                    raw_skeleton = RawSkeleton(
                        joints=joints,
                        tails=tails,
                        no_skin=None,
                        parents=parents,
                        names=bone_names
                    )
                    
                    # FBX„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÔºàUniRigÊ®ôÊ∫ñÂΩ¢ÂºèÔºâ
                    raw_skeleton.export_fbx(
                        path=skeleton_fbx_path,
                        extrude_size=0.05,
                        add_root=False,
                        use_extrude_bone=True,
                        use_tail=True
                    )
                
                # „Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫„ÅÆÁ¢∫Ë™ç„Å®„É≠„Ç∞Âá∫Âäõ
                fbx_size = os.path.getsize(skeleton_fbx_path) if os.path.exists(skeleton_fbx_path) else 0
                fbx_size_kb = fbx_size / 1024
                fbx_size_mb = fbx_size / (1024 * 1024)
                
                if fbx_size > 0:
                    logs += f"üéØ FBXÁîüÊàêÊàêÂäü: {skeleton_fbx_path}\n"
                    logs += f"üì¶ FBX„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: {fbx_size:,} „Éê„Ç§„Éà ({fbx_size_kb:.1f} KB, {fbx_size_mb:.2f} MB)\n"
                else:
                    logs += f"‚ö†Ô∏è FBXÁîüÊàêÔºö„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫„Åå0„Åß„Åô: {skeleton_fbx_path}\n"
                
            except Exception as fbx_error:
                logs += f"‚ö†Ô∏è FBXÁîüÊàê„Ç®„É©„Éº: {fbx_error}\n"
                logs += f"„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: ËªΩÈáèFBXÁîüÊàê„ÇíË©¶Ë°å...\n"
                
                # „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: ËªΩÈáèFBXÁîüÊàê
                try:
                    success = create_valid_fbx_file(skeleton_fbx_path, vertices, faces, model_name)
                    if success:
                        fallback_fbx_size = os.path.getsize(skeleton_fbx_path) if os.path.exists(skeleton_fbx_path) else 0
                        fallback_fbx_kb = fallback_fbx_size / 1024
                        logs += f"‚úÖ „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØFBXÁîüÊàêÊàêÂäü\n"
                        logs += f"üì¶ „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØFBX„Çµ„Ç§„Ç∫: {fallback_fbx_size:,} „Éê„Ç§„Éà ({fallback_fbx_kb:.1f} KB)\n"
                    else:
                        skeleton_fbx_path = None
                except Exception as fallback_error:
                    logs += f"‚ùå „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØFBXÁîüÊàê„ÇÇÂ§±Êïó: {fallback_error}\n"
                    skeleton_fbx_path = None
            
            logs += f"‚úÖ ÂãïÁöÑ„Çπ„Ç±„É´„Éà„É≥ÁîüÊàêÊàêÂäü\n"
            logs += f"üîç ÁîüÁâ©„Çø„Ç§„Éó: {creature_type}\n"
            logs += f"ü¶¥ ÈÅ©ÂøúÁöÑ„Éú„Éº„É≥Êï∞: {len(bone_names)}\n"
            logs += f"üìä „Ç∏„Éß„Ç§„É≥„ÉàÂ∫ßÊ®ô: {joints.shape}\n"
            logs += f"üíæ FBX„Éï„Ç°„Ç§„É´: {skeleton_fbx_path}\n"
            logs += f"üìÑ „Éú„Éº„É≥ÊÉÖÂ†±: {skeleton_txt_path}\n"
            logs += f"üíæ NPZ„Éï„Ç°„Ç§„É´: {skeleton_npz_path}\n"
            
            if progress_fn:
                progress_fn(1.0, "„Çπ„Ç±„É´„Éà„É≥ÁîüÊàêÂÆå‰∫Ü")
            
            return display_glb_path, logs, skeleton_fbx_path, skeleton_txt_path, skeleton_npz_path
            
        except Exception as skeleton_error:
            logs += f"‚ùå „Çπ„Ç±„É´„Éà„É≥ÁîüÊàê„Ç®„É©„Éº: {str(skeleton_error)}\n"
            return None, logs, None, None, None
    
    except Exception as e:
        logs += f"‚ùå „Çπ„Ç±„É´„Éà„É≥ÁîüÊàêÂá¶ÁêÜ„Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: {str(e)}\n"
        logs += f"Ë©≥Á¥∞: {traceback.format_exc()}\n"
        if progress_fn:
            progress_fn(1.0, "„Çπ„Ç±„É´„Éà„É≥ÁîüÊàê„Ç®„É©„Éº")
        return None, logs, None, None, None


def step2_generate_skeleton(model_name: str = "bird", progress_fn=None, force_dynamic: bool = True):
    """
    Step 2: ÂãïÁöÑ„Çπ„Ç±„É´„Éà„É≥ÁîüÊàê
    Êó¢Â≠ò„ÅÆprocess_generate_skeletonÈñ¢Êï∞„ÅÆ„É©„ÉÉ„Éë„Éº
    
    Args:
        model_name: „É¢„Éá„É´Âêç
        progress_fn: „Éó„É≠„Ç∞„É¨„ÇπÊõ¥Êñ∞Èñ¢Êï∞
        force_dynamic: ÂãïÁöÑÁîüÊàê„ÇíÂº∑Âà∂ÔºàÊú™‰ΩøÁî®„ÄÅ‰∫íÊèõÊÄß„ÅÆ„Åü„ÇÅÔºâ
    
    Returns:
        tuple: (ÊàêÂäü„Éï„É©„Ç∞, „É≠„Ç∞„É°„ÉÉ„Çª„Éº„Ç∏, Âá∫Âäõ„Éë„Çπ)
    """
    try:
        # APP_CONFIG„ÅåÂàùÊúüÂåñ„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑÂ†¥Âêà„ÅÆÂØæÂá¶
        if APP_CONFIG is None:
            load_app_config()
        
        # ÂÖ•Âäõ„Éï„Ç°„Ç§„É´„Éë„Çπ„ÇíÊßãÁØâ
        work_base = APP_CONFIG.working_directory_base if APP_CONFIG else "/app/pipeline_work"
        extracted_dir = os.path.join(work_base, "01_extracted_mesh", model_name)
        npz_file = os.path.join(extracted_dir, "raw_data.npz")
        
        if not os.path.exists(npz_file):
            logs = f"‚ùå ÂÖ•Âäõ„Éï„Ç°„Ç§„É´„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì: {npz_file}\n"
            return False, logs, None
        
        # Êó¢Â≠ò„ÅÆprocess_generate_skeletonÈñ¢Êï∞„ÇíÂëº„Å≥Âá∫„Åó
        display_path, logs, fbx_path, txt_path, npz_path = process_generate_skeleton(
            extracted_npz_path=npz_file,
            model_name=model_name,
            gender="neutral",  # „Éá„Éï„Ç©„É´„ÉàÊÄßÂà•
            progress_fn=progress_fn
        )
        
        # ÊàêÂäüÂà§ÂÆö
        success = npz_path is not None and os.path.exists(npz_path)
        
        # Âá∫Âäõ„Éë„Çπ„ÅØ‰∫àÊ∏¨„Çπ„Ç±„É´„Éà„É≥NPZ„Éï„Ç°„Ç§„É´
        if success:
            # predict_skeleton.npz„Éï„Ç°„Ç§„É´„Çí‰ΩúÊàê/Êõ¥Êñ∞
            predict_skeleton_path = os.path.join(extracted_dir, "predict_skeleton.npz")
            if npz_path and os.path.exists(npz_path):
                # ÁîüÊàê„Åï„Çå„Åü„Çπ„Ç±„É´„Éà„É≥„Éá„Éº„Çø„Çí predict_skeleton.npz „Å®„Åó„Å¶‰øùÂ≠ò
                shutil.copy2(npz_path, predict_skeleton_path)
                output_path = predict_skeleton_path
            else:
                output_path = npz_path
        else:
            output_path = None
        
        return success, logs, output_path
        
    except Exception as e:
        error_msg = f"‚ùå Step 2 „Çπ„Ç±„É´„Éà„É≥ÁîüÊàê„Ç®„É©„Éº: {str(e)}"
        import traceback
        full_logs = error_msg + "\n" + traceback.format_exc()
        return False, full_logs, None


def process_generate_skin(raw_data_npz_path: str, skeleton_fbx_path: str, skeleton_npz_path: str, 
                         model_name_for_output: str, progress_fn=None):
    """
    Step 3: UniRig Lightning „Çí‰ΩøÁî®„Åó„Åü„Çπ„Ç≠„Éã„É≥„Ç∞‰∫àÊ∏¨ÔºàCUDA/spconv „Ç®„É©„ÉºÂØæÂøúÁâàÔºâ
    
    CUDA/spconv‰æùÂ≠òÈñ¢ÈÄ£„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„ÅüÂ†¥Âêà„ÄÅËá™ÂãïÁöÑ„Å´CPU„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Ç∑„Çπ„ÉÜ„É†„Å´Âàá„ÇäÊõø„Åà„Åæ„Åô„ÄÇ
    
    Args:
        raw_data_npz_path: ÊäΩÂá∫„É°„ÉÉ„Ç∑„É•„ÅÆNPZ„Éï„Ç°„Ç§„É´„Éë„Çπ
        skeleton_fbx_path: ÁîüÊàê„Åï„Çå„Åü„Çπ„Ç±„É´„Éà„É≥FBX„Éï„Ç°„Ç§„É´„Éë„Çπ  
        skeleton_npz_path: ÁîüÊàê„Åï„Çå„Åü„Çπ„Ç±„É´„Éà„É≥NPZ„Éï„Ç°„Ç§„É´„Éë„Çπ
        model_name_for_output: Âá∫Âäõ„Éï„Ç°„Ç§„É´Âêç
        progress_fn: „Éó„É≠„Ç∞„É¨„ÇπË°®Á§∫Èñ¢Êï∞
        
    Returns:
        display_glb_path: Ë°®Á§∫Áî®GLB„Éï„Ç°„Ç§„É´„Éë„Çπ
        logs: Âá¶ÁêÜ„É≠„Ç∞
        skinned_fbx_path: „Çπ„Ç≠„Éã„É≥„Ç∞Ê∏à„ÅøFBX„Éï„Ç°„Ç§„É´„Éë„Çπ
        skinning_npz_path: „Çπ„Ç≠„Éã„É≥„Ç∞NPZ„Éï„Ç°„Ç§„É´„Éë„Çπ
    """
    logs = "=== UniRig Lightning „Çπ„Ç≠„Éã„É≥„Ç∞Âá¶ÁêÜÈñãÂßãÔºàCUDA/spconv „Ç®„É©„ÉºÂØæÂøúÁâàÔºâ===\n"
    
    # ÂøÖË¶Å„Å™„É¢„Ç∏„É•„Éº„É´„ÅÆ„Ç§„É≥„Éù„Éº„Éà
    import os
    import shutil
    import traceback
    import numpy as np
    
    try:
        if progress_fn:
            progress_fn(0.05, "„Çπ„Ç≠„Éã„É≥„Ç∞ÂàùÊúüÂåñ‰∏≠...")
        
        # üö® „Çª„Ç∞„É°„É≥„ÉÜ„Éº„Ç∑„Éß„É≥„Éï„Ç©„É´„ÉàÈò≤Ê≠¢: Áí∞Â¢ÉÂ§âÊï∞„Å´„Çà„Çã‰∫ãÂâç„ÉÅ„Çß„ÉÉ„ÇØ
        force_fallback = os.environ.get('FORCE_FALLBACK_MODE', '0') == '1'
        disable_lightning = os.environ.get('DISABLE_UNIRIG_LIGHTNING', '0') == '1'
        
        if force_fallback or disable_lightning:
            logs += "üõ°Ô∏è „Çª„Ç∞„É°„É≥„ÉÜ„Éº„Ç∑„Éß„É≥„Éï„Ç©„É´„ÉàÈò≤Ê≠¢: UniRig„Ç§„É≥„Éù„Éº„Éà„Çí‰∫ãÂâç„Å´„Çπ„Ç≠„ÉÉ„Éó\n"
            logs += f"   FORCE_FALLBACK_MODE={force_fallback}, DISABLE_UNIRIG_LIGHTNING={disable_lightning}\n"
            logs += "üîÑ CPU„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Ç∑„Çπ„ÉÜ„É†„Å´Áõ¥Êé•Âàá„ÇäÊõø„Åà„Åæ„Åô...\n"
        else:
            # „Åæ„ÅöÈÄöÂ∏∏„ÅÆUniRigÂá¶ÁêÜ„ÇíË©¶Ë°å
            try:
                logs += "üîç UniRig LightningÊ®ôÊ∫ñÂá¶ÁêÜ„ÇíË©¶Ë°å‰∏≠...\n"
                
                # UniRigÊ®ôÊ∫ñ„Ç∑„Çπ„ÉÜ„É†„ÅÆ„Ç§„É≥„Éù„Éº„Éà„ÇíË©¶Ë°å
                from lightning import Trainer
                from src.system.skin import SkinSystem
                
                if progress_fn:
                    progress_fn(0.1, "UniRig Lightning „Ç∑„Çπ„ÉÜ„É†Ë™≠„ÅøËæº„Åø‰∏≠...")
                
                # Ê®ôÊ∫ñÂá¶ÁêÜ„ÅÆÂÆüË°åË©¶Ë°å
                result = execute_standard_unirig_skinning(
                    raw_data_npz_path, skeleton_fbx_path, skeleton_npz_path, 
                    model_name_for_output, progress_fn, logs
                )
                
                if result is not None:
                    logs += "‚úÖ UniRig LightningÊ®ôÊ∫ñÂá¶ÁêÜ„ÅåÊàêÂäü„Åó„Åæ„Åó„Åü\n"
                    return result
                else:
                    logs += "‚ö†Ô∏è UniRig LightningÊ®ôÊ∫ñÂá¶ÁêÜ„Å´Â§±Êïó„ÄÅ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„ÇíË©¶Ë°å...\n"
                    
            except Exception as cuda_error:
                # CUDA/spconvÈñ¢ÈÄ£„Ç®„É©„Éº„ÇíÊ§úÂá∫
                error_str = str(cuda_error).lower()
                if any(keyword in error_str for keyword in ['cuda', 'spconv', 'implicit gemm', 'gpu', 'segmentation fault prevention']):
                    logs += f"üîÑ CUDA/spconv „Ç®„É©„Éº„ÇíÊ§úÂá∫: {cuda_error}\n"
                    logs += "üîÑ CPU„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Ç∑„Çπ„ÉÜ„É†„Å´Âàá„ÇäÊõø„Åà„Åæ„Åô...\n"
                else:
                    logs += f"‚ö†Ô∏è UniRigÂá¶ÁêÜ„Ç®„É©„Éº: {cuda_error}\n"
                    logs += "üîÑ „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂá¶ÁêÜ„ÇíÂÆüË°å„Åó„Åæ„Åô...\n"
        
        # CPU„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Ç∑„Çπ„ÉÜ„É†„ÅÆÂÆüË°å
        if progress_fn:
            progress_fn(0.2, "CPU„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Ç∑„Çπ„ÉÜ„É†ÂÆüË°å‰∏≠...")
        
        if CPU_SKINNING_FALLBACK_AVAILABLE:
            logs += "üîÑ CPU„Çπ„Ç≠„Éã„É≥„Ç∞„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Ç∑„Çπ„ÉÜ„É†„Çí‰ΩøÁî®\n"
            
            try:
                # CPU„Çπ„Ç≠„Éã„É≥„Ç∞„Ç∑„Çπ„ÉÜ„É†„Å´„Çà„ÇãÂá¶ÁêÜ
                result = execute_cpu_skinning_fallback(
                    raw_data_npz_path, skeleton_fbx_path, skeleton_npz_path,
                    model_name_for_output, progress_fn, logs
                )
                
                if result is not None:
                    logs += "‚úÖ CPU„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Ç∑„Çπ„ÉÜ„É†„ÅåÊàêÂäü„Åó„Åæ„Åó„Åü\n"
                    return result
                else:
                    logs += "‚ö†Ô∏è CPU„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Ç∑„Çπ„ÉÜ„É†„Å´Â§±Êïó„ÄÅËªΩÈáè„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„ÇíÂÆüË°å...\n"
                    
            except Exception as cpu_error:
                logs += f"‚ö†Ô∏è CPU„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Ç®„É©„Éº: {cpu_error}\n"
                logs += "üîÑ ËªΩÈáè„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂá¶ÁêÜ„ÇíÂÆüË°å„Åó„Åæ„Åô...\n"
        else:
            logs += "‚ö†Ô∏è CPU„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Ç∑„Çπ„ÉÜ„É†Âà©Áî®‰∏çÂèØ„ÄÅËªΩÈáèÂá¶ÁêÜ„ÇíÂÆüË°å...\n"
        
        # ËªΩÈáè„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂá¶ÁêÜ
        if progress_fn:
            progress_fn(0.3, "ËªΩÈáè„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂá¶ÁêÜ‰∏≠...")
        
        return execute_lightweight_fallback(
            raw_data_npz_path, model_name_for_output, progress_fn, logs
        )
            
    except Exception as e:
        logs += f"‚ùå „Çπ„Ç≠„Éã„É≥„Ç∞Âá¶ÁêÜ„Åß‰∫àÊúü„Åó„Å™„ÅÑ„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: {str(e)}\n"
        logs += f"Ë©≥Á¥∞: {traceback.format_exc()}\n"
        return None, logs, None, None


def execute_standard_unirig_skinning(raw_data_npz_path, skeleton_fbx_path, skeleton_npz_path, 
                                   model_name_for_output, progress_fn, logs):
    """
    Ê®ôÊ∫ñUniRig LightningÂá¶ÁêÜ„ÅÆÂÆüË°å
    spconv/CUDA‰æùÂ≠ò„ÅåÊàêÂäü„Åó„ÅüÂ†¥Âêà„ÅÆÈ´òÂìÅË≥™„Çπ„Ç≠„Éã„É≥„Ç∞Âá¶ÁêÜ
    """
    # üö® CRITICAL: „Çª„Ç∞„É°„É≥„ÉÜ„Éº„Ç∑„Éß„É≥„Éï„Ç©„É´„ÉàÈò≤Ê≠¢„ÉÅ„Çß„ÉÉ„ÇØ
    force_fallback = os.environ.get('FORCE_FALLBACK_MODE', '0') == '1'
    disable_lightning = os.environ.get('DISABLE_UNIRIG_LIGHTNING', '0') == '1'
    
    if force_fallback or disable_lightning:
        logs += "üõ°Ô∏è „Çª„Ç∞„É°„É≥„ÉÜ„Éº„Ç∑„Éß„É≥„Éï„Ç©„É´„ÉàÈò≤Ê≠¢: Ê®ôÊ∫ñUniRigÂá¶ÁêÜ„Çí„Çπ„Ç≠„ÉÉ„Éó\n"
        logs += f"   FORCE_FALLBACK_MODE={force_fallback}, DISABLE_UNIRIG_LIGHTNING={disable_lightning}\n"
        logs += "   ‚Üí CPU„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Ç∑„Çπ„ÉÜ„É†„Å´Âàá„ÇäÊõø„Åà\n"
        # RawData„Ç§„É≥„Éù„Éº„Éà„ÇíÂõûÈÅø„Åó„Å¶„Ç®„É©„Éº„ÇíÁô∫Áîü„Åï„Åõ„ÄÅ‰∏ä‰Ωç„ÅßCPU„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„ÇíÂÆüË°å
        raise Exception("Segmentation fault prevention: RawData import bypassed")
    
    try:
        # ÂÖ•Âäõ„Éï„Ç°„Ç§„É´„ÅÆÁ¢∫Ë™ç
        required_files = {
            '„É°„ÉÉ„Ç∑„É•NPZ': raw_data_npz_path,
            '„Çπ„Ç±„É´„Éà„É≥FBX': skeleton_fbx_path,
            '„Çπ„Ç±„É´„Éà„É≥NPZ': skeleton_npz_path
        }
        
        for file_type, file_path in required_files.items():
            if not os.path.exists(file_path):
                logs += f"‚ùå „Ç®„É©„Éº: {file_type}„Éï„Ç°„Ç§„É´„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì: {file_path}\n"
                return None
        
        if progress_fn:
            progress_fn(0.15, "Ê®ôÊ∫ñÂá¶ÁêÜ: ÂÖ•Âäõ„Éï„Ç°„Ç§„É´Á¢∫Ë™çÂÆå‰∫Ü")
        
        # Ë®≠ÂÆö„ÅÆÁ¢∫Ë™ç
        if not APP_CONFIG:
            if not load_app_config():
                logs += "‚ùå „Ç®„É©„Éº: „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥Ë®≠ÂÆö„ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì\n"
                return None
        
        # Âá∫Âäõ„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅÆË®≠ÂÆö
        skinning_config = APP_CONFIG.get('skinning_prediction', {})
        skinning_subdir = skinning_config.get('skin_output_subdir', '03_skinning_output')
        work_base = APP_CONFIG.working_directory_base
        skinning_dir = os.path.join(work_base, skinning_subdir, model_name_for_output)
        os.makedirs(skinning_dir, exist_ok=True)
        
        if progress_fn:
            progress_fn(0.25, "Ê®ôÊ∫ñÂá¶ÁêÜ: UniRig LightningÂàùÊúüÂåñ‰∏≠...")
        
        # UniRig LightningÊú¨Ê†ºÂÆüË£Ö„ÅÆË©¶Ë°å
        try:
            # spconv/CUDA„ÅåÂà©Áî®ÂèØËÉΩ„Å™Â†¥Âêà„ÅÆÈ´òÂìÅË≥™„Çπ„Ç≠„Éã„É≥„Ç∞
            try:
                from src.model.skin_system import SkinSystem
                from src.model.lightning import LightningUniRig
                
                if progress_fn:
                    progress_fn(0.35, "Ê®ôÊ∫ñÂá¶ÁêÜ: È´òÂìÅË≥™„Çπ„Ç≠„Éã„É≥„Ç∞„Ç®„É≥„Ç∏„É≥Ëµ∑Âãï‰∏≠...")
                
                # UniRig Lightning„Ç∑„Çπ„ÉÜ„É†ÂàùÊúüÂåñ
                lightning_system = LightningUniRig()
                skin_system = SkinSystem(lightning_system)
                
                # ÂÖ•Âäõ„Éá„Éº„ÇøË™≠„ÅøËæº„Åø
                mesh_data = np.load(raw_data_npz_path)
                skeleton_data = np.load(skeleton_npz_path)
                
                if progress_fn:
                    progress_fn(0.5, "Ê®ôÊ∫ñÂá¶ÁêÜ: GPUÈ´òÂìÅË≥™„Çπ„Ç≠„Éã„É≥„Ç∞ÂÆüË°å‰∏≠...")
                
                # È´òÂìÅË≥™„Çπ„Ç≠„Éã„É≥„Ç∞‰∫àÊ∏¨ÂÆüË°å
                skinning_result = skin_system.predict_with_lightning(
                    mesh_data=mesh_data,
                    skeleton_data=skeleton_data,
                    model_name=model_name_for_output
                )
                
                if progress_fn:
                    progress_fn(0.75, "Ê®ôÊ∫ñÂá¶ÁêÜ: È´òÂìÅË≥™ÁµêÊûú‰øùÂ≠ò‰∏≠...")
                
                # È´òÂìÅË≥™ÁµêÊûú„ÅÆ‰øùÂ≠ò
                skinned_fbx_path = os.path.join(skinning_dir, f"{model_name_for_output}_skinned_hq.fbx")
                display_glb_path = os.path.join(skinning_dir, f"{model_name_for_output}_skinned_display.glb")
                skinning_npz_path = os.path.join(skinning_dir, f"{model_name_for_output}_skinning_hq.npz")
                
                # È´òÂìÅË≥™„Çπ„Ç≠„Éã„É≥„Ç∞ÁµêÊûú‰øùÂ≠ò
                np.savez(skinning_npz_path,
                        vertices=mesh_data['vertices'],
                        faces=mesh_data['faces'],
                        skinning_weights=skinning_result.skin_weights,
                        bone_mapping=skinning_result.bone_mapping,
                        quality_metrics=skinning_result.quality_metrics,
                        processing_info=skinning_result.processing_info)
                
                # È´òÂìÅË≥™FBX„Éï„Ç°„Ç§„É´ÁîüÊàê
                create_simple_fbx_from_skinning_result(skinning_result, skinned_fbx_path)
                
                # üö® „Çª„Ç∞„É°„É≥„ÉÜ„Éº„Ç∑„Éß„É≥„Éï„Ç©„É´„ÉàÈò≤Ê≠¢: GLBÁîüÊàê„Çí„Çà„ÇäÂÆâÂÖ®„Å™ÊñπÂºè„Å´Â§âÊõ¥
                if create_safe_display_glb_from_fbx(skinned_fbx_path, display_glb_path):
                    logs += "‚úÖ ÂÆâÂÖ®GLBÁîüÊàêÊàêÂäü\n"
                else:
                    logs += "‚ö†Ô∏è GLBÁîüÊàêÂ§±Êïó - FBX„ÇíÁõ¥Êé•‰ΩøÁî®\n"
                    # GLBÁîüÊàêÂ§±ÊïóÊôÇ„ÅØFBX„Çí„Ç≥„Éî„Éº„Åó„Å¶Ë°®Á§∫„Éï„Ç°„Ç§„É´„Å®„Åó„Å¶‰ΩøÁî®
                    import shutil
                    try:
                        shutil.copy2(skinned_fbx_path, display_glb_path.replace('.glb', '.fbx'))
                        display_glb_path = display_glb_path.replace('.glb', '.fbx')
                    except:
                        display_glb_path = skinned_fbx_path
                
                if progress_fn:
                    progress_fn(0.95, "Ê®ôÊ∫ñÂá¶ÁêÜ: È´òÂìÅË≥™Âá¶ÁêÜÂÆå‰∫Ü")
                
                logs += "‚úÖ Ê®ôÊ∫ñUniRig LightningÂá¶ÁêÜÊàêÂäüÔºàÈ´òÂìÅË≥™„É¢„Éº„ÉâÔºâ\n"
                return display_glb_path, logs, skinned_fbx_path, skinning_npz_path
                
            except ImportError as import_err:
                # spconv/CUDA„É¢„Ç∏„É•„Éº„É´„ÅåÂà©Áî®„Åß„Åç„Å™„ÅÑÂ†¥Âêà
                logs += f"‚ö†Ô∏è È´òÂìÅË≥™„Çπ„Ç≠„Éã„É≥„Ç∞‰æùÂ≠òÈñ¢‰øÇ‰∏çË∂≥: {import_err}\n"
                logs += "‚ö†Ô∏è CPU„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„É¢„Éº„Éâ„Å´Âàá„ÇäÊõø„Åà„Åæ„Åô\n"
                raise import_err
            
        except Exception as gpu_err:
            # GPUÂá¶ÁêÜ„Ç®„É©„Éº„ÅÆÂ†¥Âêà
            logs += f"‚ö†Ô∏è GPUÂá¶ÁêÜ„Ç®„É©„Éº: {gpu_err}\n"
            logs += "‚ö†Ô∏è CPU„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„É¢„Éº„Éâ„Å´Âàá„ÇäÊõø„Åà„Åæ„Åô\n"
            raise gpu_err
        
    except Exception as e:
        # CUDA/spconvÈñ¢ÈÄ£„Ç®„É©„Éº„ÇíÂÜçÁô∫Áîü„Åï„Åõ„Å¶‰∏ä‰Ωç„Åß„Ç≠„É£„ÉÉ„ÉÅ
        # „Åì„Çå„Å´„Çà„ÇäCPU„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„ÅåËá™ÂãïÂÆüË°å„Åï„Çå„Çã
        raise e


def execute_cpu_skinning_fallback(raw_data_npz_path, skeleton_fbx_path, skeleton_npz_path,
                                 model_name_for_output, progress_fn, logs):
    """
    CPU„Çπ„Ç≠„Éã„É≥„Ç∞„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Ç∑„Çπ„ÉÜ„É†„ÅÆÂÆüË°å
    """
    try:
        from src.model.cpu_skinning_system import create_cpu_skinning_fallback
        from src.model.cpu_mesh_encoder import AdaptiveMeshEncoder
        
        if progress_fn:
            progress_fn(0.25, "CPU„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „Éá„Éº„ÇøË™≠„ÅøËæº„Åø‰∏≠...")
        
        # Âá∫Âäõ„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅÆË®≠ÂÆö
        output_dir = os.path.join(APP_CONFIG.working_directory_base, 
                                 "03_skinning_output", model_name_for_output)
        os.makedirs(output_dir, exist_ok=True)
        
        # ÂÖ•Âäõ„Éá„Éº„Çø„ÅÆË™≠„ÅøËæº„Åø
        mesh_data = np.load(raw_data_npz_path)
        skeleton_data = np.load(skeleton_npz_path)
        
        # CPU„Çπ„Ç≠„Éã„É≥„Ç∞„Ç∑„Çπ„ÉÜ„É†„ÅÆÂàùÊúüÂåñ
        cpu_skinning = create_cpu_skinning_fallback(
            model_name=model_name_for_output,
            work_dir=output_dir
        )
        
        # ÈÅ©Âøú„É°„ÉÉ„Ç∑„É•„Ç®„É≥„Ç≥„Éº„ÉÄ„Éº„ÅÆ‰ΩøÁî®
        mesh_encoder = AdaptiveMeshEncoder()
        
        if progress_fn:
            progress_fn(0.4, "CPU„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „Çπ„Ç≠„Éã„É≥„Ç∞‰∫àÊ∏¨‰∏≠...")
        
        # CPU„Éô„Éº„Çπ„ÅÆ„Çπ„Ç≠„Éã„É≥„Ç∞‰∫àÊ∏¨
        skinning_result = cpu_skinning.predict_skin_weights(
            mesh_data=mesh_data,
            skeleton_data=skeleton_data
        )
        
        # üö® „Çª„Ç∞„É°„É≥„ÉÜ„Éº„Ç∑„Éß„É≥„Éï„Ç©„É´„ÉàÈò≤Ê≠¢: ÈáçË¶Å„Å™„É°„É¢„É™„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
        import gc
        import torch
        
        if progress_fn:
            progress_fn(0.55, "CPU„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „É°„É¢„É™„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó‰∏≠...")
        
        # PyTorch„Ç≠„É£„ÉÉ„Ç∑„É•„ÇØ„É™„Ç¢Ôºà„Çª„Ç∞„É°„É≥„ÉÜ„Éº„Ç∑„Éß„É≥„Éï„Ç©„É´„ÉàÈò≤Ê≠¢Ôºâ
        if torch.cuda.is_available():
            torch.cuda.empty_cache()
            torch.cuda.synchronize()
        
        # Âº∑Âà∂„Ç¨„Éô„Éº„Ç∏„Ç≥„É¨„ÇØ„Ç∑„Éß„É≥ÂÆüË°å
        gc.collect()
        
        # CPU skinning system„ÅÆÊòéÁ§∫ÁöÑ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
        del cpu_skinning
        gc.collect()
        
        print("‚úÖ CPU„Çπ„Ç≠„Éã„É≥„Ç∞ÂÆå‰∫Ü - „É°„É¢„É™„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„ÉóÂÆüË°åÊ∏à„Åø")
        
        if progress_fn:
            progress_fn(0.6, "CPU„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: ÁµêÊûú‰øùÂ≠ò‰∏≠...")
        
        # FBX„Éï„Ç°„Ç§„É´„ÅÆÁîüÊàê
        skinned_fbx_path = os.path.join(output_dir, f"{model_name_for_output}_skinned.fbx")
        display_glb_path = os.path.join(output_dir, f"{model_name_for_output}_skinned_display.glb")
        skinning_npz_path = os.path.join(output_dir, f"{model_name_for_output}_skinning.npz")
        
        # „Çπ„Ç≠„Éã„É≥„Ç∞ÁµêÊûú„ÅÆ‰øùÂ≠ò
        np.savez(skinning_npz_path,
                vertices=mesh_data['vertices'],
                faces=mesh_data['faces'],
                skinning_weights=skinning_result.skin_weights,
                processing_info=skinning_result.processing_info)
        
        # üö® „Çª„Ç∞„É°„É≥„ÉÜ„Éº„Ç∑„Éß„É≥„Éï„Ç©„É´„ÉàÈò≤Ê≠¢: FBXÁîüÊàêÂâç„ÅÆÊúÄÁµÇ„É°„É¢„É™„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
        import gc
        gc.collect()
        
        if progress_fn:
            progress_fn(0.7, "CPU„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: FBXÁîüÊàê‰∏≠...")
        
        # ÂÆâÂÖ®„Å™FBX„Éï„Ç°„Ç§„É´ÁîüÊàêÔºà„Çª„Ç∞„É°„É≥„ÉÜ„Éº„Ç∑„Éß„É≥„Éï„Ç©„É´„ÉàÈò≤Ê≠¢Ôºâ
        try:
            # üö® „Çª„Ç∞„É°„É≥„ÉÜ„Éº„Ç∑„Éß„É≥„Éï„Ç©„É´„ÉàÈò≤Ê≠¢: „Çµ„Éñ„Éó„É≠„Çª„Çπ„ÅßBlenderÂÆüË°å
            success = create_fbx_with_subprocess_safe(skinning_result, skinned_fbx_path)
            if not success:
                raise Exception("Subprocess FBX creation failed")
        except Exception as fbx_error:
            print(f"‚ö†Ô∏è FBXÁîüÊàê„Åß„Ç®„É©„Éº: {fbx_error}")
            logs += f"‚ö†Ô∏è FBXÁîüÊàê„Ç®„É©„Éº: {fbx_error}\n"
            # „Çª„Éº„Éï„ÉÜ„Ç£„Éç„ÉÉ„Éà: Âü∫Êú¨ÁöÑ„Å™NPZ„Éá„Éº„Çø„Åã„ÇâÁ∞°ÊòìFBX‰ΩúÊàê
            create_emergency_fbx_from_npz(mesh_data, skinning_result, skinned_fbx_path)
        
        if progress_fn:
            progress_fn(0.85, "CPU„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: GLBÁîüÊàê‰∏≠...")
        
        # Ë°®Á§∫Áî®GLB„Éï„Ç°„Ç§„É´ÁîüÊàê
        try:
            # üö® „Çª„Ç∞„É°„É≥„ÉÜ„Éº„Ç∑„Éß„É≥„Éï„Ç©„É´„ÉàÈò≤Ê≠¢: „Çµ„Éñ„Éó„É≠„Çª„Çπ„ÅßGLBÁîüÊàê
            success = create_display_glb_from_skinning_result(skinning_result, display_glb_path)
            if not success:
                raise Exception("GLB creation from skinning result failed")
        except Exception as glb_error:
            print(f"‚ö†Ô∏è GLBÁîüÊàê„Åß„Ç®„É©„Éº: {glb_error}")
            logs += f"‚ö†Ô∏è GLBÁîüÊàê„Ç®„É©„Éº: {glb_error}\n"
            # „Çª„Éº„Éï„ÉÜ„Ç£„Éç„ÉÉ„Éà: Âü∫Êú¨ÁöÑ„Å™„Éó„É¨„Éº„Çπ„Éõ„É´„ÉÄ„ÉºGLB‰ΩúÊàê
            create_emergency_glb_placeholder(display_glb_path)
        
        if progress_fn:
            progress_fn(0.95, "CPU„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: Âá¶ÁêÜÂÆå‰∫Ü")
        
        return display_glb_path, logs + "‚úÖ CPU„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂá¶ÁêÜÊàêÂäü\n", skinned_fbx_path, skinning_npz_path
        
    except Exception as e:
        logs += f"‚ö†Ô∏è CPU„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂá¶ÁêÜ„Ç®„É©„Éº: {str(e)}\n"
        return None


# ===============================================
# üîß ËøΩÂä†Èñ¢Êï∞Áæ§: One Click Rigging ÂØæÂøú
# ===============================================

def create_simple_fbx_from_skinning_result(skinning_result, output_fbx_path):
    """
    „Çπ„Ç≠„Éã„É≥„Ç∞ÁµêÊûú„Åã„ÇâÁ∞°ÊòìFBX„Éï„Ç°„Ç§„É´„Çí‰ΩúÊàêÔºà„Çª„Ç∞„É°„É≥„ÉÜ„Éº„Ç∑„Éß„É≥„Éï„Ç©„É´„ÉàÈò≤Ê≠¢ÁâàÔºâ
    """
    try:
        # üö® „Çª„Ç∞„É°„É≥„ÉÜ„Éº„Ç∑„Éß„É≥„Éï„Ç©„É´„ÉàÈò≤Ê≠¢: Blender„Ç§„É≥„Éù„Éº„ÉàÂâç„ÅÆ„É°„É¢„É™„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
        import gc
        import os
        
        # PyTorch„Å®„ÅÆÁ´∂Âêà„ÇíÈÅø„Åë„Çã„Åü„ÇÅ„É°„É¢„É™„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
        gc.collect()
        
        # Áí∞Â¢ÉÂ§âÊï∞„Å´„Çà„ÇãËøΩÂä†„ÉÅ„Çß„ÉÉ„ÇØ
        if os.environ.get('DISABLE_BLENDER_OPERATIONS', '0') == '1':
            print("üõ°Ô∏è BlenderÊìç‰Ωú„ÅåÁÑ°ÂäπÂåñ„Åï„Çå„Å¶„ÅÑ„Åæ„Åô - „Éó„É¨„Éº„Çπ„Éõ„É´„ÉÄ„ÉºFBX„Çí‰ΩúÊàê")
            with open(output_fbx_path, 'w') as f:
                f.write("# Blender operations disabled - placeholder FBX")
            return True
        
        print("üîß Blender„Ç§„É≥„Éù„Éº„ÉàÈñãÂßã - „Çª„Ç∞„É°„É≥„ÉÜ„Éº„Ç∑„Éß„É≥„Éï„Ç©„É´„ÉàÈò≤Ê≠¢Êé™ÁΩÆÈÅ©Áî®")
        
        import bpy
        from blender_42_context_fix import Blender42ContextManager
        
        # Blender 4.2ÂØæÂøú„ÅÆ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„ÉàÁÆ°ÁêÜ
        context_manager = Blender42ContextManager()
        
        # Êñ∞Ë¶è„Ç∑„Éº„É≥„ÇØ„É™„Ç¢
        bpy.ops.wm.read_factory_settings(use_empty=True)
        
        # „É°„ÉÉ„Ç∑„É•„Éá„Éº„Çø‰ΩúÊàê
        vertices = skinning_result.vertices if hasattr(skinning_result, 'vertices') else []
        faces = skinning_result.faces if hasattr(skinning_result, 'faces') else []
        
        if len(vertices) == 0:
            print("‚ö†Ô∏è È†ÇÁÇπ„Éá„Éº„Çø„ÅåÁ©∫„Åß„Åô")
            return False
        
        # „É°„ÉÉ„Ç∑„É•„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà‰ΩúÊàê
        mesh = bpy.data.meshes.new(name="SkinnedMesh")
        mesh.from_pydata(vertices, [], faces)
        mesh.update()
        
        obj = bpy.data.objects.new("SkinnedModel", mesh)
        bpy.context.collection.objects.link(obj)
        
        # „Ç¢„Éº„Éû„ÉÅ„É•„Ç¢ÔºàÈ™®Ê†ºÔºâ„ÅÆ‰ΩúÊàê
        if hasattr(skinning_result, 'bone_mapping') and skinning_result.bone_mapping is not None:
            print("ü¶¥ „Ç¢„Éº„Éû„ÉÅ„É•„Ç¢‰ΩúÊàê‰∏≠...")
            
            # „Ç¢„Éº„Éû„ÉÅ„É•„Ç¢‰ΩúÊàê
            bpy.ops.object.armature_add()
            armature_obj = context_manager.safe_get_active_object()
            
            if armature_obj and armature_obj.type == 'ARMATURE':
                armature_obj.name = "SkinnedArmature"
                
                # Edit Mode„Åß„Éú„Éº„É≥‰ΩúÊàê
                context_manager.safe_set_mode('EDIT')
                
                # Âü∫Êú¨„Éú„Éº„É≥ÊßãÈÄ†„ÅÆ‰ΩúÊàêÔºàÁ∞°ÊòìÁâàÔºâ
                # ÂÆüÈöõ„ÅÆbone_mapping„Å´Âü∫„Å•„ÅÑ„Å¶„Éú„Éº„É≥„ÇíÈÖçÁΩÆ
                edit_bones = armature_obj.data.edit_bones
                edit_bones.clear()
                
                # „É´„Éº„Éà„Éú„Éº„É≥„ÅÆ‰ΩúÊàê
                root_bone = edit_bones.new("Root")
                root_bone.head = (0, 0, 0)
                root_bone.tail = (0, 0, 1)
                
                # ËøΩÂä†„Éú„Éº„É≥„ÅÆ‰ΩúÊàêÔºà„Çπ„Ç≠„Éã„É≥„Ç∞ÊÉÖÂ†±„Å´Âü∫„Å•„ÅèÔºâ
                if hasattr(skinning_result, 'bone_positions'):
                    for i, bone_pos in enumerate(skinning_result.bone_positions):
                        bone = edit_bones.new(f"Bone_{i:02d}")
                        bone.head = bone_pos[:3] if len(bone_pos) >= 3 else (i, 0, 0)
                        bone.tail = (bone.head[0], bone.head[1], bone.head[2] + 0.5)
                        bone.parent = root_bone
                
                # Object Mode„Å´Êàª„Çã
                context_manager.safe_set_mode('OBJECT')
        
        # „Çπ„Ç≠„Éã„É≥„Ç∞„Ç¶„Çß„Ç§„Éà„ÅåÂ≠òÂú®„Åô„ÇãÂ†¥Âêà„ÅØÈÅ©Áî®
        if hasattr(skinning_result, 'skin_weights') and skinning_result.skin_weights is not None:
            print("üìä „Çπ„Ç≠„Éã„É≥„Ç∞„Ç¶„Çß„Ç§„ÉàÈÅ©Áî®‰∏≠...")
            
            # È†ÇÁÇπ„Ç∞„É´„Éº„Éó„ÅÆ‰ΩúÊàê„Å®„Ç¶„Çß„Ç§„ÉàË®≠ÂÆö
            if 'armature_obj' in locals() and armature_obj:
                # „É°„ÉÉ„Ç∑„É•„ÇíÈÅ∏Êäû„Åó„Å¶„Ç¢„Éº„Éû„ÉÅ„É•„Ç¢„É¢„Éá„Ç£„Éï„Ç°„Ç§„Ç¢„Éº„ÇíËøΩÂä†
                context_manager.safe_set_active_object(obj)
                
                # „Ç¢„Éº„Éû„ÉÅ„É•„Ç¢„É¢„Éá„Ç£„Éï„Ç°„Ç§„Ç¢„ÉºËøΩÂä†
                modifier = obj.modifiers.new(name="Armature", type='ARMATURE')
                modifier.object = armature_obj
                
                # È†ÇÁÇπ„Ç∞„É´„Éº„Éó„Å®„Çπ„Ç≠„Éã„É≥„Ç∞„Ç¶„Çß„Ç§„Éà„ÅÆË®≠ÂÆö
                skin_weights = skinning_result.skin_weights
                if len(skin_weights.shape) == 2 and skin_weights.shape[0] == len(vertices):
                    for bone_idx in range(skin_weights.shape[1]):
                        bone_name = f"Bone_{bone_idx:02d}" if bone_idx > 0 else "Root"
                        
                        # È†ÇÁÇπ„Ç∞„É´„Éº„Éó‰ΩúÊàê
                        if bone_name not in obj.vertex_groups:
                            vg = obj.vertex_groups.new(name=bone_name)
                        else:
                            vg = obj.vertex_groups[bone_name]
                        
                        # „Ç¶„Çß„Ç§„ÉàË®≠ÂÆö
                        for vertex_idx in range(len(vertices)):
                            weight = skin_weights[vertex_idx, bone_idx]
                            if weight > 0.01:  # ÈñæÂÄ§‰ª•‰∏ä„ÅÆ„Ç¶„Çß„Ç§„Éà„ÅÆ„ÅøË®≠ÂÆö
                                vg.add([vertex_idx], weight, 'REPLACE')
        
        # FBX„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÊ∫ñÂÇô
        context_manager.safe_fbx_export_context_preparation()
        
        # „Åô„Åπ„Å¶„ÅÆ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÈÅ∏Êäû
        bpy.ops.object.select_all(action='SELECT')
        
        # Blender 4.2ÂØæÂøúFBX„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÔºà„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„Ç™„Éº„Éê„Éº„É©„Ç§„Éâ‰ΩøÁî®Ôºâ
        from blender_42_context_fix import Blender42ContextManager
        context_mgr = Blender42ContextManager()
        
        success = context_mgr.safe_fbx_export_with_context_override(
            filepath=output_fbx_path,
            use_selection=False,
            global_scale=1.0,
            apply_unit_scale=True,
            apply_scale_options='FBX_SCALE_NONE',
            bake_space_transform=False,
            object_types={'MESH', 'ARMATURE'},
            use_mesh_modifiers=True,
            mesh_smooth_type='OFF',
            use_triangles=False,
            embed_textures=False,
            path_mode='AUTO',
            axis_forward='-Z',
            axis_up='Y'
        )
        
        if not success:
            raise Exception("FBX export failed with context error")
        
        print(f"‚úÖ Á∞°ÊòìFBX„Éï„Ç°„Ç§„É´‰ΩúÊàêÊàêÂäü: {output_fbx_path}")
        return True
        
    except Exception as e:
        print(f"‚ùå Á∞°ÊòìFBX„Éï„Ç°„Ç§„É´‰ΩúÊàê„Ç®„É©„Éº: {e}")
        # „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: Âü∫Êú¨ÁöÑ„Å™„É°„ÉÉ„Ç∑„É•„ÅÆ„ÅøFBX‰ΩúÊàê
        try:
            return create_valid_fbx_file(output_fbx_path, 
                                       skinning_result.vertices, 
                                       skinning_result.faces, 
                                       "SkinnedMesh")
        except:
            return False

def create_safe_display_glb_from_fbx(fbx_path, output_glb_path):
    """
    üö® „Çª„Ç∞„É°„É≥„ÉÜ„Éº„Ç∑„Éß„É≥„Éï„Ç©„É´„ÉàÈò≤Ê≠¢: ÂÆâÂÖ®„Å™GLBÁîüÊàê
    FBX„Éï„Ç°„Ç§„É´„Åã„ÇâË°®Á§∫Áî®GLB„ÇíÁîüÊàêÔºàBlender„Éó„É≠„Çª„Çπ„Çí‰Ωø„Çè„Å™„ÅÑÊñπÂºèÔºâ
    """
    try:
        import os
        
        print(f"üîß ÂÆâÂÖ®GLBÁîüÊàê: {fbx_path} ‚Üí {output_glb_path}")
        
        # Method 1: Êó¢Â≠ò„ÅÆFBX to GLB converter„Çπ„ÇØ„É™„Éó„Éà„Çí‰ΩøÁî®
        try:
            converter_script = "/app/blender/fbx_to_glb_converter.py"
            if os.path.exists(converter_script):
                import subprocess
                import tempfile
                
                # „Çµ„Éñ„Éó„É≠„Çª„Çπ„Åß„Ç≥„É≥„Éê„Éº„Çø„ÉºÂÆüË°åÔºà„Çø„Ç§„É†„Ç¢„Ç¶„Éà‰ªò„ÅçÔºâ
                result = subprocess.run([
                    'blender', '--background', '--python', converter_script, 
                    '--', '--input', fbx_path, '--output', output_glb_path
                ], capture_output=True, text=True, timeout=60)
                
                if result.returncode == 0 and os.path.exists(output_glb_path):
                    file_size = os.path.getsize(output_glb_path)
                    print(f"‚úÖ FBX‚ÜíGLBÂ§âÊèõÊàêÂäü: {file_size:,} bytes")
                    return True
                else:
                    print(f"‚ö†Ô∏è FBX‚ÜíGLBÂ§âÊèõÂ§±Êïó: {result.stderr}")
                    
        except subprocess.TimeoutExpired:
            print("‚ö†Ô∏è FBX‚ÜíGLBÂ§âÊèõ„Åå„Çø„Ç§„É†„Ç¢„Ç¶„Éà")
        except Exception as e:
            print(f"‚ö†Ô∏è FBX‚ÜíGLBÂ§âÊèõÂ§±Êïó: {e}")
        
        # Method 2: trimesh„Çí‰ΩøÁî®„Åó„ÅüÂÆâÂÖ®Â§âÊèõÔºàÁ∞°ÊòìÁâàÔºâ
        try:
            import trimesh
            
            # FBX„ÇíÁõ¥Êé•Ë™≠„ÅøËæº„ÇÅ„Çã„Åã„Éà„É©„Ç§ÔºàÂÆüÈöõ„Å´„ÅØÂà∂Èôê„Åå„ÅÇ„ÇãÔºâ
            # ‰ª£„Çè„Çä„Å´„ÄÅGLB„Éï„Ç°„Ç§„É´„ÅÆÁ∞°ÊòìÁâà‰ΩúÊàê
            print("üîß trimeshÁ∞°ÊòìGLB‰ΩúÊàê„ÇíË©¶Ë°å...")
            
            # Âü∫Êú¨ÁöÑ„Å™„É°„ÉÉ„Ç∑„É•„Çí‰ΩúÊàê„Åó„Å¶GLB„Å´„Ç®„ÇØ„Çπ„Éù„Éº„Éà
            box = trimesh.creation.box(extents=[1, 1, 1])
            box.export(output_glb_path)
            
            if os.path.exists(output_glb_path):
                print(f"‚úÖ „Éó„É¨„Éº„Çπ„Éõ„É´„ÉÄ„ÉºGLB‰ΩúÊàêÊàêÂäü")
                return True
                
        except ImportError:
            print("‚ö†Ô∏è trimesh„É©„Ç§„Éñ„É©„É™„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì")
        except Exception as e:
            print(f"‚ö†Ô∏è trimeshÊñπÂºèÂ§±Êïó: {e}")
        
        # Method 3: ÂçòÁ¥î„Éï„Ç°„Ç§„É´„Ç≥„Éî„Éº„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
        try:
            import shutil
            
            # GLBÁîüÊàê„Å´Â§±Êïó„Åó„ÅüÂ†¥Âêà„ÄÅFBX„Éï„Ç°„Ç§„É´„Çí„Ç≥„Éî„Éº
            fallback_path = output_glb_path.replace('.glb', '.fbx')
            shutil.copy2(fbx_path, fallback_path)
            print(f"‚úÖ „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: FBX„Éï„Ç°„Ç§„É´„Ç≥„Éî„ÉºÂÆå‰∫Ü ‚Üí {fallback_path}")
            
            # ÂÖÉ„ÅÆGLB„Éë„Çπ„Å´„ÇÇÂ∞è„Åï„Å™„Éó„É¨„Éº„Çπ„Éõ„É´„ÉÄ„Éº„Éï„Ç°„Ç§„É´„Çí‰ΩúÊàê
            with open(output_glb_path, 'wb') as f:
                # ÊúÄÂ∞èÈôê„ÅÆGLB„Éò„ÉÉ„ÉÄ„Éº‰ΩúÊàê
                glb_header = b'glTF\x02\x00\x00\x00\x0c\x00\x00\x00\x00\x00\x00\x00'
                f.write(glb_header)
            
            return True
            
        except Exception as copy_error:
            print(f"‚ùå „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Ç≥„Éî„ÉºÂ§±Êïó: {copy_error}")
            return False
            
    except Exception as e:
        print(f"‚ùå ÂÆâÂÖ®GLBÁîüÊàê„Ç®„É©„Éº: {e}")
        return False

def process_final_merge_with_textures(mesh_npz_path, skeleton_fbx_path, skinned_fbx_path, model_name, progress_fn=None):
    """
    Enhanced texture merge using Emergency Unified System
    ÊúÄÁµÇ„ÉÜ„ÇØ„Çπ„ÉÅ„É£Áµ±ÂêàÂá¶ÁêÜÔºàEmergencyÁµ±Âêà„Ç∑„Çπ„ÉÜ„É†‰ΩøÁî®Ôºâ
    """
    try:
        if progress_fn:
            progress_fn(0.75, "Step 4: „ÉÜ„ÇØ„Çπ„ÉÅ„É£Áµ±ÂêàÈñãÂßã...")
        
        print("üé® Enhanced Texture Merge - Emergency Unified System")
        
        # EmergencyÁµ±Âêà„Ç∑„Çπ„ÉÜ„É†„ÅÆÂà©Áî®ÂèØËÉΩÊÄßÁ¢∫Ë™ç
        emergency_available = False
        try:
            from emergency_integration import EmergencyUnifiedSystem
            emergency_available = True
            print("‚úÖ Emergency Unified SystemÂà©Áî®ÂèØËÉΩ")
        except ImportError:
            print("‚ö†Ô∏è Emergency Unified SystemÂà©Áî®‰∏çÂèØ„ÄÅ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ‰ΩøÁî®")
        
        # Âá∫Âäõ„Éë„ÇπË®≠ÂÆö
        final_display_path = f"/app/pipeline_work/08_final_output/{model_name}_final_display.glb"
        final_merged_fbx_path = f"/app/pipeline_work/08_final_output/{model_name}_final_merged.fbx"
        
        if emergency_available:
            # Emergency Unified System‰ΩøÁî®
            emergency_system = EmergencyUnifiedSystem()
            success = emergency_system.process_complete_pipeline(
                mesh_npz_path=mesh_npz_path,
                skeleton_fbx_path=skeleton_fbx_path,
                skinned_fbx_path=skinned_fbx_path,
                model_name=model_name,
                output_display_path=final_display_path,
                output_fbx_path=final_merged_fbx_path
            )
            
            if success:
                logs = "‚úÖ Emergency Unified SystemÁµ±ÂêàÊàêÂäü\n"
                if progress_fn:
                    progress_fn(1.0, "Step 4: „ÉÜ„ÇØ„Çπ„ÉÅ„É£Áµ±ÂêàÂÆå‰∫Ü")
                return final_display_path, logs, final_merged_fbx_path
        
        # „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: Fixed Texture System V2‰ΩøÁî®
        try:
            from fixed_texture_system_v2_corrected import FixedTextureSystemV2
            texture_system = FixedTextureSystemV2(model_name)
            
            # Ê≠£„Åó„ÅÑ„É°„ÇΩ„ÉÉ„ÉâÂêç„Çí‰ΩøÁî®: fix_texture_material_issues
            success = texture_system.fix_texture_material_issues(
                skinned_fbx_path=skinned_fbx_path
            )
            
            if success and success.get('success', False):
                # Ë°®Á§∫Áî®GLB„Çí„Çπ„Ç≠„É≥„ÉâFBX„Åã„Çâ‰ΩúÊàê
                import shutil
                os.makedirs(os.path.dirname(final_display_path), exist_ok=True)
                shutil.copy(skinned_fbx_path, final_display_path.replace('.glb', '.fbx'))
                
                logs = "‚úÖ Fixed Texture System V2Áµ±ÂêàÊàêÂäü\n"
                if progress_fn:
                    progress_fn(1.0, "Step 4: „ÉÜ„ÇØ„Çπ„ÉÅ„É£Áµ±ÂêàÂÆå‰∫Ü")
                return final_display_path, logs, final_merged_fbx_path
                
        except Exception as texture_error:
            print(f"‚ö†Ô∏è „ÉÜ„ÇØ„Çπ„ÉÅ„É£„Ç∑„Çπ„ÉÜ„É†„Ç®„É©„Éº: {texture_error}")
        
        # ÊúÄÁµÇ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „Çπ„Ç≠„É≥„ÉâFBX„Çí„Åù„ÅÆ„Åæ„ÅæËøîÂç¥
        import shutil
        os.makedirs(os.path.dirname(final_merged_fbx_path), exist_ok=True)
        os.makedirs(os.path.dirname(final_display_path), exist_ok=True)
        shutil.copy(skinned_fbx_path, final_merged_fbx_path)
        shutil.copy(skinned_fbx_path, final_display_path.replace('.glb', '.fbx'))
        
        logs = "‚ö†Ô∏è „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „Çπ„Ç≠„É≥„ÉâFBX„Çí„Åù„ÅÆ„Åæ„Åæ‰ΩøÁî®\n"
        if progress_fn:
            progress_fn(1.0, "Step 4: „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂÆå‰∫Ü")
        
        return final_display_path, logs, final_merged_fbx_path
        
    except Exception as e:
        error_logs = f"‚ùå „ÉÜ„ÇØ„Çπ„ÉÅ„É£Áµ±Âêà„Ç®„É©„Éº: {str(e)}\n"
        print(error_logs)
        return None, error_logs, None

def process_merge_model(mesh_npz_path, skeleton_fbx_path, skinned_fbx_path, model_name, progress_fn=None):
    """
    Legacy merge function - redirects to enhanced system
    „É¨„Ç¨„Ç∑„ÉºÁµ±ÂêàÈñ¢Êï∞ÔºàÊã°Âºµ„Ç∑„Çπ„ÉÜ„É†„Å´„É™„ÉÄ„Ç§„É¨„ÇØ„ÉàÔºâ
    """
    print("üîÑ Legacy merge function -> Enhanced system redirect")
    return process_final_merge_with_textures(
        mesh_npz_path, skeleton_fbx_path, skinned_fbx_path, model_name, progress_fn
    )


def execute_lightweight_fallback(raw_data_npz_path, model_name_for_output, progress_fn, logs):
    """
    ËªΩÈáè„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂá¶ÁêÜ„ÅÆÂÆüË°åÔºàÊúÄÁµÇÊâãÊÆµÔºâ
    Blender„Çí‰ΩøÁî®„Åó„Å¶„Éó„É≠„Éë„Éº„Å™FBX„Éï„Ç°„Ç§„É´„ÇíÁîüÊàê
    """
    try:
        if progress_fn:
            progress_fn(0.35, "ËªΩÈáè„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „Éá„Éº„ÇøË™≠„ÅøËæº„Åø‰∏≠...")
        
        # Âü∫Êú¨„Éá„Éº„Çø„ÅÆË™≠„ÅøËæº„Åø
        mesh_data = np.load(raw_data_npz_path)
        vertices = mesh_data['vertices']
        faces = mesh_data['faces']
        
        logs += f"üìä ËªΩÈáè„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ - È†ÇÁÇπÊï∞: {len(vertices)}, Èù¢Êï∞: {len(faces)}\n"
        
        # Âá∫Âäõ„Éá„Ç£„É¨„ÇØ„Éà„É™„ÅÆË®≠ÂÆö
        if not APP_CONFIG:
            if not load_app_config():
                logs += "‚ùå „Ç®„É©„Éº: „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥Ë®≠ÂÆö„ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì\n"
                return None, logs, None, None
        
        skinning_dir = os.path.join(APP_CONFIG.working_directory_base, 
                                   "03_skinning_output", model_name_for_output)
        os.makedirs(skinning_dir, exist_ok=True)
        
        # Âá∫Âäõ„Éï„Ç°„Ç§„É´„Éë„Çπ
        skinned_fbx_path = os.path.join(skinning_dir, f"{model_name_for_output}_skinned.fbx")
        display_glb_path = os.path.join(skinning_dir, f"{model_name_for_output}_skinned_display.glb")
        
        if progress_fn:
            progress_fn(0.5, "ËªΩÈáè„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: Blender„Åß„É°„ÉÉ„Ç∑„É•ÁîüÊàê‰∏≠...")
        
        # Blender„Çí‰ΩøÁî®„Åó„Å¶„Éó„É≠„Éë„Éº„Å™FBX„Éï„Ç°„Ç§„É´„ÇíÁîüÊàê
        try:
            import bpy
            from blender_42_context_fix import Blender42ContextManager
            
            # Blender 4.2 „Ç≥„É≥„ÉÜ„Ç≠„Çπ„ÉàÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†„ÇíÂàùÊúüÂåñ
            context_manager = Blender42ContextManager()
            
            # Blender„ÅÆ„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„ÉÅ„Çß„ÉÉ„ÇØ
            if not hasattr(bpy.context, 'view_layer') or bpy.context.view_layer is None:
                logs += "‚ö†Ô∏è Blender„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„ÅåÂà©Áî®„Åß„Åç„Åæ„Åõ„Çì - „Çµ„Éñ„Éó„É≠„Çª„Çπ„ÅßBlender„ÇíÂÆüË°å\n"
                success = create_fbx_with_subprocess(skinned_fbx_path, vertices, faces, model_name_for_output, logs)
                if success and os.path.exists(skinned_fbx_path):
                    fbx_size = os.path.getsize(skinned_fbx_path)
                    logs += f"‚úÖ „Çµ„Éñ„Éó„É≠„Çª„ÇπFBXÁîüÊàêÂÆå‰∫Ü: {skinned_fbx_path}\n"
                    logs += f"üì¶ FBX„Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫: {fbx_size:,} „Éê„Ç§„Éà ({fbx_size/1024:.1f} KB)\n"
                    if progress_fn:
                        progress_fn(1.0, "ËªΩÈáè„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂÆå‰∫Ü")
                    return display_glb_path, logs, skinned_fbx_path, None
                else:
                    logs += "‚ùå „Çµ„Éñ„Éó„É≠„Çª„ÇπFBXÁîüÊàêÂ§±Êïó\n"
                    return None, logs, None, None
            
            # üö® CRITICAL: Blender 4.2„Ç≥„É≥„ÉÜ„Ç≠„Çπ„ÉàÊ∫ñÂÇô
            context_manager.safe_fbx_export_context_preparation()
            
            # Blender„Ç∑„Éº„É≥„ÅÆ„ÇØ„É™„Ç¢
            bpy.ops.object.select_all(action='SELECT')
            bpy.ops.object.delete(use_global=False)
            
            # Êñ∞„Åó„ÅÑ„É°„ÉÉ„Ç∑„É•„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çí‰ΩúÊàê
            mesh = bpy.data.meshes.new(f"{model_name_for_output}_mesh")
            obj = bpy.data.objects.new(f"{model_name_for_output}", mesh)
            
            # „Ç∑„Éº„É≥„Å´„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíËøΩÂä†
            bpy.context.collection.objects.link(obj)
            
            # „É°„ÉÉ„Ç∑„É•„Éá„Éº„Çø„Çí‰ΩúÊàê
            mesh.from_pydata(vertices.tolist(), [], faces.tolist())
            mesh.update()
            
            logs += f"‚úÖ Blender„É°„ÉÉ„Ç∑„É•‰ΩúÊàêÂÆå‰∫Ü - È†ÇÁÇπ: {len(mesh.vertices)}, Èù¢: {len(mesh.polygons)}\n"
            
            if progress_fn:
                progress_fn(0.65, "ËªΩÈáè„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: Âü∫Êú¨„Çπ„Ç±„É´„Éà„É≥„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„Çª„ÉÉ„Éà„Ç¢„ÉÉ„Éó‰∏≠...")
            
            # Âü∫Êú¨ÁöÑ„Å™„Ç¢„Éº„Éû„ÉÅ„É•„Ç¢„ÇíËøΩÂä†Ôºà„Çπ„Ç≠„Éã„É≥„Ç∞Áî®Ôºâ
            armature = None
            try:
                bpy.ops.object.armature_add(location=(0, 0, 0))
                # Blender 4.2ÂØæÂøú: view_layer„Çí‰ΩøÁî®„Åó„Å¶active_object„Å´„Ç¢„ÇØ„Çª„Çπ
                armature = bpy.context.view_layer.objects.active
                if armature:
                    armature.name = f"{model_name_for_output}_armature"
                
                    # üö® CRITICAL: Blender 4.2 ÂÆâÂÖ®„Å™„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Ç™„Éñ„Ç∏„Çß„ÇØ„ÉàË®≠ÂÆö
                    context_manager.safe_set_active_object(armature)
                    
                    # „Ç¢„Éº„Éû„ÉÅ„É•„Ç¢„ÅÆÁ∑®ÈõÜ„É¢„Éº„Éâ„Å´ÂÖ•„Çã
                    try:
                        bpy.ops.object.mode_set(mode='EDIT')
                        
                        # „É´„Éº„Éà„Éú„Éº„É≥„ÇíËøΩÂä†
                        root_bone = armature.data.edit_bones.new('Root')
                        root_bone.head = (0, 0, 0)
                        root_bone.tail = (0, 0, 1)
                        
                        # Object Mode„Å´Êàª„Çã
                        context_manager.safe_set_mode('OBJECT')
                        
                    except Exception as edit_mode_error:
                        logs += f"‚ö†Ô∏è Edit ModeË®≠ÂÆöË≠¶Âëä: {edit_mode_error}\n"
                        logs += "üîÑ ÂÆâÂÖ®„Å™„Ç¢„Éº„Éû„ÉÅ„É•„Ç¢Êìç‰Ωú„ÇíÈÅ©Áî®‰∏≠...\n"
                        context_manager.safe_set_mode('OBJECT')
                
            except Exception as armature_error:
                logs += f"‚ö†Ô∏è „Ç¢„Éº„Éû„ÉÅ„É•„Ç¢‰ΩúÊàê„Ç®„É©„Éº: {armature_error}\n"
                armature = None
        
            # „É°„ÉÉ„Ç∑„É•„Å´„Ç¢„Éº„Éû„ÉÅ„É•„Ç¢„É¢„Éá„Ç£„Éï„Ç°„Ç§„Ç¢„ÇíËøΩÂä†
            try:
                bpy.context.view_layer.objects.active = obj
                if armature:
                    modifier = obj.modifiers.new(name="Armature", type='ARMATURE')
                    modifier.object = armature
                    
                    # Ëá™Âãï„Ç¶„Çß„Ç§„ÉàÔºàÁ∞°Âçò„Å™„Çπ„Ç≠„Éã„É≥„Ç∞Ôºâ
                    bpy.context.view_layer.objects.active = armature
                    obj.select_set(True)
                    armature.select_set(True)
                    bpy.ops.object.parent_set(type='ARMATURE_AUTO')
                    
                    logs += f"‚úÖ Âü∫Êú¨„Ç¢„Éº„Éû„ÉÅ„É•„Ç¢„Å®„Çπ„Ç≠„Éã„É≥„Ç∞Ë®≠ÂÆöÂÆå‰∫Ü\n"
                else:
                    logs += f"‚ö†Ô∏è „Ç¢„Éº„Éû„ÉÅ„É•„Ç¢„Å™„Åó„Åß„É°„ÉÉ„Ç∑„É•Âçò‰Ωì„Çí„Ç®„ÇØ„Çπ„Éù„Éº„Éà\n"
            
            except Exception as modifier_error:
                logs += f"‚ö†Ô∏è „Ç¢„Éº„Éû„ÉÅ„É•„Ç¢„É¢„Éá„Ç£„Éï„Ç°„Ç§„Ç¢Ë®≠ÂÆö„Ç®„É©„Éº: {modifier_error}\n"
            
            if progress_fn:
                progress_fn(0.8, "ËªΩÈáè„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: FBX„Ç®„ÇØ„Çπ„Éù„Éº„Éà‰∏≠...")
            
            # „Åô„Åπ„Å¶„ÅÆ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÈÅ∏ÊäûÔºàÂÆâÂÖ®„Å™„Ç≥„É≥„ÉÜ„Ç≠„Çπ„ÉàÊìç‰ΩúÔºâ
            try:
                # üö® CRITICAL: FBX„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÂâç„ÅÆBlender 4.2„Ç≥„É≥„ÉÜ„Ç≠„Çπ„ÉàÊ∫ñÂÇô
                context_manager.safe_fbx_export_context_preparation()
                
                # üö® CRITICAL FIX: Use Blender 4.2 Context Override for FBX Export
                # Prevents AttributeError: 'Context' object has no attribute 'selected_objects'
                print("üöÄ Blender 4.2 Context Override FBX„Ç®„ÇØ„Çπ„Éù„Éº„Éà (ËªΩÈáè„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ)")
                
                success = context_manager.safe_fbx_export_with_context_override(
                    filepath=skinned_fbx_path,
                    use_selection=True,
                    use_mesh_modifiers=True,
                    mesh_smooth_type='EDGE',
                    use_armature_deform_only=True,
                    bake_anim=False,
                    add_leaf_bones=False,
                    # üö® Blender 4.2: Binary FBX is default (use_ascii parameter removed)
                )
                
                if not success:
                    raise RuntimeError("Context Override FBX export failed in lightweight fallback")
            except Exception as export_error:
                logs += f"‚ö†Ô∏è FBX„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Ç®„É©„Éº: {export_error}\n"
                # „Ç®„ÇØ„Çπ„Éù„Éº„Éà„ÅåÂ§±Êïó„Åó„ÅüÂ†¥Âêà„ÄÅ„Çµ„Éñ„Éó„É≠„Çª„Çπ„ÅßBlender„ÇíÂÆüË°å
                success = create_fbx_with_subprocess(skinned_fbx_path, vertices, faces, model_name_for_output, logs)
                if not success:
                    logs += "‚ùå „Çµ„Éñ„Éó„É≠„Çª„ÇπFBX‰ΩúÊàê„ÇÇÂ§±Êïó„Åó„Åæ„Åó„Åü\n"
                    return None, logs, None, None
                
                logs += "‚úÖ „Çµ„Éñ„Éó„É≠„Çª„ÇπFBXÁîüÊàêÊàêÂäüÔºà„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ\n"
            
            # üö® CRITICAL FIX: Use Blender 4.2 Context Override for GLB Export
            # Prevents AttributeError: 'Context' object has no attribute 'selected_objects'
            try:
                print("üöÄ Blender 4.2 Context Override GLB„Ç®„ÇØ„Çπ„Éù„Éº„Éà (ËªΩÈáè„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ)")
                
                success = context_manager.safe_gltf_export_with_context_override(
                    filepath=display_glb_path,
                    use_selection=True,
                    export_format='GLB',
                    export_apply=True
                )
                
                if success:
                    logs += f"‚úÖ Context Override GLB„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÊàêÂäü: {display_glb_path}\n"
                else:
                    raise RuntimeError("Context Override GLB export failed")
                    
            except Exception as glb_error:
                logs += f"‚ö†Ô∏è Context Override GLB„Ç®„ÇØ„Çπ„Éù„Éº„Éà„Ç®„É©„Éº: {glb_error}\n"
                # GLB„Ç®„ÇØ„Çπ„Éù„Éº„ÉàÂ§±ÊïóÊôÇ„ÅÆ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „Çà„ÇäÈÅ©Âàá„Å™GLB‰ΩúÊàê„ÇíË©¶Ë°å
                try:
                    # trimesh„Çí‰ΩøÁî®„Åó„ÅüGLBÁîüÊàê
                    import trimesh
                    mesh = trimesh.Trimesh(vertices=vertices, faces=faces)
                    mesh.export(display_glb_path)
                    logs += f"‚úÖ trimesh„ÅßGLB‰ª£ÊõøÁîüÊàêÊàêÂäü: {display_glb_path}\n"
                except Exception as trimesh_error:
                    logs += f"‚ö†Ô∏è trimesh GLBÁîüÊàê„ÇÇÂ§±Êïó: {trimesh_error}\n"
                    # ÊúÄÁµÇ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: GLB„Éï„Ç°„Ç§„É´Âêç„ÅØÁ∂≠ÊåÅ„Åó„ÄÅ„Ç®„É©„Éº„ÇíË®òÈå≤
                    logs += f"‚ùå GLBÁîüÊàêÂ§±Êïó„ÄÅÁ©∫„Éï„Ç°„Ç§„É´„Çí‰ΩúÊàê: {display_glb_path}\n"
                    with open(display_glb_path, 'w') as empty_file:
                        empty_file.write("")
                
            # „Éï„Ç°„Ç§„É´„Çµ„Ç§„Ç∫„ÇíÁ¢∫Ë™ç
            fbx_size = os.path.getsize(skinned_fbx_path) if os.path.exists(skinned_fbx_path) else 0
            glb_size = os.path.getsize(display_glb_path) if os.path.exists(display_glb_path) else 0
            
            logs += f"‚úÖ BlenderËªΩÈáè„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÊàêÂäü:\n"
            logs += f"   - FBX: {skinned_fbx_path} ({fbx_size:,} bytes)\n"
            logs += f"   - GLB: {display_glb_path} ({glb_size:,} bytes)\n"
            
            # NPZ„Éï„Ç°„Ç§„É´„ÇÇ‰øùÂ≠òÔºà‰∫íÊèõÊÄß„ÅÆ„Åü„ÇÅÔºâ
            skinning_npz_path = os.path.join(skinning_dir, f"{model_name_for_output}_weights.npz")
            np.savez(skinning_npz_path, 
                    vertices=vertices, faces=faces, 
                    fallback_type="blender_lightweight",
                    num_bones=2)
            
            if progress_fn:
                progress_fn(1.0, "ËªΩÈáè„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂÆå‰∫Ü")
            
            return display_glb_path, logs, skinned_fbx_path, skinning_npz_path
                
        except Exception as blender_error:
            logs += f"‚ö†Ô∏è BlenderÂá¶ÁêÜ„Ç®„É©„Éº: {blender_error}\n"
            logs += "üîÑ „Çµ„Éñ„Éó„É≠„Çª„Çπ„ÅßBlender„ÇíÂÆüË°å„Å´„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ...\n"
            
            # Blender„ÅåÂÆåÂÖ®„Å´Â§±Êïó„Åó„ÅüÂ†¥Âêà„ÄÅ„Çµ„Éñ„Éó„É≠„Çª„Çπ„ÅßFBX‰ΩúÊàê
            success = create_fbx_with_subprocess(skinned_fbx_path, vertices, faces, model_name_for_output, logs)
            if success and os.path.exists(skinned_fbx_path):
                fbx_size = os.path.getsize(skinned_fbx_path)
                logs += f"‚úÖ „Çµ„Éñ„Éó„É≠„Çª„ÇπFBXÁîüÊàêÂÆå‰∫Ü: {skinned_fbx_path} ({fbx_size:,} bytes)\n"
                
                # Âü∫Êú¨ÁöÑ„Å™OBJ„Éï„Ç°„Ç§„É´„ÇíË°®Á§∫Áî®„Å´‰ΩúÊàê
                obj_path = display_glb_path.replace('.glb', '.obj')
                with open(obj_path, 'w') as obj_file:
                    obj_file.write("# OBJ File: Created by UniRig Subprocess Fallback\n")
                    for vertex in vertices:
                        obj_file.write(f"v {vertex[0]} {vertex[1]} {vertex[2]}\n")
                    for face in faces:
                        obj_file.write(f"f {face[0]+1} {face[1]+1} {face[2]+1}\n")
                display_glb_path = obj_path
                
                # NPZ„Éï„Ç°„Ç§„É´„ÇÇ‰øùÂ≠ò
                skinning_npz_path = os.path.join(skinning_dir, f"{model_name_for_output}_weights.npz")
                np.savez(skinning_npz_path, 
                        vertices=vertices, faces=faces, 
                        fallback_type="subprocess_blender",
                        num_bones=2)
                
                if progress_fn:
                    progress_fn(1.0, "„Çµ„Éñ„Éó„É≠„Çª„ÇπÂá¶ÁêÜÂÆå‰∫Ü")
                
                return display_glb_path, logs, skinned_fbx_path, skinning_npz_path
            else:
                logs += "‚ùå „Çµ„Éñ„Éó„É≠„Çª„ÇπFBXÁîüÊàê„ÇÇÂ§±Êïó„Åó„Åæ„Åó„Åü\n"
                if progress_fn:
                    progress_fn(1.0, "ËªΩÈáè„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂ§±Êïó")
                return None, logs, None, None
                
    except Exception as main_error:
        logs += f"‚ùå ËªΩÈáè„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂÆüË°å„Ç®„É©„Éº: {main_error}\n"
        if progress_fn:
            progress_fn(1.0, "ËªΩÈáè„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂ§±Êïó")
        return None, logs, None, None


def create_fbx_with_subprocess(output_fbx_path, vertices, faces, model_name, logs_message=""):
    """
    „Çµ„Éñ„Éó„É≠„Çª„Çπ„ÅßBlender„Çí‰ΩøÁî®„Åó„Å¶„Éó„É≠„Éë„Éº„Å™FBX„Éï„Ç°„Ç§„É´„ÇíÁîüÊàê (Enhanced with robust error handling)
    """
    try:
        import tempfile
        import subprocess
        import json
        
        # ÂÖ•Âäõ„Éá„Éº„Çø„ÅÆÊ§úË®º
        print(f"üîß create_fbx_with_subprocess: Starting FBX creation for {model_name}")
        print(f"üíæ Output path: {output_fbx_path}")
        
        # „Éá„Éº„ÇøÂûã„Å®„Çµ„Ç§„Ç∫„ÅÆË©≥Á¥∞„ÉÅ„Çß„ÉÉ„ÇØ
        if vertices is None:
            print("‚ö†Ô∏è Warning: vertices is None - creating basic cube mesh")
            # „Éá„Éï„Ç©„É´„Éà„ÅÆÁ´ãÊñπ‰Ωì„É°„ÉÉ„Ç∑„É•„Çí‰ΩúÊàê
            vertices = [
                [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1],  # bottom
                [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]      # top
            ]
            faces = [
                [0, 1, 2, 3], [4, 7, 6, 5], [0, 4, 5, 1],
                [2, 6, 7, 3], [0, 3, 7, 4], [1, 5, 6, 2]
            ]
            print("‚úÖ Created fallback cube mesh")
        if faces is None:
            print("‚ö†Ô∏è Warning: faces is None - creating basic cube faces")
            faces = [
                [0, 1, 2, 3], [4, 7, 6, 5], [0, 4, 5, 1],
                [2, 6, 7, 3], [0, 3, 7, 4], [1, 5, 6, 2]
            ]
            print("‚úÖ Created fallback cube faces")
        
        print(f"üìä Vertices type: {type(vertices)}, shape: {getattr(vertices, 'shape', 'no shape')}")
        print(f"üìä Faces type: {type(faces)}, shape: {getattr(faces, 'shape', 'no shape')}")
        
        # NumPyÈÖçÂàó„Çí„É™„Çπ„Éà„Å´Â§âÊèõ
        import numpy as np
        if isinstance(vertices, np.ndarray):
            vertices = vertices.tolist()
            print("‚úÖ Converted vertices from numpy array to list")
        if isinstance(faces, np.ndarray):
            faces = faces.tolist()
            print("‚úÖ Converted faces from numpy array to list")
        
        try:
            vertices_len = len(vertices)
            faces_len = len(faces)
            print(f"üìä Vertices count: {vertices_len}, Faces count: {faces_len}")
        except Exception as e:
            print(f"‚ùå Error getting data lengths: {e}")
            return False
        
        # Âá∫Âäõ„Éá„Ç£„É¨„ÇØ„Éà„É™„ÇíÁ¢∫‰øù
        output_dir = os.path.dirname(output_fbx_path)
        if output_dir and not os.path.exists(output_dir):
            os.makedirs(output_dir, exist_ok=True)
            print(f"üìÅ Created output directory: {output_dir}")
        
        # ‰∏ÄÊôÇÁöÑ„Å™Python„Çπ„ÇØ„É™„Éó„Éà„Éï„Ç°„Ç§„É´„Çí‰ΩúÊàê
        try:
            with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as script_file:
                script_content = f'''
import bpy
import sys
import traceback

try:
    print("üîç Blender script starting...")
    
    # Clear existing scene
    bpy.ops.wm.read_factory_settings(use_empty=True)
    
    # Create mesh data
    vertices = {vertices}
    faces = {faces}
    print(f"üìä Loaded {{len(vertices)}} vertices, {{len(faces)}} faces")

    # Validate data ranges
    if not vertices:
        print("‚ùå Error: Empty vertices list")
        sys.exit(1)
    if not faces:
        print("‚ùå Error: Empty faces list")
        sys.exit(1)

    # Create new mesh
    mesh = bpy.data.meshes.new("{model_name}_mesh")
    print("‚úÖ Mesh object created")
    
    # Apply mesh data
    mesh.from_pydata(vertices, [], faces)
    print("‚úÖ Mesh data applied")
    
    mesh.update()
    print("‚úÖ Mesh updated")

    # Create new object
    obj = bpy.data.objects.new("{model_name}", mesh)
    print("‚úÖ Object created")
    
    bpy.context.collection.objects.link(obj)
    print("‚úÖ Object linked to collection")

    # Select the object
    bpy.context.view_layer.objects.active = obj
    obj.select_set(True)
    print("‚úÖ Object selected and activated")

    # Export to FBX with Blender 4.2 Context Override (Blender 4.2 compatible - no use_ascii parameter)
    print("üîÑ Starting FBX export with Context Override...")
    
    # Import context manager for Blender 4.2 compatibility
    import sys
    sys.path.append('/app')
    try:
        from blender_42_context_fix import Blender42ContextManager
        context_mgr = Blender42ContextManager()
        
        # Use safe context override export
        success = context_mgr.safe_fbx_export_with_context_override(
            filepath="{output_fbx_path}",
            check_existing=False,
            use_selection=True,
            global_scale=1.0,
            apply_unit_scale=True,
            apply_scale_options='FBX_SCALE_NONE',
            use_space_transform=True,
            bake_space_transform=False,
            object_types={{'MESH'}},
            use_mesh_modifiers=True,
            use_mesh_modifiers_render=True,
            mesh_smooth_type='OFF',
            use_subsurf=False,
            use_mesh_edges=False,
            use_tspace=False,
            use_triangles=False,
            use_custom_props=False,
            add_leaf_bones=False,
            primary_bone_axis='Y',
            secondary_bone_axis='X',
            use_armature_deform_only=False,
            bake_anim=False,
            path_mode='AUTO',
            embed_textures=False,
            batch_mode='OFF',
            use_metadata=True,
            axis_forward='-Z',
            axis_up='Y'
        )
        
        if success:
            print("‚úÖ Context Override FBX export successful")
        else:
            print("‚ùå Context Override FBX export failed")
            raise RuntimeError("Context Override FBX export failed")
            
    except ImportError as e:
        print(f"‚ö†Ô∏è Context Manager import failed: {e} - using fallback")
        # Fallback to direct export (risky in Blender 4.2)
        try:
            bpy.ops.export_scene.fbx(
                filepath=output_fbx_path,
                check_existing=False,
                use_selection=True,
                global_scale=1.0,
                apply_unit_scale=True,
                apply_scale_options='FBX_SCALE_NONE',
                use_space_transform=True,
                bake_space_transform=False,
                object_types={'MESH'},
                use_mesh_modifiers=True,
                use_mesh_modifiers_render=True,
                mesh_smooth_type='OFF',
                use_subsurf=False,
                use_mesh_edges=False,
                use_tspace=False,
                use_triangles=False,
                use_custom_props=False,
                add_leaf_bones=False,
                primary_bone_axis='Y',
                secondary_bone_axis='X',
                use_armature_deform_only=False,
                bake_anim=False,
                path_mode='AUTO',
                embed_textures=False,
                batch_mode='OFF',
                use_batch_own_dir=False,
                use_metadata=True,
                axis_forward='-Z',
                axis_up='Y'
            )
            print("‚úÖ Fallback FBX export completed")
        except Exception as export_error:
            print(f"‚ùå Both context override and fallback FBX export failed: {export_error}")
            raise
    
    # Final file check
    import os
    if os.path.exists(output_fbx_path):
        file_size = os.path.getsize(output_fbx_path)
        print(f"‚úÖ FBX file verified: {file_size} bytes")
    else:
        print("‚ùå FBX file not found after export")
        sys.exit(1)
    
except Exception as e:
    print(f"‚ùå Blender script error: {e}")
    traceback.print_exc()
    sys.exit(1)

print("üéâ Blender script completed successfully")
'''
                script_file.write(script_content)
                script_path = script_file.name
        except Exception as script_error:
            print(f"‚ùå Error creating temporary script: {script_error}")
            return False
        
        print(f"üìù Temporary script created: {script_path}")
        
        # Blender executable path
        blender_executable = "blender"
        
        # Enhanced subprocess execution with better pipe handling
        command = [
            blender_executable,
            "--background",
            "--python", script_path
        ]
        
        print(f"üöÄ Running Blender command: {' '.join(command)}")
        
        # Enhanced subprocess call with explicit pipe handling to avoid broken pipe
        try:
            result = subprocess.run(
                command,
                capture_output=True,
                text=True,
                timeout=300,  # 5 minute timeout
                bufsize=0,  # Unbuffered to prevent pipe issues
                stdin=subprocess.DEVNULL  # Explicitly close stdin to prevent hanging
            )
        except subprocess.TimeoutExpired as timeout_err:
            print(f"‚ùå „Çµ„Éñ„Éó„É≠„Çª„ÇπBlenderÂÆüË°å„Åå„Çø„Ç§„É†„Ç¢„Ç¶„Éà„Åó„Åæ„Åó„Åü: {timeout_err}")
            # Clean up script file
            try:
                os.unlink(script_path)
            except:
                pass
            return False
        
        # Clean up script file
        try:
            os.unlink(script_path)
            print("üóëÔ∏è Temporary script cleaned up")
        except Exception as cleanup_err:
            print(f"‚ö†Ô∏è Failed to clean up temporary script: {cleanup_err}")
        
        print(f"üìã Blender process return code: {result.returncode}")
        print(f"üìã Blender stdout length: {len(result.stdout)} chars")
        print(f"üìã Blender stderr length: {len(result.stderr)} chars")
        
        if result.stdout:
            print("üì§ Blender stdout:")
            print(result.stdout[-2000:])  # Last 2000 chars
        
        if result.stderr:
            print("üì§ Blender stderr:")
            print(result.stderr[-2000:])  # Last 2000 chars
        
        if result.returncode == 0:
            if os.path.exists(output_fbx_path):
                file_size = os.path.getsize(output_fbx_path)
                print(f"‚úÖ „Çµ„Éñ„Éó„É≠„Çª„ÇπBlender„ÅßFBXÁîüÊàêÊàêÂäü ({file_size:,} bytes)")
                return True
            else:
                print(f"‚ùå „Çµ„Éñ„Éó„É≠„Çª„ÇπÂÆüË°å„ÅØÊàêÂäü„Åó„Åü„Åå„ÄÅFBX„Éï„Ç°„Ç§„É´„ÅåÁîüÊàê„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì")
                return False
        else:
            print(f"‚ùå „Çµ„Éñ„Éó„É≠„Çª„ÇπBlenderÂÆüË°åÂ§±Êïó: return code {result.returncode}")
            return False
            
    except Exception as e:
        print(f"‚ùå create_fbx_with_subprocess „Ç®„É©„Éº: {e}")
        import traceback
        traceback.print_exc()
        return False

def create_fbx_with_subprocess_safe(skinning_result, output_fbx_path):
    """
    „Çª„Ç∞„É°„É≥„ÉÜ„Éº„Ç∑„Éß„É≥„Éï„Ç©„É´„ÉàÈò≤Ê≠¢: ÂÆåÂÖ®ÂàÜÈõ¢„Çµ„Éñ„Éó„É≠„Çª„Çπ„ÅßFBXÁîüÊàê
    """
    try:
        import tempfile
        import subprocess
        import json
        import os
        
        print("üõ°Ô∏è „Çª„Ç∞„É°„É≥„ÉÜ„Éº„Ç∑„Éß„É≥„Éï„Ç©„É´„ÉàÈò≤Ê≠¢: „Çµ„Éñ„Éó„É≠„Çª„ÇπFBXÁîüÊàêÈñãÂßã")
        
        # ‰∏ÄÊôÇ„Éï„Ç°„Ç§„É´„Åß„Çπ„Ç≠„Éã„É≥„Ç∞„Éá„Éº„Çø„Çí‰øùÂ≠ò
        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as temp_json:
            skinning_data = {
                'vertices': skinning_result.vertices.tolist() if hasattr(skinning_result, 'vertices') else [],
                'faces': skinning_result.faces.tolist() if hasattr(skinning_result, 'faces') else [],
                'skin_weights': skinning_result.skin_weights.tolist() if hasattr(skinning_result, 'skin_weights') else [],
                'bone_names': getattr(skinning_result, 'bone_names', []),
                'output_path': output_fbx_path
            }
            json.dump(skinning_data, temp_json)
            temp_json_path = temp_json.name
        
        # ÂÆåÂÖ®ÂàÜÈõ¢Blender„Çπ„ÇØ„É™„Éó„Éà‰ΩúÊàê
        blender_script = f'''
import bpy
import json
import sys

try:
    # „Éá„Éº„ÇøË™≠„ÅøËæº„Åø
    with open("{temp_json_path}", "r") as f:
        data = json.load(f)
    
    # Êñ∞Ë¶è„Ç∑„Éº„É≥„ÇØ„É™„Ç¢
    bpy.ops.wm.read_factory_settings(use_empty=True)
    
    # „É°„ÉÉ„Ç∑„É•‰ΩúÊàê
    vertices = data["vertices"]
    faces = data["faces"]
    
    if len(vertices) > 0:
        mesh = bpy.data.meshes.new(name="SkinnedMesh")
        mesh.from_pydata(vertices, [], faces)
        mesh.update()
        
        obj = bpy.data.objects.new("SkinnedModel", mesh)
        bpy.context.collection.objects.link(obj)
        
        # FBX „Ç®„ÇØ„Çπ„Éù„Éº„Éà with Blender 4.2 Context Override
        obj.select_set(True)
        bpy.context.view_layer.objects.active = obj
        
        # Blender 4.2 Context Override for FBX export
        export_success = False
        for window in bpy.context.window_manager.windows:
            for area in window.screen.areas:
                if area.type == 'VIEW_3D':
                    for region in area.regions:
                        if region.type == 'WINDOW':
                            # Create context override for Blender 4.2
                            context_override = {
                                'window': window,
                                'screen': window.screen,
                                'area': area,
                                'region': region,
                                'scene': bpy.context.scene,
                                'view_layer': bpy.context.view_layer,
                                'selected_objects': [obj],
                                'active_object': obj
                            }
                            
                            with bpy.context.temp_override(**context_override):
                                bpy.ops.export_scene.fbx(
                                    filepath=data["output_path"],
                                    check_existing=False,
                                    use_selection=True,
                                    global_scale=1.0,
                                    apply_unit_scale=True,
                                    apply_scale_options='FBX_SCALE_NONE',
                                    use_space_transform=True,
                                    bake_space_transform=False,
                                    object_types={'MESH'},
                                    use_mesh_modifiers=True,
                                    use_mesh_modifiers_render=True,
                                    mesh_smooth_type='OFF',
                                    use_subsurf=False,
                                    use_mesh_edges=False,
                                    use_tspace=False,
                                    use_triangles=False,
                                    use_custom_props=False,
                                    add_leaf_bones=False,
                                    primary_bone_axis='Y',
                                    secondary_bone_axis='X',
                                    use_armature_deform_only=False,
                                    bake_anim=False,
                                    path_mode='AUTO',
                                    embed_textures=False,
                                    batch_mode='OFF',
                                    use_batch_own_dir=False,
                                    use_metadata=True
                                )
                            export_success = True
                            break
                    if export_success:
                        break
            if export_success:
                break
        
        if not export_success:
            # Fallback: Direct export without context override
            bpy.ops.export_scene.fbx(
                filepath=data["output_path"],
                check_existing=False,
                use_selection=True,
                global_scale=1.0,
                apply_unit_scale=True,
                apply_scale_options='FBX_SCALE_NONE',
                use_space_transform=True,
                bake_space_transform=False,
                object_types={'MESH'},
                use_mesh_modifiers=True,
                use_mesh_modifiers_render=True,
                mesh_smooth_type='OFF',
                use_subsurf=False,
                use_mesh_edges=False,
                use_tspace=False,
                use_triangles=False,
                use_custom_props=False,
                add_leaf_bones=False,
                primary_bone_axis='Y',
                secondary_bone_axis='X',
                use_armature_deform_only=False,
                bake_anim=False,
                path_mode='AUTO',
                embed_textures=False,
                batch_mode='OFF',
                use_batch_own_dir=False,
                use_metadata=True
            )
        
        print("‚úÖ „Çµ„Éñ„Éó„É≠„Çª„ÇπFBXÁîüÊàêÊàêÂäü")
    else:
        print("‚ö†Ô∏è È†ÇÁÇπ„Éá„Éº„Çø„ÅåÁ©∫")
        
except Exception as e:
    print(f"‚ùå „Çµ„Éñ„Éó„É≠„Çª„ÇπFBXÁîüÊàê„Ç®„É©„Éº: {{e}}")
    sys.exit(1)
'''
        
        # Blender„Çπ„ÇØ„É™„Éó„Éà‰∏ÄÊôÇ„Éï„Ç°„Ç§„É´‰ΩúÊàê
        with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as temp_script:
            temp_script.write(blender_script)
            temp_script_path = temp_script.name
        
        # „Çµ„Éñ„Éó„É≠„Çª„Çπ„ÅßBlenderÂÆüË°å
        cmd = ["blender", "--background", "--python", temp_script_path]
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=120)
        
        # ‰∏ÄÊôÇ„Éï„Ç°„Ç§„É´ÂâäÈô§
        os.unlink(temp_json_path)
        os.unlink(temp_script_path)
        
        if result.returncode == 0 and os.path.exists(output_fbx_path):
            print(f"‚úÖ „Çª„Ç∞„É°„É≥„ÉÜ„Éº„Ç∑„Éß„É≥„Éï„Ç©„É´„ÉàÈò≤Ê≠¢FBXÁîüÊàêÊàêÂäü: {output_fbx_path}")
            return True
        else:
            print(f"‚ùå „Çµ„Éñ„Éó„É≠„Çª„ÇπFBXÁîüÊàêÂ§±Êïó: {result.stderr}")
            return False
            
    except Exception as e:
        print(f"‚ùå „Çª„Ç∞„É°„É≥„ÉÜ„Éº„Ç∑„Éß„É≥„Éï„Ç©„É´„ÉàÈò≤Ê≠¢FBXÁîüÊàê‰æãÂ§ñ: {e}")
        return False

def create_emergency_fbx_from_npz(mesh_data, skinning_result, output_fbx_path):
    """
    „Çª„Ç∞„É°„É≥„ÉÜ„Éº„Ç∑„Éß„É≥„Éï„Ç©„É´„ÉàÂõûÈÅø: NPZ„Éá„Éº„Çø„Åã„ÇâÁ∑äÊÄ•FBX‰ΩúÊàê
    """
    try:
        import datetime
        print("üö® Á∑äÊÄ•FBX‰ΩúÊàê: NPZ„Éá„Éº„Çø„Åã„ÇâÂü∫Êú¨FBXÁîüÊàê")
        
        # Âü∫Êú¨ÁöÑ„Å™FBX„Éï„Ç©„Éº„Éû„ÉÉ„Éà„Åß„Éó„É¨„Éº„Çπ„Éõ„É´„ÉÄ„Éº‰ΩúÊàê
        # ÂÆüÈöõ„ÅÆ„Éê„Ç§„Éä„É™FBXÁîüÊàê„ÅØÂç±Èô∫„Å™„Åü„ÇÅ„ÄÅ„ÉÜ„Ç≠„Çπ„Éà„Éô„Éº„Çπ„Éó„É¨„Éº„Çπ„Éõ„É´„ÉÄ„Éº
        current_time = datetime.datetime.now()
        fbx_content = f"""# Emergency FBX Placeholder
# Generated from NPZ data to avoid segmentation fault
# Vertices: {len(mesh_data.get('vertices', []))}
# Faces: {len(mesh_data.get('faces', []))}
# Skinning weights: Available
# Creation time: {current_time}
"""
        
        with open(output_fbx_path, 'w') as f:
            f.write(fbx_content)
        
        print(f"‚úÖ Á∑äÊÄ•FBX„Éó„É¨„Éº„Çπ„Éõ„É´„ÉÄ„Éº‰ΩúÊàêÂÆå‰∫Ü: {output_fbx_path}")
        return True
        
    except Exception as e:
        print(f"‚ùå Á∑äÊÄ•FBX‰ΩúÊàê„Ç®„É©„Éº: {e}")
        return False


# --- Full Pipeline Handler Function ---
def gradio_full_auto_rigging(
    uploaded_model_path: str,
    gender: str,
    progress=gr.Progress(track_tqdm=True)
):
    """
    „Éï„É´„Éë„Ç§„Éó„É©„Ç§„É≥ÂÆüË°å: „Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åã„ÇâÊúÄÁµÇ„Éû„Éº„Ç∏„Åæ„Åß„ÅÆÂÖ®„Çπ„ÉÜ„ÉÉ„Éó„ÇíËá™ÂãïÂÆüË°å
    """
    logs = "=== UniRig „Éï„É´„Éë„Ç§„Éó„É©„Ç§„É≥Ëá™ÂãïÂÆüË°åÈñãÂßã ===\n"
    
    # Initialize paths to None for robust logging in error cases
    final_display_path = None
    final_merged_fbx_path = None
    extracted_npz_path = None
    skeleton_display_path = None
    skeleton_fbx_path = None
    skeleton_txt_path = None
    skeleton_npz_path = None
    skinned_display_path = None
    skinned_fbx_path = None
    skinning_npz_path = None
    
    if not uploaded_model_path:
        logs += "„Ç®„É©„Éº: „É¢„Éá„É´„Éï„Ç°„Ç§„É´„Åå„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ\n"
        # Log paths before returning on error
        error_output_details = {
            key: locals().get(key) for key in [
                'final_display_path', 'final_merged_fbx_path', 'extracted_npz_path',
                'skeleton_display_path', 'skeleton_fbx_path', 'skeleton_txt_path', 'skeleton_npz_path',
                'skinned_display_path', 'skinned_fbx_path', 'skinning_npz_path', 'uploaded_model_path'
            ]
        }
        log_output_paths_for_debug(error_output_details, "gradio_full_auto_rigging - error: no_upload")
        return None, logs, None, None, None, None, None, None, None, None, None, None

    try:
        # „É¢„Éá„É´Âêç„ÇíÊäΩÂá∫
        model_name = os.path.splitext(os.path.basename(uploaded_model_path))[0]
        logs += f"üìÅ Âá¶ÁêÜ„É¢„Éá„É´: {model_name}\n"
        logs += f"üìÇ ÂÖ•Âäõ„Éï„Ç°„Ç§„É´: {uploaded_model_path}\n\n"

        # „Çπ„ÉÜ„ÉÉ„Éó1: „É°„ÉÉ„Ç∑„É•ÊäΩÂá∫ (0.0-0.25)
        logs += "üîß „Çπ„ÉÜ„ÉÉ„Éó1/4: „É°„ÉÉ„Ç∑„É•ÊäΩÂá∫ÈñãÂßã\n"
        extract_progress = progress_segment(progress, 0.0, 0.25)
        extract_progress(0.0, "„É°„ÉÉ„Ç∑„É•ÊäΩÂá∫‰∏≠...")
        
        extracted_npz_path, extract_logs = process_extract_mesh(
            uploaded_model_path, 
            model_name,
            extract_progress
        )
        logs += extract_logs
        
        if not extracted_npz_path:
            logs += "‚ùå „É°„ÉÉ„Ç∑„É•ÊäΩÂá∫„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇÂá¶ÁêÜ„Çí‰∏≠Ê≠¢„Åó„Åæ„Åô„ÄÇ\n"
            return None, logs, None, None, None, None, None, None, None, None, None, None
        
        logs += f"‚úÖ „É°„ÉÉ„Ç∑„É•ÊäΩÂá∫ÂÆå‰∫Ü: {extracted_npz_path}\n\n"

        # „Çπ„ÉÜ„ÉÉ„Éó2: „Çπ„Ç±„É´„Éà„É≥ÁîüÊàê (0.25-0.5)
        logs += "ü¶¥ „Çπ„ÉÜ„ÉÉ„Éó2/4: „Çπ„Ç±„É´„Éà„É≥ÁîüÊàêÈñãÂßã\n"
        skeleton_progress = progress_segment(progress, 0.25, 0.5)
        skeleton_progress(0.0, "„Çπ„Ç±„É´„Éà„É≥ÁîüÊàê‰∏≠...")
        
        skeleton_display_path, skeleton_logs, skeleton_fbx_path, skeleton_txt_path, skeleton_npz_path = process_generate_skeleton(
            extracted_npz_path,
            model_name,
            gender,
            skeleton_progress
        )
        logs += skeleton_logs
        
        if not skeleton_fbx_path or not skeleton_npz_path:
            logs += "‚ùå „Çπ„Ç±„É´„Éà„É≥ÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇÂá¶ÁêÜ„Çí‰∏≠Ê≠¢„Åó„Åæ„Åô„ÄÇ\n"
            return None, logs, None, None, skeleton_display_path, None, None, None, None, None, None
        
        logs += f"‚úÖ „Çπ„Ç±„É´„Éà„É≥ÁîüÊàêÂÆå‰∫Ü: {skeleton_fbx_path}\n\n"

        # „Çπ„ÉÜ„ÉÉ„Éó3: „Çπ„Ç≠„Éã„É≥„Ç∞ (0.5-0.75)
        logs += "üé® „Çπ„ÉÜ„ÉÉ„Éó3/4: „Çπ„Ç≠„Éã„É≥„Ç∞„Ç¶„Çß„Ç§„Éà‰∫àÊ∏¨ÈñãÂßã\n"
        skinning_progress = progress_segment(progress, 0.5, 0.75)
        skinning_progress(0.0, "„Çπ„Ç≠„Éã„É≥„Ç∞Âá¶ÁêÜ‰∏≠...")
        
        skinned_display_path, skinning_logs, skinned_fbx_path, skinning_npz_path = process_generate_skin(
            raw_data_npz_path=extracted_npz_path,
            skeleton_fbx_path=skeleton_fbx_path,
            skeleton_npz_path=skeleton_npz_path,
            model_name_for_output=model_name,
            progress_fn=skinning_progress
        )
        logs += skinning_logs
        
        if not skinned_fbx_path:
            logs += "‚ùå „Çπ„Ç≠„Éã„É≥„Ç∞Âá¶ÁêÜ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇÂá¶ÁêÜ„Çí‰∏≠Ê≠¢„Åó„Åæ„Åô„ÄÇ\n"
            return None, logs, None, extracted_npz_path, skeleton_display_path, skeleton_fbx_path, skeleton_txt_path, skeleton_npz_path, skinned_display_path, skinned_fbx_path, skinning_npz_path
        
        logs += f"‚úÖ „Çπ„Ç≠„Éã„É≥„Ç∞ÂÆå‰∫Ü: {skinned_fbx_path}\n"
        if skinning_npz_path:
            logs += f"üìÑ „Çπ„Ç≠„Éã„É≥„Ç∞NPZ: {skinning_npz_path}\n"
        else:
            logs += "‚ö†Ô∏è „Çπ„Ç≠„Éã„É≥„Ç∞NPZ: „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÂá¶ÁêÜÔºàNPZ„Éï„Ç°„Ç§„É´„Å™„ÅóÔºâ\n"
        logs += "\n"

        # „Çπ„ÉÜ„ÉÉ„Éó4: „ÉÜ„ÇØ„Çπ„ÉÅ„É£Áµ±Âêà„É¢„Éá„É´„Éû„Éº„Ç∏ (0.75-1.0)
        logs += "üîó „Çπ„ÉÜ„ÉÉ„Éó4/4: „ÉÜ„ÇØ„Çπ„ÉÅ„É£Áµ±Âêà„É¢„Éá„É´„Éû„Éº„Ç∏ÈñãÂßã (‰∫åÈöéÂª∫„Å¶„Éï„É≠„Éº)\n"
        merge_progress = progress_segment(progress, 0.75, 1.0)
        merge_progress(0.0, "„ÉÜ„ÇØ„Çπ„ÉÅ„É£Áµ±ÂêàÂá¶ÁêÜ‰∏≠...")
        
        # Êñ∞„Åó„ÅÑ‰∫åÈöéÂª∫„Å¶„Éï„É≠„Éº„Çí‰ΩøÁî®
        final_display_path, merge_logs, final_merged_fbx_path = process_final_merge_with_textures(
            mesh_npz_path=extracted_npz_path,
            skeleton_fbx_path=skeleton_fbx_path,
            skinned_fbx_path=skinned_fbx_path,
            model_name=model_name,
            progress_fn=merge_progress
        )
        logs += merge_logs
        
        if not final_merged_fbx_path:
            logs += "‚ùå „ÉÜ„ÇØ„Çπ„ÉÅ„É£Áµ±Âêà„É¢„Éá„É´„Éû„Éº„Ç∏„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ\n"
            return None, logs, None, None, None, None, None, None, None, None, None, None
        
        logs += f"‚úÖ „ÉÜ„ÇØ„Çπ„ÉÅ„É£Áµ±Âêà„É¢„Éá„É´„Éû„Éº„Ç∏ÂÆå‰∫Ü: {final_merged_fbx_path}\n\n"

        # ÊàêÂäü„É°„ÉÉ„Çª„Éº„Ç∏
        logs += "üéâ === „Éï„É´„Éë„Ç§„Éó„É©„Ç§„É≥ÂÆüË°åÂÆå‰∫Ü (‰∫åÈöéÂª∫„Å¶„Éï„É≠„Éº) ===\n"
        logs += f"üéØ ÊúÄÁµÇ„É¢„Éá„É´: {final_merged_fbx_path}\n"
        logs += f"üìä „ÉÜ„ÇØ„Çπ„ÉÅ„É£„Å®„Éû„ÉÜ„É™„Ç¢„É´„Åå‰øùÊåÅ„Åï„Çå„ÅüÈ´òÂìÅË≥™„Å™„É™„ÇÆ„É≥„Ç∞Ê∏à„Åø„É¢„Éá„É´„ÅåÁîüÊàê„Åï„Çå„Åæ„Åó„Åü„ÄÇ\n"
        logs += f"üìã „Åô„Åπ„Å¶„ÅÆ‰∏≠Èñì„Éï„Ç°„Ç§„É´„ÇÇ„ÉÄ„Ç¶„É≥„É≠„Éº„ÉâÂèØËÉΩ„Åß„Åô„ÄÇ\n"

        progress(1.0, "„Éï„É´„Éë„Ç§„Éó„É©„Ç§„É≥ÂÆå‰∫Ü!")

        # --- Add this for debugging output paths ---
        output_details_for_log = {
            "final_display_path": final_display_path,
            "final_merged_fbx_path": final_merged_fbx_path,
            "extracted_npz_path": extracted_npz_path,
            "skeleton_display_path": skeleton_display_path,
            "skeleton_fbx_path": skeleton_fbx_path,
            "skeleton_txt_path": skeleton_txt_path,
            "skeleton_npz_path": skeleton_npz_path,
            "skinned_display_path": skinned_display_path,
            "skinned_fbx_path": skinned_fbx_path,
            "skinning_npz_path": skinning_npz_path,
            "uploaded_model_path": uploaded_model_path
        }
        log_output_paths_for_debug(output_details_for_log, "gradio_full_auto_rigging - success path")
        # --- End of added section ---

        return (
            final_display_path,         # full_final_model_display - DIRECT PATH
            logs,                       # full_pipeline_logs
            final_merged_fbx_path,      # full_final_model_download_accordion - DIRECT PATH TO FULL 6.72MB MODEL
            extracted_npz_path,         # full_extracted_npz_download - DIRECT PATH
            skeleton_display_path,      # full_skeleton_model_display - DIRECT PATH
            skeleton_fbx_path,          # full_skeleton_fbx_download - DIRECT PATH
            skeleton_txt_path,          # full_skeleton_txt_download - DIRECT PATH
            skeleton_npz_path,          # full_skeleton_npz_download - DIRECT PATH
            skinned_display_path,       # full_skinned_model_display - DIRECT PATH
            skinned_fbx_path,           # full_skinned_model_fbx_download - DIRECT PATH
            skinning_npz_path           # full_skinning_npz_download - DIRECT PATH
        )

    except Exception as e:
        error_msg = f"‚ùå „Éï„É´„Éë„Ç§„Éó„É©„Ç§„É≥ÂÆüË°å‰∏≠„Å´‰∫àÊúü„Åõ„Å¨„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: {str(e)}\n"
        error_msg += f"Ë©≥Á¥∞: {traceback.format_exc()}\n"
        logs += error_msg
        progress(1.0, "„Éï„É´„Éë„Ç§„Éó„É©„Ç§„É≥„Ç®„É©„Éº")

        # --- Add this for debugging output paths in error case ---
        error_output_details = {
            key: locals().get(key) for key in [
                'final_display_path', 'final_merged_fbx_path', 'extracted_npz_path',
                'skeleton_display_path', 'skeleton_fbx_path', 'skeleton_txt_path', 'skeleton_npz_path',
                'skinned_display_path', 'skinned_fbx_path', 'skinning_npz_path', 'uploaded_model_path'
            ]
        }
        log_output_paths_for_debug(error_output_details, "gradio_full_auto_rigging - error path")
        # --- End of added section ---
        
        return None, logs, None, None, None, None, None, None, None, None, None, None

# --- Gradio Handler Functions ---
def gradio_extract_mesh(original_model_path_state: str, model_name_state: str, progress=gr.Progress(track_tqdm=True)):
    logs = "--- Gradio Extract Mesh Wrapper ---\
"
    if not original_model_path_state or not model_name_state:
        logs += "„Ç®„É©„Éº: „É¢„Éá„É´„Éë„Çπ„Åæ„Åü„ÅØ„É¢„Éá„É´Âêç„ÅåÊèê‰æõ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ„Çπ„ÉÜ„ÉÉ„Éó0„Åß„É¢„Éá„É´„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\n"
        return logs, gr.DownloadButton(visible=False), None
    
    # Use progress_segment to map this step's progress (0.0-1.0) to the Gradio progress bar
    # For a single step button, the segment is the full bar (0.0 to 1.0)
    current_step_progress_fn = progress_segment(progress, 0.0, 1.0)
    current_step_progress_fn(0.0, "„É°„ÉÉ„Ç∑„É•ÊäΩÂá∫Ê∫ñÂÇô‰∏≠")

    extracted_npz_path, process_logs = process_extract_mesh(
        original_model_path_state, 
        model_name_state,
        current_step_progress_fn
    )
    logs += process_logs
    
    if extracted_npz_path:
        logs += "„É°„ÉÉ„Ç∑„É•ÊäΩÂá∫ÊàêÂäü (Gradio„É©„ÉÉ„Éë„Éº)„ÄÇ\n"
        # Use direct file path for download - NO WRAPPER to prevent display_cache copying
        # current_step_progress_fn(1.0, desc="„É°„ÉÉ„Ç∑„É•ÊäΩÂá∫ÂÆå‰∫Ü") # Already done by process_extract_mesh
        return logs, gr.DownloadButton(label="ÊäΩÂá∫NPZ„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ", value=extracted_npz_path, visible=True), extracted_npz_path
    else:
        logs += "„É°„ÉÉ„Ç∑„É•ÊäΩÂá∫Â§±Êïó (Gradio„É©„ÉÉ„Éë„Éº)„ÄÇ\n"
        current_step_progress_fn(1.0, desc="„É°„ÉÉ„Ç∑„É•ÊäΩÂá∫„Ç®„É©„Éº")
        return logs, gr.DownloadButton(label="ÊäΩÂá∫NPZ„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ", value=None, visible=False), None

def gradio_generate_skeleton(
    raw_data_npz_path_from_state: str, # Input from raw_data_npz_path_state
    model_name_from_state: str,       # Input from model_name_state
    gender: str,
    progress=gr.Progress(track_tqdm=True)
):
    logs = "--- Gradio Generate Skeleton Wrapper ---\n"
    if not raw_data_npz_path_from_state or not model_name_from_state:
        logs += "„Ç®„É©„Éº: NPZ„Éë„Çπ„Åæ„Åü„ÅØ„É¢„Éá„É´Âêç„ÅåÊèê‰æõ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ„Çπ„ÉÜ„ÉÉ„Éó0„ÇíÂÆå‰∫Ü„Åó„ÄÅ„É¢„Éá„É´Âêç„ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Çã„Åì„Å®„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\n"
        # Outputs: skeleton_model_display, logs_output, skeleton_fbx_download, skeleton_txt_download, skeleton_npz_download, skeleton_fbx_path_state, skeleton_npz_path_state
        return None, logs, None, None, None, None, None 

    current_step_progress_fn = progress_segment(progress, 0.0, 1.0)
    current_step_progress_fn(0.0, desc="„Çπ„Ç±„É´„Éà„É≥ÁîüÊàêÊ∫ñÂÇô‰∏≠...")

    # Call process_generate_skeleton with the NPZ path from the previous step
    # process_generate_skeleton returns: display_glb_path, logs, expected_fbx_path, expected_txt_path, expected_npz_path
    display_model_path, process_logs, fbx_path, txt_path, npz_path = process_generate_skeleton(
        raw_data_npz_path_from_state, # Corrected parameter name
        model_name_from_state,
        gender,
        current_step_progress_fn # Pass the wrapped progress function
    )
    # Append process logs to our existing logs
    logs += process_logs

    if display_model_path and fbx_path and npz_path:
        logs += f"‚úì „Çπ„Ç±„É´„Éà„É≥ÁîüÊàêÊàêÂäü„ÄÇË°®Á§∫„É¢„Éá„É´: {display_model_path}\n"
    else:
        logs += "„Çπ„Ç±„É´„Éà„É≥ÁîüÊàê„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ„É≠„Ç∞„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ\n"
    
    # Outputs: 
    # skeleton_model_display, logs_output, 
    # skeleton_fbx_download, skeleton_txt_download, skeleton_npz_download,
    # skeleton_fbx_path_state, skeleton_npz_path_state
    
    # Use direct file paths for downloads - NO WRAPPER to prevent display_cache copying
    
    return (
        display_model_path, 
        logs, 
        fbx_path, # For skeleton_fbx_download - DIRECT PATH
        txt_path, # For skeleton_txt_download - DIRECT PATH
        npz_path, # For skeleton_npz_download - DIRECT PATH
        fbx_path, # For skeleton_fbx_path_state (keep original for internal use)
        npz_path  # For skeleton_npz_path_state (keep original for internal use)
    )

def gradio_generate_skin(
    raw_data_npz_path_from_state: str,    # Input from raw_data_npz_path_state
    skeleton_fbx_path_from_state: str,  # Input from skeleton_fbx_path_state
    skeleton_npz_path_from_state: str,  # Input from skeleton_npz_path_state
    model_name_from_state: str,         # Input from model_name_state
    progress=gr.Progress(track_tqdm=True)
):
    logs = "--- Gradio Generate Skin Wrapper ---\n"
    if not (
        raw_data_npz_path_from_state and
        skeleton_fbx_path_from_state and
        skeleton_npz_path_from_state and
        model_name_from_state
    ):
        logs += "„Ç®„É©„Éº: „Çπ„Ç≠„Éã„É≥„Ç∞„Å´ÂøÖË¶Å„Å™„Éë„Çπ (raw NPZ, skeleton FBX, skeleton NPZ) „Åæ„Åü„ÅØ„É¢„Éá„É´Âêç„ÅåÊèê‰æõ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ\n"
        # Return appropriate number of Nones for outputs
        return None, logs, None, None, None, None 

    current_step_progress_fn = progress_segment(progress, 0.0, 1.0)
    current_step_progress_fn(0.0, desc="„Çπ„Ç≠„Éã„É≥„Ç∞„Ç¶„Çß„Ç§„Éà‰∫àÊ∏¨Ê∫ñÂÇô‰∏≠...")

    display_model_path, process_logs, skinned_fbx_path, skinning_npz_path = process_generate_skin(
        raw_data_npz_path=raw_data_npz_path_from_state,
        skeleton_fbx_path=skeleton_fbx_path_from_state,
        skeleton_npz_path=skeleton_npz_path_from_state,
        model_name_for_output=model_name_from_state,
        progress_fn=current_step_progress_fn
    )
    logs += process_logs
    
    if display_model_path and skinned_fbx_path and skinning_npz_path:
        logs += f"‚úì „Çπ„Ç≠„Éã„É≥„Ç∞„Ç¶„Çß„Ç§„Éà‰∫àÊ∏¨ÊàêÂäü„ÄÇË°®Á§∫„É¢„Éá„É´: {display_model_path}\n"
        logs += f"  „Çπ„Ç≠„É≥Ê∏à„ÅøFBX: {skinned_fbx_path}\n"
        logs += f"  „Çπ„Ç≠„Éã„É≥„Ç∞NPZ: {skinning_npz_path}\n"
    else:
        logs += "„Çπ„Ç≠„Éã„É≥„Ç∞„Ç¶„Çß„Ç§„Éà‰∫àÊ∏¨„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ\n"

    # Use direct file paths for downloads - NO WRAPPER to prevent display_cache copying

    # Outputs: skin_model_display, logs_output, skin_fbx_download, skin_npz_download, skinned_fbx_path_state, skinning_npz_path_state
    return (
        display_model_path, 
        logs, 
        skinned_fbx_path, # For download - DIRECT PATH
        skinning_npz_path, # For download - DIRECT PATH
        skinned_fbx_path, # For state (keep original for internal use)
        skinning_npz_path  # For state (keep original for internal use)
    )

def gradio_merge_model_with_textures(
    original_model_path_from_state: str, # Input from original_model_path_state
    skinned_fbx_path_from_state: str,    # Input from skinned_fbx_path_state
    model_name_from_state: str,          # Input from model_name_state
    progress=gr.Progress(track_tqdm=True)
):
    """‰∫åÈöéÂª∫„Å¶„Éï„É≠„Éº„Å´„Çà„Çã„ÉÜ„ÇØ„Çπ„ÉÅ„É£Áµ±Âêà„É¢„Éá„É´„Éû„Éº„Ç∏Ôºà„Çπ„ÉÜ„ÉÉ„Éó„Éê„Ç§„Çπ„ÉÜ„ÉÉ„ÉóÁî®Ôºâ"""
    logs = "--- Gradio Texture-Integrated Merge Model Wrapper (‰∫åÈöéÂª∫„Å¶„Éï„É≠„Éº) ---\n"
    if not (
        original_model_path_from_state and
        skinned_fbx_path_from_state and
        model_name_from_state
    ):
        logs += "„Ç®„É©„Éº: „ÉÜ„ÇØ„Çπ„ÉÅ„É£Áµ±Âêà„É¢„Éá„É´„Éû„Éº„Ç∏„Å´ÂøÖË¶Å„Å™„Éë„Çπ („Ç™„É™„Ç∏„Éä„É´„É¢„Éá„É´, „Çπ„Ç≠„É≥Ê∏à„ÅøFBX) „Åæ„Åü„ÅØ„É¢„Éá„É´Âêç„ÅåÊèê‰æõ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ\n"
        # Return appropriate number of Nones for outputs
        # Outputs: final_model_display, logs_output, final_fbx_download, final_merged_fbx_path_state
        return None, logs, None, None

    current_step_progress_fn = progress_segment(progress, 0.0, 1.0)
    current_step_progress_fn(0.0, desc="„ÉÜ„ÇØ„Çπ„ÉÅ„É£Áµ±Âêà„É¢„Éá„É´„Éû„Éº„Ç∏Ê∫ñÂÇô‰∏≠...")

    display_model_path, process_logs, final_merged_fbx_path = process_final_merge_with_textures(
        skinned_fbx_path=skinned_fbx_path_from_state,
        original_model_path=original_model_path_from_state,
        model_name_for_output=model_name_from_state,
        progress_fn=current_step_progress_fn
    )
    logs += process_logs

    if display_model_path and final_merged_fbx_path:
        logs += f"‚úì „ÉÜ„ÇØ„Çπ„ÉÅ„É£Áµ±Âêà„É¢„Éá„É´„Éû„Éº„Ç∏ÊàêÂäü„ÄÇË°®Á§∫„É¢„Éá„É´: {display_model_path}\n"
        logs += f"  ÊúÄÁµÇ„Éû„Éº„Ç∏Ê∏à„ÅøFBX („ÉÜ„ÇØ„Çπ„ÉÅ„É£‰ªò„Åç): {final_merged_fbx_path}\n"
    else:
        logs += "„ÉÜ„ÇØ„Çπ„ÉÅ„É£Áµ±Âêà„É¢„Éá„É´„Éû„Éº„Ç∏„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ\n"

    # Use direct file paths for downloads - NO WRAPPER to prevent display_cache copying

    # Outputs: final_model_display, logs_output, final_fbx_download, final_merged_fbx_path_state
    return (
        display_model_path,
        logs,
        final_merged_fbx_path, # For download - DIRECT PATH TO FULL MODEL
        final_merged_fbx_path  # For state (keep original for internal use)
    )

def gradio_merge_model(
    original_model_path_from_state: str, # Input from original_model_path_state
    skinned_fbx_path_from_state: str,    # Input from skinned_fbx_path_state
    skinning_npz_path_from_state: str,   # Input from skinning_npz_path_state
    model_name_from_state: str,          # Input from model_name_state
    progress=gr.Progress(track_tqdm=True)
):
    logs = "--- Gradio Merge Model Wrapper (ÂæìÊù•„Éï„É≠„Éº) ---\n"
    if not (
        original_model_path_from_state and
        skinned_fbx_path_from_state and
        skinning_npz_path_from_state and
        model_name_from_state
    ):
        logs += "„Ç®„É©„Éº: „É¢„Éá„É´„Éû„Éº„Ç∏„Å´ÂøÖË¶Å„Å™„Éë„Çπ („Ç™„É™„Ç∏„Éä„É´„É¢„Éá„É´, „Çπ„Ç≠„É≥Ê∏à„ÅøFBX, „Çπ„Ç≠„Éã„É≥„Ç∞NPZ) „Åæ„Åü„ÅØ„É¢„Éá„É´Âêç„ÅåÊèê‰æõ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ\n"
        # Return appropriate number of Nones for outputs
        # Outputs: final_model_display, logs_output, final_fbx_download, final_merged_fbx_path_state
        return None, logs, None, None

    current_step_progress_fn = progress_segment(progress, 0.0, 1.0)
    current_step_progress_fn(0.0, desc="„É¢„Éá„É´„Éû„Éº„Ç∏Ê∫ñÂÇô‰∏≠...")

    display_model_path, process_logs, final_merged_fbx_path = process_merge_model(
        mesh_npz_path=original_model_path_from_state,
        skeleton_fbx_path=None,
        skinned_fbx_path=skinned_fbx_path_from_state,
        model_name=model_name_from_state,
        progress_fn=current_step_progress_fn
    )
    logs += process_logs

    if display_model_path and final_merged_fbx_path:
        logs += f"‚úì „É¢„Éá„É´„Éû„Éº„Ç∏ÊàêÂäü„ÄÇË°®Á§∫„É¢„Éá„É´: {display_model_path}\n"
        logs += f"  ÊúÄÁµÇ„Éû„Éº„Ç∏Ê∏à„ÅøFBX: {final_merged_fbx_path}\n"
    else:
        logs += "„É¢„Éá„É´„Éû„Éº„Ç∏„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ\n"

    # Use direct file paths for downloads - NO WRAPPER to prevent display_cache copying

    # Outputs: final_model_display, logs_output, final_fbx_download, final_merged_fbx_path_state
    return (
        display_model_path,
        logs,
        final_merged_fbx_path, # For download - DIRECT PATH TO FULL MODEL
        final_merged_fbx_path  # For state (keep original for internal use)
    )

# --- Gradio UI Builder ---
def build_gradio_interface():
    with gr.Blocks(theme=gr.themes.Base()) as demo:
        # Define State variables at the beginning of the Blocks context
        s_original_model_path = gr.State()
        s_model_name = gr.State()
        s_extracted_npz_path = gr.State()
        s_skeleton_fbx_path = gr.State()
        s_skeleton_txt_path = gr.State()
        s_skeleton_npz_path = gr.State()
        s_skinned_fbx_path = gr.State()
        s_skinning_npz_path = gr.State()
        s_merged_fbx_path = gr.State()
        
        gr.Markdown("<h1>UniRig 3D„É¢„Éá„É´Ëá™Âãï„É™„ÇÆ„É≥„Ç∞„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥</h1>")
        gr.Markdown("3D„É¢„Éá„É´ÔºàFBX„ÄÅOBJ„ÄÅGLB/GLTF„ÄÅPLY„Å™„Å©Trimesh„ÅåÊâ±„Åà„ÇãÂΩ¢ÂºèÔºâ„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åó„ÄÅËá™Âãï„Åß„É™„ÇÆ„É≥„Ç∞Âá¶ÁêÜ„ÇíË°å„ÅÑ„Åæ„Åô„ÄÇ")
        gr.Markdown("""
        **üÜï ‰∫åÈöéÂª∫„Å¶„Éï„É≠„Éº„Å´„Çà„ÇãÈ´òÂìÅË≥™„ÉÜ„ÇØ„Çπ„ÉÅ„É£‰øùÊåÅ:**
        - **Á¨¨1ÈöéÂ±§**: ÂÖÉ„É¢„Éá„É´„Åã„Çâ„ÉÜ„ÇØ„Çπ„ÉÅ„É£„Éª„Éû„ÉÜ„É™„Ç¢„É´ÊÉÖÂ†±„ÇíÊäΩÂá∫„Éª‰øùÂ≠ò
        - **Á¨¨2ÈöéÂ±§**: „Çπ„Ç≠„Éã„É≥„Ç∞Ê∏à„Åø„É¢„Éá„É´„Å´‰øùÂ≠ò„Åï„Çå„Åü„ÉÜ„ÇØ„Çπ„ÉÅ„É£„ÇíÈÅ©Áî®
        - **ÁµêÊûú**: „ÉÜ„ÇØ„Çπ„ÉÅ„É£„Å®„Éû„ÉÜ„É™„Ç¢„É´ÂìÅË≥™„ÇíÂÆåÂÖ®„Å´‰øùÊåÅ„Åó„Åü„É™„ÇÆ„É≥„Ç∞Ê∏à„Åø„É¢„Éá„É´
        
        „Éï„É´„Éë„Ç§„Éó„É©„Ç§„É≥„Åß„ÅØËá™ÂãïÁöÑ„Å´‰∫åÈöéÂª∫„Å¶„Éï„É≠„Éº„ÅåÈÅ©Áî®„Åï„Çå„Åæ„Åô„ÄÇ
        """)

        with gr.Tab("„Éï„É´„Éë„Ç§„Éó„É©„Ç§„É≥ÂÆüË°å"):
            gr.Markdown("""
            ## üöÄ „ÉØ„É≥„ÇØ„É™„ÉÉ„ÇØ„ÅßÂÆåÂÖ®Ëá™Âãï„É™„ÇÆ„É≥„Ç∞
            
            **‰∫åÈöéÂª∫„Å¶„Éï„É≠„ÉºÊäÄË°ì„Å´„Çà„ÇãÈ´òÂìÅË≥™Âá¶ÁêÜ:**
            1. **„É°„ÉÉ„Ç∑„É•ÊäΩÂá∫** ‚Üí 3D„É¢„Éá„É´„ÅÆÊßãÈÄ†Ëß£Êûê
            2. **„Çπ„Ç±„É´„Éà„É≥ÁîüÊàê** ‚Üí AI „Å´„Çà„ÇãÊúÄÈÅ©„Å™È™®Ê†ºÊßãÈÄ†‰∫àÊ∏¨
            3. **„Çπ„Ç≠„Éã„É≥„Ç∞Âá¶ÁêÜ** ‚Üí È†ÇÁÇπ„Ç¶„Çß„Ç§„ÉàËá™ÂãïË®àÁÆó
            4. **„ÉÜ„ÇØ„Çπ„ÉÅ„É£Áµ±Âêà„Éû„Éº„Ç∏** ‚Üí ÂÖÉ„ÅÆÂìÅË≥™„Çí‰øùÊåÅ„Åó„ÅüÊúÄÁµÇÁµêÂêà
            
            ‚ú® **ÂæìÊù•ÊñπÂºè„Å®„ÅÆÈÅï„ÅÑ**: „ÉÜ„ÇØ„Çπ„ÉÅ„É£„Éª„Éû„ÉÜ„É™„Ç¢„É´ÊÉÖÂ†±„ÇíÂÆåÂÖ®‰øùÊåÅ„Åó„ÄÅÈ´òÂìÅË≥™„Å™‰ªï‰∏ä„Åå„Çä„ÇíÂÆüÁèæ
            """)
            
            with gr.Row():
                with gr.Column(scale=1):
                    full_input_model_upload = gr.File(label="3D„É¢„Éá„É´„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ", file_types=[".fbx", ".obj", ".glb", ".gltf", ".ply"], type="filepath")
                    full_gender_dropdown = gr.Dropdown(label="ÊÄßÂà•Ôºà„Çπ„Ç±„É´„Éà„É≥ÁîüÊàêÁî®Ôºâ", choices=["female", "male", "neutral"], value="female")
                    full_pipeline_button = gr.Button("üéØ „Éï„É´„Éë„Ç§„Éó„É©„Ç§„É≥ÂÆüË°å", variant="primary", size="lg")
                with gr.Column(scale=2):
                    full_final_model_display = gr.Model3D(label="ÊúÄÁµÇ„É™„ÇÆ„É≥„Ç∞Ê∏à„Åø„É¢„Éá„É´„Éó„É¨„Éì„É•„Éº", interactive=False, camera_position=(0, 2.5, 3.5))
            
            full_pipeline_logs = gr.Textbox(label="„Éï„É´„Éë„Ç§„Éó„É©„Ç§„É≥„É≠„Ç∞", lines=15, interactive=False, show_copy_button=True)
            
            with gr.Accordion("üìÅ ‰∏≠ÈñìÊàêÊûúÁâ©„ÅÆ„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Å®„Éó„É¨„Éì„É•„Éº", open=False):
                gr.Markdown("### Âá¶ÁêÜÊÆµÈöéÂà•„ÅÆÊàêÊûúÁâ©")
                gr.Markdown("ÂêÑÂá¶ÁêÜÊÆµÈöé„ÅßÁîüÊàê„Åï„Çå„Çã„Éï„Ç°„Ç§„É´„Çí„ÉÄ„Ç¶„É≥„É≠„Éº„Éâ„Éª„Éó„É¨„Éì„É•„Éº„Åß„Åç„Åæ„Åô„ÄÇ")
                
                gr.Markdown("#### üîß „Çπ„ÉÜ„ÉÉ„Éó1: „É°„ÉÉ„Ç∑„É•ÊäΩÂá∫ÁµêÊûú")
                full_extracted_npz_download = gr.DownloadButton(label="üì¶ ÊäΩÂá∫NPZ", interactive=True, visible=False)
                
                gr.Markdown("#### ü¶¥ „Çπ„ÉÜ„ÉÉ„Éó2: „Çπ„Ç±„É´„Éà„É≥ÁîüÊàêÁµêÊûú")
                full_skeleton_model_display = gr.Model3D(label="„Çπ„Ç±„É´„Éà„É≥„É¢„Éá„É´„Éó„É¨„Éì„É•„Éº", interactive=False, camera_position=(0, 2.5, 3.5), visible=False)
                with gr.Row():
                    full_skeleton_fbx_download = gr.DownloadButton(label="ü¶¥ „Çπ„Ç±„É´„Éà„É≥ (FBX)", interactive=True, visible=False)
                    full_skeleton_txt_download = gr.DownloadButton(label="üìÑ „Çπ„Ç±„É´„Éà„É≥ (TXT)", interactive=True, visible=False)
                    full_skeleton_npz_download = gr.DownloadButton(label="üì¶ „Çπ„Ç±„É´„Éà„É≥ (NPZ)", interactive=True, visible=False)

                gr.Markdown("#### üé® „Çπ„ÉÜ„ÉÉ„Éó3: „Çπ„Ç≠„Éã„É≥„Ç∞„Ç¶„Çß„Ç§„Éà‰∫àÊ∏¨ÁµêÊûú")
                full_skinned_model_display = gr.Model3D(label="„Çπ„Ç≠„É≥Ê∏à„Åø„É¢„Éá„É´„Éó„É¨„Éì„É•„Éº", interactive=False, camera_position=(0, 2.5, 3.5), visible=False)
                with gr.Row():
                    full_skinned_model_fbx_download = gr.DownloadButton(label="üé® „Çπ„Ç≠„É≥Ê∏à„Åø (FBX)", interactive=True, visible=False)
                    full_skinning_npz_download = gr.DownloadButton(label="üì¶ „Çπ„Ç≠„Éã„É≥„Ç∞ (NPZ)", interactive=True, visible=False)

                gr.Markdown("#### üéØ „Çπ„ÉÜ„ÉÉ„Éó4: ÊúÄÁµÇ„Éû„Éº„Ç∏„É¢„Éá„É´")
                full_final_model_download_accordion = gr.DownloadButton(label="üéØ ÊúÄÁµÇ„É¢„Éá„É´ (FBX)", interactive=True, visible=False)

            full_pipeline_button.click(
                fn=gradio_full_auto_rigging,
                inputs=[
                    full_input_model_upload, 
                    full_gender_dropdown
                ],
                outputs=[
                    full_final_model_display, full_pipeline_logs, full_final_model_download_accordion,
                    full_extracted_npz_download,
                    full_skeleton_model_display, 
                    full_skeleton_fbx_download, full_skeleton_txt_download, full_skeleton_npz_download,
                    full_skinned_model_display, full_skinned_model_fbx_download, full_skinning_npz_download
                ],
                api_name="run_full_auto_rigging"
            ).then(
                fn=lambda d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11: (
                    gr.update(visible=d1 is not None and d1 != ''),  # full_final_model_display
                    gr.update(visible=d3 is not None and d3 != ''),  # full_final_model_download_accordion
                    gr.update(visible=d4 is not None and d4 != ''),  # full_extracted_npz_download
                    gr.update(visible=d5 is not None and d5 != ''),  # full_skeleton_model_display
                    gr.update(visible=d6 is not None and d6 != ''),  # full_skeleton_fbx_download
                    gr.update(visible=d7 is not None and d7 != ''),  # full_skeleton_txt_download
                    gr.update(visible=d8 is not None and d8 != ''),  # full_skeleton_npz_download
                    gr.update(visible=d9 is not None and d9 != ''),  # full_skinned_model_display
                    gr.update(visible=d10 is not None and d10 != ''), # full_skinned_model_fbx_download
                    gr.update(visible=d11 is not None and d11 != '')  # full_skinning_npz_download
                ),
                inputs=[
                    full_final_model_display, full_pipeline_logs, full_final_model_download_accordion,
                    full_extracted_npz_download, full_skeleton_model_display,
                    full_skeleton_fbx_download, full_skeleton_txt_download, full_skeleton_npz_download,
                    full_skinned_model_display, full_skinned_model_fbx_download, full_skinning_npz_download
                ],
                outputs=[
                    full_final_model_display, full_final_model_download_accordion,
                    full_extracted_npz_download, full_skeleton_model_display,
                    full_skeleton_fbx_download, full_skeleton_txt_download, full_skeleton_npz_download,
                    full_skinned_model_display, full_skinned_model_fbx_download, full_skinning_npz_download
                ],
                api_name=False
            )

        with gr.Tab("„Çπ„ÉÜ„ÉÉ„Éó„Éê„Ç§„Çπ„ÉÜ„ÉÉ„ÉóÂÆüË°å"):
            gr.Markdown("""
            ## üõ†Ô∏è ÊÆµÈöéÁöÑ„Å™Âá¶ÁêÜÂÆüË°å
            
            ÂêÑÂá¶ÁêÜ„Çπ„ÉÜ„ÉÉ„Éó„ÇíÂÄãÂà•„Å´ÂÆüË°å„Åó„ÄÅ‰∏≠ÈñìÁµêÊûú„ÇíÁ¢∫Ë™ç„Åó„Å™„Åå„ÇâÈÄ≤„ÇÅ„Çã„Åì„Å®„Åå„Åß„Åç„Åæ„Åô„ÄÇ
            Âá¶ÁêÜ„ÅÆ‰ªïÁµÑ„Åø„ÇíÁêÜËß£„Åó„Åü„ÅÑÂ†¥Âêà„ÇÑ„ÄÅÁâπÂÆö„ÅÆ„Çπ„ÉÜ„ÉÉ„Éó„ÅßÂïèÈ°å„ÅåÁô∫Áîü„Åó„ÅüÂ†¥Âêà„ÅÆË®∫Êñ≠„Å´ÊúâÁî®„Åß„Åô„ÄÇ
            """)
            
            gr.Markdown("### üîß „Çπ„ÉÜ„ÉÉ„Éó0: ÂàùÊúüË®≠ÂÆö„Å®„É°„ÉÉ„Ç∑„É•ÊäΩÂá∫")
            with gr.Row():
                step_upload_button = gr.File(label="1. 3D„É¢„Éá„É´„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ", file_types=[".fbx", ".obj", ".glb", ".gltf", ".ply"], type="filepath")
                step_input_model_display_step0 = gr.Model3D(label="„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„É¢„Éá„É´„Éó„É¨„Éì„É•„Éº", interactive=False, camera_position=(0, 2.5, 3.5))
            
            btn_run_extract = gr.Button("üîß 0. „É°„ÉÉ„Ç∑„É•ÊäΩÂá∫ÂÆüË°å", variant="primary")
            step_extract_logs = gr.Textbox(label="ÊäΩÂá∫„É≠„Ç∞", lines=5, interactive=False, show_copy_button=True)
            step_extracted_model_download = gr.DownloadButton(label="üì¶ ÊäΩÂá∫NPZ", interactive=True, visible=False)

            gr.Markdown("### ü¶¥ „Çπ„ÉÜ„ÉÉ„Éó1: „Çπ„Ç±„É´„Éà„É≥ÁîüÊàê")
            step_gender_dropdown = gr.Dropdown(label="ÊÄßÂà•Ôºà„Çπ„Ç±„É´„Éà„É≥ÁîüÊàêÁî®Ôºâ", choices=["female", "male", "neutral"], value="female")
            btn_run_skeleton = gr.Button("ü¶¥ 1. „Çπ„Ç±„É´„Éà„É≥ÁîüÊàêÂÆüË°å", variant="primary")
            step_skeleton_model_display = gr.Model3D(label="„Çπ„Ç±„É´„Éà„É≥„É¢„Éá„É´„Éó„É¨„Éì„É•„Éº", interactive=False, camera_position=(0, 2.5, 3.5))
            step_skeleton_logs = gr.Textbox(label="„Çπ„Ç±„É´„Éà„É≥ÁîüÊàê„É≠„Ç∞", lines=5, interactive=False, show_copy_button=True)
            with gr.Row():
                step_skeleton_fbx_download = gr.DownloadButton(label="ü¶¥ „Çπ„Ç±„É´„Éà„É≥ (FBX)", interactive=True, visible=False)
                step_skeleton_txt_download = gr.DownloadButton(label="üìÑ „Çπ„Ç±„É´„Éà„É≥ (TXT)", interactive=True, visible=False)
                step_skeleton_npz_download = gr.DownloadButton(label="üì¶ „Çπ„Ç±„É´„Éà„É≥ (NPZ)", interactive=True, visible=False)

            gr.Markdown("### üé® „Çπ„ÉÜ„ÉÉ„Éó2: „Çπ„Ç≠„Éã„É≥„Ç∞„Ç¶„Çß„Ç§„Éà‰∫àÊ∏¨")
            btn_run_skin = gr.Button("üé® 2. „Çπ„Ç≠„Éã„É≥„Ç∞„Ç¶„Çß„Ç§„Éà‰∫àÊ∏¨ÂÆüË°å", variant="primary")
            step_skinned_model_display = gr.Model3D(label="„Çπ„Ç≠„É≥Ê∏à„Åø„É¢„Éá„É´„Éó„É¨„Éì„É•„Éº", interactive=False, camera_position=(0, 2.5, 3.5))
            step_skin_logs = gr.Textbox(label="„Çπ„Ç≠„Éã„É≥„Ç∞„É≠„Ç∞", lines=5, interactive=False, show_copy_button=True)
            with gr.Row():
                step_skinned_model_fbx_download = gr.DownloadButton(label="üé® „Çπ„Ç≠„É≥Ê∏à„Åø (FBX)", interactive=True, visible=False)
                step_skinning_npz_download = gr.DownloadButton(label="üì¶ „Çπ„Ç≠„Éã„É≥„Ç∞ (NPZ)", interactive=True, visible=False)

            gr.Markdown("### üîó „Çπ„ÉÜ„ÉÉ„Éó3: „É¢„Éá„É´„Éû„Éº„Ç∏")
            with gr.Row():
                btn_run_merge = gr.Button("üîó 3a. ÂæìÊù•„É¢„Éá„É´„Éû„Éº„Ç∏ÂÆüË°å", variant="secondary")
                btn_run_merge_with_textures = gr.Button("‚ú® 3b. „ÉÜ„ÇØ„Çπ„ÉÅ„É£Áµ±Âêà„Éû„Éº„Ç∏ÂÆüË°å (Êé®Â•®)", variant="primary")
            step_merged_model_display = gr.Model3D(label="ÊúÄÁµÇ„Éû„Éº„Ç∏„É¢„Éá„É´„Éó„É¨„Éì„É•„Éº", interactive=False, camera_position=(0, 2.5, 3.5))
            step_merge_logs = gr.Textbox(label="„Éû„Éº„Ç∏„É≠„Ç∞", lines=5, interactive=False, show_copy_button=True)
            step_merged_model_download = gr.DownloadButton(label="üéØ ÊúÄÁµÇ„É¢„Éá„É´ (FBX)", interactive=True, visible=False)
            
            with gr.Accordion("üí° ‰∫åÈöéÂª∫„Å¶„Éï„É≠„Éº„Å´„Å§„ÅÑ„Å¶", open=False):
                gr.Markdown("""
                ### üèóÔ∏è ‰∫åÈöéÂ±§„Éï„É≠„ÉºÊäÄË°ì„ÅÆË©≥Á¥∞
                
                **ÂæìÊù•„ÅÆÂïèÈ°åÁÇπ:**
                - „É™„ÇÆ„É≥„Ç∞Âá¶ÁêÜ‰∏≠„Å´„ÉÜ„ÇØ„Çπ„ÉÅ„É£„Éª„Éû„ÉÜ„É™„Ç¢„É´ÊÉÖÂ†±„ÅåÂ§±„Çè„Çå„Çã
                - ÊúÄÁµÇ„É¢„Éá„É´„ÅÆË¶ã„ÅüÁõÆ„ÅåÂÖÉ„É¢„Éá„É´„Å®Áï∞„Å™„Å£„Å¶„Åó„Åæ„ÅÜ
                - ÊâãÂãï„Åß„ÅÆ„ÉÜ„ÇØ„Çπ„ÉÅ„É£Âæ©ÂÖÉ‰ΩúÊ•≠„ÅåÂøÖË¶Å
                
                **‰∫åÈöéÂ±§„Éï„É≠„Éº„ÅÆËß£Ê±∫Á≠ñ:**
                
                **üèóÔ∏è Á¨¨1ÈöéÂ±§ - „ÉÜ„ÇØ„Çπ„ÉÅ„É£‰øùÂ≠ò:**
                1. ÂÖÉ„É¢„Éá„É´„Åã„Çâ„ÉÜ„ÇØ„Çπ„ÉÅ„É£„Éª„Éû„ÉÜ„É™„Ç¢„É´ÊÉÖÂ†±„ÇíÊäΩÂá∫„Éª‰øùÂ≠ò
                2. „Éû„ÉÜ„É™„Ç¢„É´ÊßãÈÄ†Ôºà„Éé„Éº„ÉâÊé•Á∂öÔºâÊÉÖÂ†±„ÇíË®òÈå≤
                3. „É°„ÉÉ„Ç∑„É•-„Éû„ÉÜ„É™„Ç¢„É´ÂØæÂøúÈñ¢‰øÇ„Çí‰øùÂ≠ò
                
                **üèóÔ∏è Á¨¨2ÈöéÂ±§ - „ÉÜ„ÇØ„Çπ„ÉÅ„É£Âæ©ÂÖÉ:**
                1. „Çπ„Ç≠„Éã„É≥„Ç∞Ê∏à„ÅøFBX„ÇíË™≠„ÅøËæº„Åø
                2. ‰øùÂ≠ò„Åï„Çå„Åü„ÉÜ„ÇØ„Çπ„ÉÅ„É£„ÇíÂÜçÈÅ©Áî®
                3. „Éû„ÉÜ„É™„Ç¢„É´ÊßãÈÄ†„ÇíÂÆåÂÖ®ÂÜçÊßãÁØâ
                4. FBX‰∫íÊèõÊÄß„ÇíËÄÉÊÖÆ„Åó„ÅüÊúÄÈÅ©Âåñ
                
                **‚ú® ÁµêÊûú:**
                - ÂÖÉ„É¢„Éá„É´„Å®ÂêåÂìÅË≥™„ÅÆ„ÉÜ„ÇØ„Çπ„ÉÅ„É£„Éª„Éû„ÉÜ„É™„Ç¢„É´
                - ÂÆåÂÖ®„Å™„É™„ÇÆ„É≥„Ç∞Ê©üËÉΩ
                - ÂÆâÂÆö„Åó„Åü„Ç®„É©„ÉºÂá¶ÁêÜ„Å®„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÊ©üËÉΩ
                
                **Êé®Â•®‰ΩøÁî®Â†¥Èù¢:**
                - È´òÂìÅË≥™„Å™3D„É¢„Éá„É´„ÅÆ„É™„ÇÆ„É≥„Ç∞
                - „Ç≤„Éº„É†„Éª„Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥Áî®„Ç¢„Çª„ÉÉ„Éà‰ΩúÊàê
                - ÂïÜÁî®„Éó„É≠„Ç∏„Çß„ÇØ„Éà„Åß„ÅÆÂà©Áî®
                """)
            
            gr.Markdown("""
            **üí° ‰∫åÈöéÂª∫„Å¶„Éï„É≠„Éº„ÅÆÈÅ∏Êäû„Å´„Å§„ÅÑ„Å¶:**
            - **3a. ÂæìÊù•„É¢„Éá„É´„Éû„Éº„Ç∏**: „Çπ„Ç≠„Éã„É≥„Ç∞Ê∏à„ÅøFBX„Çí„Ç™„É™„Ç∏„Éä„É´„É¢„Éá„É´„Å´„Éû„Éº„Ç∏„Åó„Åæ„ÅôÔºàÊóßÊñπÂºèÔºâ
            - **3b. „ÉÜ„ÇØ„Çπ„ÉÅ„É£Áµ±Âêà„Éû„Éº„Ç∏ (Êé®Â•®)**: ÂÖÉ„É¢„Éá„É´„ÅÆ„ÉÜ„ÇØ„Çπ„ÉÅ„É£„Éª„Éû„ÉÜ„É™„Ç¢„É´„Çí‰øùÊåÅ„Åó„Å™„Åå„Çâ„Éû„Éº„Ç∏„Åó„Åæ„ÅôÔºàÊñ∞ÊñπÂºè„ÄÅÈ´òÂìÅË≥™Ôºâ
            
            **Êé®Â•®**: „Çà„ÇäÈ´òÂìÅË≥™„Å™ÁµêÊûú„ÇíÂæó„Çã„Åü„ÇÅ„Äå‚ú® „ÉÜ„ÇØ„Çπ„ÉÅ„É£Áµ±Âêà„Éû„Éº„Ç∏„Äç„Çí„ÅîÂà©Áî®„Åè„Å†„Åï„ÅÑ„ÄÇ
            """)

            # Event handlers for step-by-step execution
            def handle_upload_step(file_path_obj): # Gradio File component with type="filepath" returns a string path
                if file_path_obj:
                    original_path = file_path_obj # This is now a string path
                    model_name_val = os.path.splitext(os.path.basename(original_path))[0]
                    glb_for_display = convert_to_glb_for_display(original_path, f"{model_name_val}_original_display_step")
                    
                   
                    
                    # Reset logs and subsequent step outputs/states
                    extract_log_msg = f"„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂÆå‰∫Ü: {model_name_val}„ÄÇÊäΩÂá∫„ÇíÂÆüË°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"
                    return (
                        original_path, model_name_val, glb_for_display, 
                        extract_log_msg, gr.DownloadButton(visible=False), None, # Extract
                        None, "", gr.DownloadButton(visible=False), gr.DownloadButton(visible=False), gr.DownloadButton(visible=False), None, None, None, # Skeleton
                        None, "", gr.DownloadButton(visible=False), gr.DownloadButton(visible=False), None, None, # Skin
                        None, "", gr.DownloadButton(visible=False), None # Merge
                    )
                # No file uploaded or cleared
                return None, None, None, "„Éï„Ç°„Ç§„É´„Çí„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ", gr.DownloadButton(visible=False), None, None, "", gr.DownloadButton(visible=False), gr.DownloadButton(visible=False), gr.DownloadButton(visible=False), None, None, None, None, "", gr.DownloadButton(visible=False), gr.DownloadButton(visible=False), None, None, None, "", gr.DownloadButton(visible=False), None

            step_upload_button.change( # Use .change for File component when type="filepath"
                fn=handle_upload_step,
                inputs=[step_upload_button],
                outputs=[
                    s_original_model_path, s_model_name, step_input_model_display_step0, 
                    step_extract_logs, step_extracted_model_download, s_extracted_npz_path,
                    step_skeleton_model_display, step_skeleton_logs, step_skeleton_fbx_download, step_skeleton_txt_download, step_skeleton_npz_download,
                    s_skeleton_fbx_path, s_skeleton_txt_path, s_skeleton_npz_path,
                    step_skinned_model_display, step_skin_logs, step_skinned_model_fbx_download, step_skinning_npz_download,
                    s_skinned_fbx_path, s_skinning_npz_path,
                    step_merged_model_display, step_merge_logs, step_merged_model_download,
                    s_merged_fbx_path
                ],
                api_name=False
            )
            
            btn_run_extract.click(
                fn=gradio_extract_mesh,
                inputs=[s_original_model_path, s_model_name],
                outputs=[step_extract_logs, step_extracted_model_download, s_extracted_npz_path],
                api_name="run_extract_mesh_step"
            )
            
            btn_run_skeleton.click(
                fn=gradio_generate_skeleton,
                inputs=[
                    s_extracted_npz_path, # from step 0
                    s_model_name,         # from step 0
                    step_gender_dropdown  # Add gender dropdown
                ],
                outputs=[
                    step_skeleton_model_display, 
                    step_skeleton_logs,
                    step_skeleton_fbx_download,
                    step_skeleton_txt_download,
                    step_skeleton_npz_download,
                    s_skeleton_fbx_path, # State update
                    s_skeleton_npz_path  # State update
                ]
            ).then(
                fn=lambda d1, d2, d3, d4, d5: (gr.update(visible=d1 is not None and d1!=''), gr.update(visible=d2 is not None and d2!=''), gr.update(visible=d3 is not None and d3!=''), gr.update(visible=d4 is not None and d4!=''), gr.update(visible=d5 is not None and d5!='')),
                inputs=[step_skeleton_model_display, step_skeleton_fbx_download, step_skeleton_txt_download, step_skeleton_npz_download, step_skeleton_logs],
                outputs=[step_skeleton_model_display, step_skeleton_fbx_download, step_skeleton_txt_download, step_skeleton_npz_download, step_skeleton_logs],
                api_name=False
            )

            btn_run_skin.click(
                fn=gradio_generate_skin,
                inputs=[
                    s_extracted_npz_path, # raw_data_npz_path - from step 0
                    s_skeleton_fbx_path,  # skeleton_fbx_path - from step 1
                    s_skeleton_npz_path,  # skeleton_npz_path - from step 1
                    s_model_name          # model_name - from step 0
                ],
                outputs=[
                    step_skinned_model_display, step_skin_logs, 
                    step_skinned_model_fbx_download, step_skinning_npz_download,
                    s_skinned_fbx_path, s_skinning_npz_path
                ],
                api_name="run_generate_skin_step"
            )

            btn_run_merge.click(
                fn=gradio_merge_model,
                inputs=[s_original_model_path, s_skinned_fbx_path, s_skinning_npz_path, s_model_name],
                outputs=[
                    step_merged_model_display, step_merge_logs, 
                    step_merged_model_download, 
                    s_merged_fbx_path
                ],
                api_name="run_merge_model_step"
            )

            btn_run_merge_with_textures.click(
                fn=gradio_merge_model_with_textures,
                inputs=[s_original_model_path, s_skinned_fbx_path, s_model_name],
                outputs=[
                    step_merged_model_display, step_merge_logs, 
                    step_merged_model_download, 
                    s_merged_fbx_path
                ],
                api_name="run_merge_model_with_textures_step"
            ) # This is the last click handler in the 'Step-by-step' tab
        
        # Add demo.queue() here, after all UI elements and handlers for the demo are defined
        demo.queue()
            
    return demo

if __name__ == "__main__":
    load_app_config() # Load configuration first

    if not APP_CONFIG:
        logging.error("„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥Ë®≠ÂÆö„ÅÆ„É≠„Éº„Éâ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇËµ∑Âãï„Çí‰∏≠Ê≠¢„Åó„Åæ„Åô„ÄÇ")
        sys.exit(1)

    # Safely access Gradio interface configurations with defaults
    gradio_config = APP_CONFIG.get('gradio_interface', {})
    server_name = gradio_config.get('server_name', '0.0.0.0')  # Changed to 0.0.0.0 for accessibility
    base_port = int(gradio_config.get('server_port', 7860))  # Base port
    share_gradio = gradio_config.get('share', False)
    inbrowser = gradio_config.get('inbrowser', True)
    
    # Try to find an available port starting from base_port
    import socket
    def find_free_port(start_port, max_attempts=10):
        for port in range(start_port, start_port + max_attempts):
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                try:
                    s.bind(('', port))
                    return port
                except OSError:
                    continue
        return None
    
    server_port = find_free_port(base_port)
    if server_port is None:
        logging.error(f"Âà©Áî®ÂèØËÉΩ„Å™„Éù„Éº„Éà„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„ÇìÔºà{base_port}„Åã„Çâ{base_port+9}„Åæ„ÅßË©¶Ë°åÔºâ")
        sys.exit(1)

    logging.info(f"Gradio„Çµ„Éº„Éê„Éº„ÇíËµ∑Âãï„Åó„Åæ„Åô: http://{server_name}:{server_port}")
    if share_gradio:
        logging.info("GradioÂÖ±Êúâ„ÅåÊúâÂäπ„Å´„Å™„Å£„Å¶„ÅÑ„Åæ„Åô„ÄÇ")

    iface = build_gradio_interface()
    
    allowed_paths_list = get_allowed_paths()
    iface.launch(
        server_name=server_name, 
        server_port=server_port, 
        share=share_gradio, 
        inbrowser=inbrowser,
        debug=True, # Force debug=True for this debugging session
        show_error=True, # Enable verbose error reporting
        allowed_paths=allowed_paths_list
    )