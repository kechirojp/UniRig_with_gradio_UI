# ğŸ¯ UniRigãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼çµ±åˆæ•´æµæ–¹æ³• - 2025å¹´6æœˆ14æ—¥åˆ†æçµæœ

## ğŸ“Š åˆ†æå¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«ã®æ•´ç†

### åˆ†ææ¸ˆã¿ãƒ•ã‚¡ã‚¤ãƒ«
1. `unified_naming_completion_report_2025_06_14.md` - çµ±ä¸€å‘½åè¦å‰‡ã®å®Ÿè£…çŠ¶æ³
2. `dataflow_consistency_fix_system_2025_06_14.md` - ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼é½Ÿé½¬ã®ä¿®æ­£ã‚·ã‚¹ãƒ†ãƒ 
3. `unified_naming_convention.instructions.md` - ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸­å¿ƒè¨­è¨ˆã®å‘½åè¦å‰‡

## ğŸš¨ ç™ºè¦‹ã•ã‚ŒãŸæ ¹æœ¬çš„å•é¡Œ

### 1. **ä¸‰å±¤ã®é½Ÿé½¬æ§‹é€ **
```
ãƒ¬ã‚¤ãƒ¤ãƒ¼1: ãƒ¦ãƒ¼ã‚¶ãƒ¼æœŸå¾… ({model_name}_rigged.fbx)
    â†“ é½Ÿé½¬
ãƒ¬ã‚¤ãƒ¤ãƒ¼2: çµ±ä¸€å‘½åè¦å‰‡ ({model_name}_skeleton.fbx)
    â†“ é½Ÿé½¬
ãƒ¬ã‚¤ãƒ¤ãƒ¼3: åŸæµå‡¦ç†å®Ÿè£… (skeleton.fbx, predict_skeleton.npz)
```

### 2. **app.pyã®ç¾çŠ¶ã¨ç†æƒ³ã®ä¹–é›¢**

#### âŒ ç¾åœ¨ã®app.pyå•é¡Œç‚¹
```python
# app.pyã¯å›ºå®šãƒ‘ã‚¹æœŸå¾…
expected = fdm.get_expected_files("step2")
# â†’ {model_name}.fbx, predict_skeleton.npz ã‚’æœŸå¾…

# ã—ã‹ã—ã€çµ±ä¸€å‘½åè¦å‰‡ã§ã¯
# â†’ {model_name}_skeleton.fbx, {model_name}_skeleton.npz ã‚’æœŸå¾…

# åŸæµå‡¦ç†å®Ÿéš›å‡ºåŠ›
# â†’ skeleton.fbx, predict_skeleton.npz
```

## ğŸ¯ çµ±åˆæ•´æµæ–¹æ³•

### Phase 1: **å›ºå®šãƒ‘ã‚¹æˆ¦ç•¥ã®å†è¨­è¨ˆ**

#### ç¾åœ¨ã®FixedDirectoryManagerã‚’æ›´æ–°
```python
# app.pyã®æœŸå¾…ãƒ•ã‚¡ã‚¤ãƒ«æ§‹é€ ã‚’çµ±ä¸€å‘½åè¦å‰‡ã«åˆã‚ã›ã‚‹
def get_expected_files(self, step: str) -> Dict[str, Path]:
    expected_files = {
        "step1": {
            "raw_data_npz": step_dir / "raw_data.npz"  # åŸæµäº’æ›ç¶­æŒ
        },
        "step2": {
            # âœ… çµ±ä¸€å‘½åè¦å‰‡æº–æ‹ ã«å¤‰æ›´
            "skeleton_fbx": step_dir / f"{self.model_name}_skeleton.fbx",
            "skeleton_npz": step_dir / f"{self.model_name}_skeleton.npz"
        },
        "step3": {
            # âœ… çµ±ä¸€å‘½åè¦å‰‡æº–æ‹ ã«å¤‰æ›´
            "skinned_fbx": step_dir / f"{self.model_name}_skinned.fbx",
            "skinning_npz": step_dir / f"{self.model_name}_skinning.npz"
        },
        "step4": {
            "merged_fbx": step_dir / f"{self.model_name}_merged.fbx"
        },
        "step5": {
            "final_fbx": step_dir / f"{self.model_name}_rigged.fbx"  # ãƒ¦ãƒ¼ã‚¶ãƒ¼æœŸå¾…å
        }
    }
```

### Phase 2: **src/pipelineçµ±ä¸€ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼ã®ä¿®æ­£**

#### å„*_unifiedãƒ¡ã‚½ãƒƒãƒ‰ã§å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«åçµ±ä¸€åŒ–å‡¦ç†
```python
class UnifiedSkeletonOrchestrator:
    def generate_skeleton_unified(self, model_name: str, gender: str, extracted_file: str, output_dir: str):
        # 1. åŸæµå‡¦ç†å®Ÿè¡Œ
        success, logs, output_files = self.generate_skeleton(...)
        
        # 2. å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«åçµ±ä¸€åŒ–å‡¦ç†
        if success:
            output_path = Path(output_dir)
            
            # åŸæµå‡¦ç†å‡ºåŠ› â†’ çµ±ä¸€å‘½åè¦å‰‡å¤‰æ›
            original_fbx = output_path / "skeleton.fbx"
            unified_fbx = output_path / f"{model_name}_skeleton.fbx"
            
            original_npz = output_path / "predict_skeleton.npz"
            unified_npz = output_path / f"{model_name}_skeleton.npz"
            
            # ãƒ•ã‚¡ã‚¤ãƒ«åå¤‰æ›´å®Ÿè¡Œ
            if original_fbx.exists():
                original_fbx.rename(unified_fbx)
            if original_npz.exists():
                shutil.copy(original_npz, unified_npz)  # predict_skeleton.npzã¯å¾Œç¶šã§å¿…è¦
        
        return success, logs
```

### Phase 3: **ä¸‰æ®µéšé©å¿œã‚¢ãƒ—ãƒ­ãƒ¼ãƒ**

#### ãƒ¬ãƒ™ãƒ«1: å³åº§é©ç”¨ï¼ˆapp.pyäº’æ›æ€§ç¢ºä¿ï¼‰
```python
# app.pyã®validate_step_inputsã«æŸ”è»Ÿæ€§è¿½åŠ 
def validate_step_inputs(self, step: str) -> Tuple[bool, str, Dict[str, str]]:
    expected = self.get_expected_files(step)
    available_files = {}
    
    for key, path in expected.items():
        if path.exists():
            available_files[key] = str(path)
        else:
            # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ¤œç´¢ï¼ˆåŸæµå‡¦ç†äº’æ›ï¼‰
            fallback_path = self._find_fallback_file(step, key, path)
            if fallback_path and fallback_path.exists():
                available_files[key] = str(fallback_path)
                self.logger.warning(f"ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä½¿ç”¨: {fallback_path}")
            else:
                return False, f"å¿…é ˆãƒ•ã‚¡ã‚¤ãƒ«æœªä½œæˆ: {path}", {}
    
    return True, "å…¥åŠ›æ¤œè¨¼æˆåŠŸ", available_files
```

#### ãƒ¬ãƒ™ãƒ«2: æ®µéšçš„ç§»è¡Œï¼ˆçµ±ä¸€å‘½åè¦å‰‡é©ç”¨ï¼‰
```python
def _find_fallback_file(self, step: str, key: str, expected_path: Path) -> Optional[Path]:
    """åŸæµå‡¦ç†äº’æ›æ€§ã®ãŸã‚ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ¤œç´¢"""
    fallback_patterns = {
        "step2": {
            "skeleton_fbx": [
                expected_path.parent / f"{self.model_name}.fbx",  # åŸæµæœŸå¾…å€¤
                expected_path.parent / "skeleton.fbx"            # åŸæµå®Ÿéš›å‡ºåŠ›
            ],
            "skeleton_npz": [
                expected_path.parent / "predict_skeleton.npz"    # åŸæµå›ºå®šå
            ]
        },
        "step3": {
            "skinned_fbx": [
                expected_path.parent / f"{self.model_name}_skinned_unirig.fbx",
                expected_path.parent / "result_fbx.fbx"
            ]
        }
    }
    
    patterns = fallback_patterns.get(step, {}).get(key, [])
    for pattern in patterns:
        if pattern.exists():
            return pattern
    return None
```

#### ãƒ¬ãƒ™ãƒ«3: å®Œå…¨çµ±ä¸€ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“æœ€é©åŒ–ï¼‰
```python
# æœ€çµ‚çš„ã«ã¯ã™ã¹ã¦ãŒçµ±ä¸€å‘½åè¦å‰‡ã«æº–æ‹ 
# ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ¤œç´¢ã¯å‰Šé™¤
# åŸæµå‡¦ç†è‡ªä½“ã‚‚çµ±ä¸€å‘½åè¦å‰‡ã§å‡ºåŠ›ã™ã‚‹ã‚ˆã†ä¿®æ­£
```

### Phase 4: **æ®µéšçš„æ•´æµå®Ÿè¡Œè¨ˆç”»**

#### Step 1: å³åº§å®Ÿè¡Œå¯èƒ½ãªä¿®æ­£
1. **app.pyã®FixedDirectoryManageræ›´æ–°**
   - get_expected_filesã‚’çµ±ä¸€å‘½åè¦å‰‡æº–æ‹ ã«å¤‰æ›´
   - validate_step_inputsã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ¤œç´¢è¿½åŠ 

2. **src/pipeline/*_unifiedãƒ¡ã‚½ãƒƒãƒ‰å¼·åŒ–**
   - åŸæµå‡¦ç†å‡ºåŠ›ã®çµ±ä¸€å‘½åè¦å‰‡å¤‰æ›å‡¦ç†è¿½åŠ 
   - ãƒ•ã‚¡ã‚¤ãƒ«å­˜åœ¨ç¢ºèªã¨ãƒªãƒãƒ¼ãƒ å‡¦ç†

#### Step 2: è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ä¿®æ­£
1. **quick_inference_skeleton_articulationxl_ar_256.yaml**
   ```yaml
   writer:
     export_fbx: "{model_name}_skeleton"  # skeleton â†’ {model_name}_skeleton
     export_npz: predict_skeleton         # ç¶­æŒï¼ˆåŸæµäº’æ›ï¼‰
   ```

2. **quick_inference_unirig_skin.yaml**
   ```yaml
   # é‡è¤‡writerå®šç¾©ã‚’å®Œå…¨å‰Šé™¤
   writer:
     export_fbx: "{model_name}_skinned"   # çµ±ä¸€å‘½åè¦å‰‡æº–æ‹ 
     export_npz: "{model_name}_skinning"  # çµ±ä¸€å‘½åè¦å‰‡æº–æ‹ 
   ```

#### Step 3: åŸæµå‡¦ç†ã‚¹ã‚¯ãƒªãƒ—ãƒˆä¿®æ­£
1. **generate_skeleton.sh**
   - --model_nameãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¿½åŠ 
   - çµ±ä¸€å‘½åè¦å‰‡å‡ºåŠ›å¯¾å¿œ

2. **generate_skin.sh**
   - npz_dirãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ä¿®æ­£
   - çµ±ä¸€å‘½åè¦å‰‡å‡ºåŠ›å¯¾å¿œ

## ğŸ¯ çµ±åˆåŠ¹æœ

### 1. **ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼é€æ˜åŒ–**
```
ãƒ¦ãƒ¼ã‚¶ãƒ¼å…¥åŠ›: bird.glb
    â†“
Step1: raw_data.npz (åŸæµäº’æ›ç¶­æŒ)
    â†“
Step2: bird_skeleton.fbx + bird_skeleton.npz (çµ±ä¸€å‘½å)
    â†“
Step3: bird_skinned.fbx + bird_skinning.npz (çµ±ä¸€å‘½å)
    â†“
Step4: bird_merged.fbx (çµ±ä¸€å‘½å)
    â†“
Step5: bird_rigged.fbx (ãƒ¦ãƒ¼ã‚¶ãƒ¼æœŸå¾…å)
```

### 2. **ãƒ‡ãƒãƒƒã‚°å®¹æ˜“æ€§ç¢ºä¿**
- å…¨ãƒ•ã‚¡ã‚¤ãƒ«åãŒãƒ¢ãƒ‡ãƒ«åãƒ™ãƒ¼ã‚¹ã§äºˆæ¸¬å¯èƒ½
- ã‚¹ãƒ†ãƒƒãƒ—é–“ã®ãƒ•ã‚¡ã‚¤ãƒ«ä¾å­˜é–¢ä¿‚ãŒæ˜ç¢º
- ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿæ™‚ã®åŸå› ç‰¹å®šãŒè¿…é€Ÿ

### 3. **ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“å‘ä¸Š**
- æŠ€è¡“çš„è¤‡é›‘ã•ã®éš è”½
- ä¸€è²«ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«å‘½åè¦å‰‡
- æœ€çµ‚æˆæœç‰©ã®æ˜ç¢ºãªè­˜åˆ¥

## ğŸ“‹ å®Ÿè£…å„ªå…ˆåº¦

### ğŸ”¥ æœ€é«˜å„ªå…ˆåº¦ï¼ˆå³åº§å®Ÿè¡Œï¼‰
1. FixedDirectoryManagerã®çµ±ä¸€å‘½åè¦å‰‡å¯¾å¿œ
2. src/pipeline/*_unifiedãƒ¡ã‚½ãƒƒãƒ‰ã®ãƒ•ã‚¡ã‚¤ãƒ«åå¤‰æ›å‡¦ç†è¿½åŠ 
3. app.pyã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ¤œç´¢æ©Ÿèƒ½è¿½åŠ 

### âš¡ é«˜å„ªå…ˆåº¦ï¼ˆé€±å†…å®Ÿè¡Œï¼‰
1. è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ä¿®æ­£ï¼ˆYAMLé‡è¤‡é™¤å»ã€çµ±ä¸€å‘½åé©ç”¨ï¼‰
2. åŸæµå‡¦ç†ã‚¹ã‚¯ãƒªãƒ—ãƒˆä¿®æ­£
3. çµ±åˆãƒ†ã‚¹ãƒˆå®Ÿè¡Œ

### ğŸ“ˆ ä¸­å„ªå…ˆåº¦ï¼ˆæ®µéšçš„å®Ÿè¡Œï¼‰
1. ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½ã®æ®µéšçš„å‰Šé™¤
2. å®Œå…¨çµ±ä¸€å‘½åè¦å‰‡ã¸ã®ç§»è¡Œ
3. ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“æœ€çµ‚æœ€é©åŒ–

---

**ğŸ“… ä½œæˆæ—¥**: 2025å¹´6æœˆ14æ—¥  
**ğŸ¯ ç›®æ¨™**: ä¸‰å±¤é½Ÿé½¬ã®å®Œå…¨è§£æ±ºã«ã‚ˆã‚‹é€æ˜ãªãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼ç¢ºç«‹  
**ğŸ“ æœŸå¾…åŠ¹æœ**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“å‘ä¸Šã€ãƒ‡ãƒãƒƒã‚°å®¹æ˜“æ€§ç¢ºä¿ã€ä¿å®ˆæ€§å‘ä¸Š  
**ğŸ”„ å®Ÿè£…æ–¹é‡**: æ®µéšçš„æ•´æµã«ã‚ˆã‚‹å®‰å…¨ãªç§»è¡Œ
