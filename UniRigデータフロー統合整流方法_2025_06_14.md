# 🎯 UniRigデータフロー統合整流方法 - 2025年6月14日分析結果

## 📊 分析対象ファイルの整理

### 分析済みファイル
1. `unified_naming_completion_report_2025_06_14.md` - 統一命名規則の実装状況
2. `dataflow_consistency_fix_system_2025_06_14.md` - データフロー齟齬の修正システム
3. `unified_naming_convention.instructions.md` - ユーザー中心設計の命名規則

## 🚨 発見された根本的問題

### 1. **三層の齟齬構造**
```
レイヤー1: ユーザー期待 ({model_name}_rigged.fbx)
    ↓ 齟齬
レイヤー2: 統一命名規則 ({model_name}_skeleton.fbx)
    ↓ 齟齬
レイヤー3: 原流処理実装 (skeleton.fbx, predict_skeleton.npz)
```

### 2. **app.pyの現状と理想の乖離**

#### ❌ 現在のapp.py問題点
```python
# app.pyは固定パス期待
expected = fdm.get_expected_files("step2")
# → {model_name}.fbx, predict_skeleton.npz を期待

# しかし、統一命名規則では
# → {model_name}_skeleton.fbx, {model_name}_skeleton.npz を期待

# 原流処理実際出力
# → skeleton.fbx, predict_skeleton.npz
```

## 🎯 統合整流方法

### Phase 1: **固定パス戦略の再設計**

#### 現在のFixedDirectoryManagerを更新
```python
# app.pyの期待ファイル構造を統一命名規則に合わせる
def get_expected_files(self, step: str) -> Dict[str, Path]:
    expected_files = {
        "step1": {
            "raw_data_npz": step_dir / "raw_data.npz"  # 原流互換維持
        },
        "step2": {
            # ✅ 統一命名規則準拠に変更
            "skeleton_fbx": step_dir / f"{self.model_name}_skeleton.fbx",
            "skeleton_npz": step_dir / f"{self.model_name}_skeleton.npz"
        },
        "step3": {
            # ✅ 統一命名規則準拠に変更
            "skinned_fbx": step_dir / f"{self.model_name}_skinned.fbx",
            "skinning_npz": step_dir / f"{self.model_name}_skinning.npz"
        },
        "step4": {
            "merged_fbx": step_dir / f"{self.model_name}_merged.fbx"
        },
        "step5": {
            "final_fbx": step_dir / f"{self.model_name}_rigged.fbx"  # ユーザー期待名
        }
    }
```

### Phase 2: **src/pipeline統一オーケストレーターの修正**

#### 各*_unifiedメソッドで出力ファイル名統一化処理
```python
class UnifiedSkeletonOrchestrator:
    def generate_skeleton_unified(self, model_name: str, gender: str, extracted_file: str, output_dir: str):
        # 1. 原流処理実行
        success, logs, output_files = self.generate_skeleton(...)
        
        # 2. 出力ファイル名統一化処理
        if success:
            output_path = Path(output_dir)
            
            # 原流処理出力 → 統一命名規則変換
            original_fbx = output_path / "skeleton.fbx"
            unified_fbx = output_path / f"{model_name}_skeleton.fbx"
            
            original_npz = output_path / "predict_skeleton.npz"
            unified_npz = output_path / f"{model_name}_skeleton.npz"
            
            # ファイル名変更実行
            if original_fbx.exists():
                original_fbx.rename(unified_fbx)
            if original_npz.exists():
                shutil.copy(original_npz, unified_npz)  # predict_skeleton.npzは後続で必要
        
        return success, logs
```

### Phase 3: **三段階適応アプローチ**

#### レベル1: 即座適用（app.py互換性確保）
```python
# app.pyのvalidate_step_inputsに柔軟性追加
def validate_step_inputs(self, step: str) -> Tuple[bool, str, Dict[str, str]]:
    expected = self.get_expected_files(step)
    available_files = {}
    
    for key, path in expected.items():
        if path.exists():
            available_files[key] = str(path)
        else:
            # フォールバック検索（原流処理互換）
            fallback_path = self._find_fallback_file(step, key, path)
            if fallback_path and fallback_path.exists():
                available_files[key] = str(fallback_path)
                self.logger.warning(f"フォールバック使用: {fallback_path}")
            else:
                return False, f"必須ファイル未作成: {path}", {}
    
    return True, "入力検証成功", available_files
```

#### レベル2: 段階的移行（統一命名規則適用）
```python
def _find_fallback_file(self, step: str, key: str, expected_path: Path) -> Optional[Path]:
    """原流処理互換性のためのフォールバック検索"""
    fallback_patterns = {
        "step2": {
            "skeleton_fbx": [
                expected_path.parent / f"{self.model_name}.fbx",  # 原流期待値
                expected_path.parent / "skeleton.fbx"            # 原流実際出力
            ],
            "skeleton_npz": [
                expected_path.parent / "predict_skeleton.npz"    # 原流固定名
            ]
        },
        "step3": {
            "skinned_fbx": [
                expected_path.parent / f"{self.model_name}_skinned_unirig.fbx",
                expected_path.parent / "result_fbx.fbx"
            ]
        }
    }
    
    patterns = fallback_patterns.get(step, {}).get(key, [])
    for pattern in patterns:
        if pattern.exists():
            return pattern
    return None
```

#### レベル3: 完全統一（ユーザー体験最適化）
```python
# 最終的にはすべてが統一命名規則に準拠
# フォールバック検索は削除
# 原流処理自体も統一命名規則で出力するよう修正
```

### Phase 4: **段階的整流実行計画**

#### Step 1: 即座実行可能な修正
1. **app.pyのFixedDirectoryManager更新**
   - get_expected_filesを統一命名規則準拠に変更
   - validate_step_inputsにフォールバック検索追加

2. **src/pipeline/*_unifiedメソッド強化**
   - 原流処理出力の統一命名規則変換処理追加
   - ファイル存在確認とリネーム処理

#### Step 2: 設定ファイル修正
1. **quick_inference_skeleton_articulationxl_ar_256.yaml**
   ```yaml
   writer:
     export_fbx: "{model_name}_skeleton"  # skeleton → {model_name}_skeleton
     export_npz: predict_skeleton         # 維持（原流互換）
   ```

2. **quick_inference_unirig_skin.yaml**
   ```yaml
   # 重複writer定義を完全削除
   writer:
     export_fbx: "{model_name}_skinned"   # 統一命名規則準拠
     export_npz: "{model_name}_skinning"  # 統一命名規則準拠
   ```

#### Step 3: 原流処理スクリプト修正
1. **generate_skeleton.sh**
   - --model_nameパラメータ追加
   - 統一命名規則出力対応

2. **generate_skin.sh**
   - npz_dirパラメータ修正
   - 統一命名規則出力対応

## 🎯 統合効果

### 1. **データフロー透明化**
```
ユーザー入力: bird.glb
    ↓
Step1: raw_data.npz (原流互換維持)
    ↓
Step2: bird_skeleton.fbx + bird_skeleton.npz (統一命名)
    ↓
Step3: bird_skinned.fbx + bird_skinning.npz (統一命名)
    ↓
Step4: bird_merged.fbx (統一命名)
    ↓
Step5: bird_rigged.fbx (ユーザー期待名)
```

### 2. **デバッグ容易性確保**
- 全ファイル名がモデル名ベースで予測可能
- ステップ間のファイル依存関係が明確
- エラー発生時の原因特定が迅速

### 3. **ユーザー体験向上**
- 技術的複雑さの隠蔽
- 一貫したファイル命名規則
- 最終成果物の明確な識別

## 📋 実装優先度

### 🔥 最高優先度（即座実行）
1. FixedDirectoryManagerの統一命名規則対応
2. src/pipeline/*_unifiedメソッドのファイル名変換処理追加
3. app.pyのフォールバック検索機能追加

### ⚡ 高優先度（週内実行）
1. 設定ファイル修正（YAML重複除去、統一命名適用）
2. 原流処理スクリプト修正
3. 統合テスト実行

### 📈 中優先度（段階的実行）
1. フォールバック機能の段階的削除
2. 完全統一命名規則への移行
3. ユーザー体験最終最適化

---

**📅 作成日**: 2025年6月14日  
**🎯 目標**: 三層齟齬の完全解決による透明なデータフロー確立  
**📝 期待効果**: ユーザー体験向上、デバッグ容易性確保、保守性向上  
**🔄 実装方針**: 段階的整流による安全な移行
